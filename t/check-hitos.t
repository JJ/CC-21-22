
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR';
  # Error.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@ti.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Based on my original Error.pm, and Exceptions.pm by Peter Seibel
  # <peter@weblogic.com> and adapted by Jesse Glick <jglick@sig.bsh.com>.
  #
  # but modified ***significantly***
  
  package Error;
  
  use strict;
  use warnings;
  
  use vars qw($VERSION);
  use 5.004;
  
  $VERSION = "0.17022";
  
  use overload (
  	'""'	   =>	'stringify',
  	'0+'	   =>	'value',
  	'bool'     =>	sub { return 1; },
  	'fallback' =>	1
  );
  
  $Error::Depth = 0;	# Depth to pass to caller()
  $Error::Debug = 0;	# Generate verbose stack traces
  @Error::STACK = ();	# Clause stack for try
  $Error::THROWN = undef;	# last error thrown, a workaround until die $ref works
  
  my $LAST;		# Last error created
  my %ERROR;		# Last error associated with package
  
  sub _throw_Error_Simple
  {
      my $args = shift;
      return Error::Simple->new($args->{'text'});
  }
  
  $Error::ObjectifyCallback = \&_throw_Error_Simple;
  
  
  # Exported subs are defined in Error::subs
  
  use Scalar::Util ();
  
  sub import {
      shift;
      my @tags = @_;
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
  
      @tags = grep {
         if( $_ eq ':warndie' ) {
            Error::WarnDie->import();
            0;
         }
         else {
            1;
         }
      } @tags;
  
      Error::subs->import(@tags);
  }
  
  # I really want to use last for the name of this method, but it is a keyword
  # which prevent the syntax  last Error
  
  sub prior {
      shift; # ignore
  
      return $LAST unless @_;
  
      my $pkg = shift;
      return exists $ERROR{$pkg} ? $ERROR{$pkg} : undef
  	unless ref($pkg);
  
      my $obj = $pkg;
      my $err = undef;
      if($obj->isa('HASH')) {
  	$err = $obj->{'__Error__'}
  	    if exists $obj->{'__Error__'};
      }
      elsif($obj->isa('GLOB')) {
  	$err = ${*$obj}{'__Error__'}
  	    if exists ${*$obj}{'__Error__'};
      }
  
      $err;
  }
  
  sub flush {
      shift; #ignore
  
      unless (@_) {
         $LAST = undef;
         return;
      }
  
      my $pkg = shift;
      return unless ref($pkg);
  
      undef $ERROR{$pkg} if defined $ERROR{$pkg};
  }
  
  # Return as much information as possible about where the error
  # happened. The -stacktrace element only exists if $Error::DEBUG
  # was set when the error was created
  
  sub stacktrace {
      my $self = shift;
  
      return $self->{'-stacktrace'}
  	if exists $self->{'-stacktrace'};
  
      my $text = exists $self->{'-text'} ? $self->{'-text'} : "Died";
  
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
  
      $text;
  }
  
  
  sub associate {
      my $err = shift;
      my $obj = shift;
  
      return unless ref($obj);
  
      if($obj->isa('HASH')) {
  	$obj->{'__Error__'} = $err;
      }
      elsif($obj->isa('GLOB')) {
  	${*$obj}{'__Error__'} = $err;
      }
      $obj = ref($obj);
      $ERROR{ ref($obj) } = $err;
  
      return;
  }
  
  
  sub new {
      my $self = shift;
      my($pkg,$file,$line) = caller($Error::Depth);
  
      my $err = bless {
  	'-package' => $pkg,
  	'-file'    => $file,
  	'-line'    => $line,
  	@_
      }, $self;
  
      $err->associate($err->{'-object'})
  	if(exists $err->{'-object'});
  
      # To always create a stacktrace would be very inefficient, so
      # we only do it if $Error::Debug is set
  
      if($Error::Debug) {
  	require Carp;
  	local $Carp::CarpLevel = $Error::Depth;
  	my $text = defined($err->{'-text'}) ? $err->{'-text'} : "Error";
  	my $trace = Carp::longmess($text);
  	# Remove try calls from the trace
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$err->{'-stacktrace'} = $trace
      }
  
      $@ = $LAST = $ERROR{$pkg} = $err;
  }
  
  # Throw an error. this contains some very gory code.
  
  sub throw {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      # if we are not rethrow-ing then create the object to throw
      $self = $self->new(@_) unless ref($self);
  
      die $Error::THROWN = $self;
  }
  
  # syntactic sugar for
  #
  #    die with Error( ... );
  
  sub with {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # syntactic sugar for
  #
  #    record Error( ... ) and return;
  
  sub record {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # catch clause for
  #
  # try { ... } catch CLASS with { ... }
  
  sub catch {
      my $pkg = shift;
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      unshift @$catch,  $pkg, $code;
  
      $clauses;
  }
  
  # Object query methods
  
  sub object {
      my $self = shift;
      exists $self->{'-object'} ? $self->{'-object'} : undef;
  }
  
  sub file {
      my $self = shift;
      exists $self->{'-file'} ? $self->{'-file'} : undef;
  }
  
  sub line {
      my $self = shift;
      exists $self->{'-line'} ? $self->{'-line'} : undef;
  }
  
  sub text {
      my $self = shift;
      exists $self->{'-text'} ? $self->{'-text'} : undef;
  }
  
  # overload methods
  
  sub stringify {
      my $self = shift;
      defined $self->{'-text'} ? $self->{'-text'} : "Died";
  }
  
  sub value {
      my $self = shift;
      exists $self->{'-value'} ? $self->{'-value'} : undef;
  }
  
  package Error::Simple;
  
  use vars qw($VERSION);
  
  $VERSION = "0.17022";
  
  @Error::Simple::ISA = qw(Error);
  
  sub new {
      my $self  = shift;
      my $text  = "" . shift;
      my $value = shift;
      my(@args) = ();
  
      local $Error::Depth = $Error::Depth + 1;
  
      @args = ( -file => $1, -line => $2)
  	if($text =~ s/\s+at\s+(\S+)\s+line\s+(\d+)(?:,\s*<[^>]*>\s+line\s+\d+)?\.?\n?$//s);
      push(@args, '-value', 0 + $value)
  	if defined($value);
  
      $self->SUPER::new(-text => $text, @args);
  }
  
  sub stringify {
      my $self = shift;
      my $text = $self->SUPER::stringify;
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
      $text;
  }
  
  ##########################################################################
  ##########################################################################
  
  # Inspired by code from Jesse Glick <jglick@sig.bsh.com> and
  # Peter Seibel <peter@weblogic.com>
  
  package Error::subs;
  
  use Exporter ();
  use vars qw(@EXPORT_OK @ISA %EXPORT_TAGS);
  
  @EXPORT_OK   = qw(try with finally except otherwise);
  %EXPORT_TAGS = (try => \@EXPORT_OK);
  
  @ISA = qw(Exporter);
  
  sub run_clauses ($$$\@) {
      my($clauses,$err,$wantarray,$result) = @_;
      my $code = undef;
  
      $err = $Error::ObjectifyCallback->({'text' =>$err}) unless ref($err);
  
      CATCH: {
  
  	# catch
  	my $catch;
  	if(defined($catch = $clauses->{'catch'})) {
  	    my $i = 0;
  
  	    CATCHLOOP:
  	    for( ; $i < @$catch ; $i += 2) {
  		my $pkg = $catch->[$i];
  		unless(defined $pkg) {
  		    #except
  		    splice(@$catch,$i,2,$catch->[$i+1]->($err));
  		    $i -= 2;
  		    next CATCHLOOP;
  		}
  		elsif(Scalar::Util::blessed($err) && $err->isa($pkg)) {
  		    $code = $catch->[$i+1];
  		    while(1) {
  			my $more = 0;
  			local($Error::THROWN, $@);
  			my $ok = eval {
  			    $@ = $err;
  			    if($wantarray) {
  				@{$result} = $code->($err,\$more);
  			    }
  			    elsif(defined($wantarray)) {
  			        @{$result} = ();
  				$result->[0] = $code->($err,\$more);
  			    }
  			    else {
  				$code->($err,\$more);
  			    }
  			    1;
  			};
  			if( $ok ) {
  			    next CATCHLOOP if $more;
  			    undef $err;
  			}
  			else {
  			    $err = $@ || $Error::THROWN;
  				$err = $Error::ObjectifyCallback->({'text' =>$err})
  					unless ref($err);
  			}
  			last CATCH;
  		    };
  		}
  	    }
  	}
  
  	# otherwise
  	my $owise;
  	if(defined($owise = $clauses->{'otherwise'})) {
  	    my $code = $clauses->{'otherwise'};
  	    my $more = 0;
          local($Error::THROWN, $@);
  	    my $ok = eval {
  		$@ = $err;
  		if($wantarray) {
  		    @{$result} = $code->($err,\$more);
  		}
  		elsif(defined($wantarray)) {
  		    @{$result} = ();
  		    $result->[0] = $code->($err,\$more);
  		}
  		else {
  		    $code->($err,\$more);
  		}
  		1;
  	    };
  	    if( $ok ) {
  		undef $err;
  	    }
  	    else {
  		$err = $@ || $Error::THROWN;
  
  		$err = $Error::ObjectifyCallback->({'text' =>$err})
  			unless ref($err);
  	    }
  	}
      }
      $err;
  }
  
  sub try (&;$) {
      my $try = shift;
      my $clauses = @_ ? shift : {};
      my $ok = 0;
      my $err = undef;
      my @result = ();
  
      unshift @Error::STACK, $clauses;
  
      my $wantarray = wantarray();
  
      do {
  	local $Error::THROWN = undef;
  	local $@ = undef;
  
  	$ok = eval {
  	    if($wantarray) {
  		@result = $try->();
  	    }
  	    elsif(defined $wantarray) {
  		$result[0] = $try->();
  	    }
  	    else {
  		$try->();
  	    }
  	    1;
  	};
  
  	$err = $@ || $Error::THROWN
  	    unless $ok;
      };
  
      shift @Error::STACK;
  
      $err = run_clauses($clauses,$err,wantarray,@result)
      unless($ok);
  
      $clauses->{'finally'}->()
  	if(defined($clauses->{'finally'}));
  
      if (defined($err))
      {
          if (Scalar::Util::blessed($err) && $err->can('throw'))
          {
              throw $err;
          }
          else
          {
              die $err;
          }
      }
  
      wantarray ? @result : $result[0];
  }
  
  # Each clause adds a sub to the list of clauses. The finally clause is
  # always the last, and the otherwise clause is always added just before
  # the finally clause.
  #
  # All clauses, except the finally clause, add a sub which takes one argument
  # this argument will be the error being thrown. The sub will return a code ref
  # if that clause can handle that error, otherwise undef is returned.
  #
  # The otherwise clause adds a sub which unconditionally returns the users
  # code reference, this is why it is forced to be last.
  #
  # The catch clause is defined in Error.pm, as the syntax causes it to
  # be called as a method
  
  sub with (&;$) {
      @_
  }
  
  sub finally (&) {
      my $code = shift;
      my $clauses = { 'finally' => $code };
      $clauses;
  }
  
  # The except clause is a block which returns a hashref or a list of
  # key-value pairs, where the keys are the classes and the values are subs.
  
  sub except (&;$) {
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      my $sub = sub {
  	my $ref;
  	my(@array) = $code->($_[0]);
  	if(@array == 1 && ref($array[0])) {
  	    $ref = $array[0];
  	    $ref = [ %$ref ]
  		if(UNIVERSAL::isa($ref,'HASH'));
  	}
  	else {
  	    $ref = \@array;
  	}
  	@$ref
      };
  
      unshift @{$catch}, undef, $sub;
  
      $clauses;
  }
  
  sub otherwise (&;$) {
      my $code = shift;
      my $clauses = shift || {};
  
      if(exists $clauses->{'otherwise'}) {
  	require Carp;
  	Carp::croak("Multiple otherwise clauses");
      }
  
      $clauses->{'otherwise'} = $code;
  
      $clauses;
  }
  
  1;
  
  package Error::WarnDie;
  
  sub gen_callstack($)
  {
      my ( $start ) = @_;
  
      require Carp;
      local $Carp::CarpLevel = $start;
      my $trace = Carp::longmess("");
      # Remove try calls from the trace
      $trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
      $trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
      my @callstack = split( m/\n/, $trace );
      return @callstack;
  }
  
  my $old_DIE;
  my $old_WARN;
  
  sub DEATH
  {
      my ( $e ) = @_;
  
      local $SIG{__DIE__} = $old_DIE if( defined $old_DIE );
  
      die @_ if $^S;
  
      my ( $etype, $message, $location, @callstack );
      if ( ref($e) && $e->isa( "Error" ) ) {
          $etype = "exception of type " . ref( $e );
          $message = $e->text;
          $location = $e->file . ":" . $e->line;
          @callstack = split( m/\n/, $e->stacktrace );
      }
      else {
          # Don't apply subsequent layer of message formatting
          die $e if( $e =~ m/^\nUnhandled perl error caught at toplevel:\n\n/ );
          $etype = "perl error";
          my $stackdepth = 0;
          while( caller( $stackdepth ) =~ m/^Error(?:$|::)/ ) {
              $stackdepth++
          }
  
          @callstack = gen_callstack( $stackdepth + 1 );
  
          $message = "$e";
          chomp $message;
  
          if ( $message =~ s/ at (.*?) line (\d+)\.$// ) {
              $location = $1 . ":" . $2;
          }
          else {
              my @caller = caller( $stackdepth );
              $location = $caller[1] . ":" . $caller[2];
          }
      }
  
      shift @callstack;
      # Do it this way in case there are no elements; we don't print a spurious \n
      my $callstack = join( "", map { "$_\n"} @callstack );
  
      die "\nUnhandled $etype caught at toplevel:\n\n  $message\n\nThrown from: $location\n\nFull stack trace:\n\n$callstack\n";
  }
  
  sub TAXES
  {
      my ( $message ) = @_;
  
      local $SIG{__WARN__} = $old_WARN if( defined $old_WARN );
  
      $message =~ s/ at .*? line \d+\.$//;
      chomp $message;
  
      my @callstack = gen_callstack( 1 );
      my $location = shift @callstack;
  
      # $location already starts in a leading space
      $message .= $location;
  
      # Do it this way in case there are no elements; we don't print a spurious \n
      my $callstack = join( "", map { "$_\n"} @callstack );
  
      warn "$message:\n$callstack";
  }
  
  sub import
  {
      $old_DIE  = $SIG{__DIE__};
      $old_WARN = $SIG{__WARN__};
  
      $SIG{__DIE__}  = \&DEATH;
      $SIG{__WARN__} = \&TAXES;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Error - Error/exception handling in an OO-ish way
  
  =head1 WARNING
  
  Using the "Error" module is B<no longer recommended> due to the black-magical
  nature of its syntactic sugar, which often tends to break. Its maintainers
  have stopped actively writing code that uses it, and discourage people
  from doing so. See the "SEE ALSO" section below for better recommendations.
  
  =head1 SYNOPSIS
  
      use Error qw(:try);
  
      throw Error::Simple( "A simple error");
  
      sub xyz {
          ...
  	record Error::Simple("A simple error")
  	    and return;
      }
  
      unlink($file) or throw Error::Simple("$file: $!",$!);
  
      try {
  	do_some_stuff();
  	die "error!" if $condition;
  	throw Error::Simple "Oops!" if $other_condition;
      }
      catch Error::IO with {
  	my $E = shift;
  	print STDERR "File ", $E->{'-file'}, " had a problem\n";
      }
      except {
  	my $E = shift;
  	my $general_handler=sub {send_message $E->{-description}};
  	return {
  	    UserException1 => $general_handler,
  	    UserException2 => $general_handler
  	};
      }
      otherwise {
  	print STDERR "Well I don't know what to say\n";
      }
      finally {
  	close_the_garage_door_already(); # Should be reliable
      }; # Don't forget the trailing ; or you might be surprised
  
  =head1 DESCRIPTION
  
  The C<Error> package provides two interfaces. Firstly C<Error> provides
  a procedural interface to exception handling. Secondly C<Error> is a
  base class for errors/exceptions that can either be thrown, for
  subsequent catch, or can simply be recorded.
  
  Errors in the class C<Error> should not be thrown directly, but the
  user should throw errors from a sub-class of C<Error>.
  
  =head1 PROCEDURAL INTERFACE
  
  C<Error> exports subroutines to perform exception handling. These will
  be exported if the C<:try> tag is used in the C<use> line.
  
  =over 4
  
  =item try BLOCK CLAUSES
  
  C<try> is the main subroutine called by the user. All other subroutines
  exported are clauses to the try subroutine.
  
  The BLOCK will be evaluated and, if no error is throw, try will return
  the result of the block.
  
  C<CLAUSES> are the subroutines below, which describe what to do in the
  event of an error being thrown within BLOCK.
  
  =item catch CLASS with BLOCK
  
  This clauses will cause all errors that satisfy C<$err-E<gt>isa(CLASS)>
  to be caught and handled by evaluating C<BLOCK>.
  
  C<BLOCK> will be passed two arguments. The first will be the error
  being thrown. The second is a reference to a scalar variable. If this
  variable is set by the catch block then, on return from the catch
  block, try will continue processing as if the catch block was never
  found. The error will also be available in C<$@>.
  
  To propagate the error the catch block may call C<$err-E<gt>throw>
  
  If the scalar reference by the second argument is not set, and the
  error is not thrown. Then the current try block will return with the
  result from the catch block.
  
  =item except BLOCK
  
  When C<try> is looking for a handler, if an except clause is found
  C<BLOCK> is evaluated. The return value from this block should be a
  HASHREF or a list of key-value pairs, where the keys are class names
  and the values are CODE references for the handler of errors of that
  type.
  
  =item otherwise BLOCK
  
  Catch any error by executing the code in C<BLOCK>
  
  When evaluated C<BLOCK> will be passed one argument, which will be the
  error being processed. The error will also be available in C<$@>.
  
  Only one otherwise block may be specified per try block
  
  =item finally BLOCK
  
  Execute the code in C<BLOCK> either after the code in the try block has
  successfully completed, or if the try block throws an error then
  C<BLOCK> will be executed after the handler has completed.
  
  If the handler throws an error then the error will be caught, the
  finally block will be executed and the error will be re-thrown.
  
  Only one finally block may be specified per try block
  
  =back
  
  =head1 COMPATIBILITY
  
  L<Moose> exports a keyword called C<with> which clashes with Error's. This
  example returns a prototype mismatch error:
  
      package MyTest;
  
      use warnings;
      use Moose;
      use Error qw(:try);
  
  (Thanks to C<maik.hentsche@amd.com> for the report.).
  
  =head1 CLASS INTERFACE
  
  =head2 CONSTRUCTORS
  
  The C<Error> object is implemented as a HASH. This HASH is initialized
  with the arguments that are passed to it's constructor. The elements
  that are used by, or are retrievable by the C<Error> class are listed
  below, other classes may add to these.
  
  	-file
  	-line
  	-text
  	-value
  	-object
  
  If C<-file> or C<-line> are not specified in the constructor arguments
  then these will be initialized with the file name and line number where
  the constructor was called from.
  
  If the error is associated with an object then the object should be
  passed as the C<-object> argument. This will allow the C<Error> package
  to associate the error with the object.
  
  The C<Error> package remembers the last error created, and also the
  last error associated with a package. This could either be the last
  error created by a sub in that package, or the last error which passed
  an object blessed into that package as the C<-object> argument.
  
  =over 4
  
  =item Error->new()
  
  See the Error::Simple documentation.
  
  =item throw ( [ ARGS ] )
  
  Create a new C<Error> object and throw an error, which will be caught
  by a surrounding C<try> block, if there is one. Otherwise it will cause
  the program to exit.
  
  C<throw> may also be called on an existing error to re-throw it.
  
  =item with ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      die with Some::Error ( ... );
  
  =item record ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      record Some::Error ( ... )
  	and return;
  
  =back
  
  =head2 STATIC METHODS
  
  =over 4
  
  =item prior ( [ PACKAGE ] )
  
  Return the last error created, or the last error associated with
  C<PACKAGE>
  
  =item flush ( [ PACKAGE ] )
  
  Flush the last error created, or the last error associated with
  C<PACKAGE>.It is necessary to clear the error stack before exiting the
  package or uncaught errors generated using C<record> will be reported.
  
       $Error->flush;
  
  =cut
  
  =back
  
  =head2 OBJECT METHODS
  
  =over 4
  
  =item stacktrace
  
  If the variable C<$Error::Debug> was non-zero when the error was
  created, then C<stacktrace> returns a string created by calling
  C<Carp::longmess>. If the variable was zero the C<stacktrace> returns
  the text of the error appended with the filename and line number of
  where the error was created, providing the text does not end with a
  newline.
  
  =item object
  
  The object this error was associated with
  
  =item file
  
  The file where the constructor of this error was called from
  
  =item line
  
  The line where the constructor of this error was called from
  
  =item text
  
  The text of the error
  
  =item $err->associate($obj)
  
  Associates an error with an object to allow error propagation. I.e:
  
      $ber->encode(...) or
          return Error->prior($ber)->associate($ldap);
  
  =back
  
  =head2 OVERLOAD METHODS
  
  =over 4
  
  =item stringify
  
  A method that converts the object into a string. This method may simply
  return the same as the C<text> method, or it may append more
  information. For example the file name and line number.
  
  By default this method returns the C<-text> argument that was passed to
  the constructor, or the string C<"Died"> if none was given.
  
  =item value
  
  A method that will return a value that can be associated with the
  error. For example if an error was created due to the failure of a
  system call, then this may return the numeric value of C<$!> at the
  time.
  
  By default this method returns the C<-value> argument that was passed
  to the constructor.
  
  =back
  
  =head1 PRE-DEFINED ERROR CLASSES
  
  =head2 Error::Simple
  
  This class can be used to hold simple error strings and values. It's
  constructor takes two arguments. The first is a text value, the second
  is a numeric value. These values are what will be returned by the
  overload methods.
  
  If the text value ends with C<at file line 1> as $@ strings do, then
  this information will be used to set the C<-file> and C<-line> arguments
  of the error object.
  
  This class is used internally if an eval'd block die's with an error
  that is a plain string. (Unless C<$Error::ObjectifyCallback> is modified)
  
  
  =head1 $Error::ObjectifyCallback
  
  This variable holds a reference to a subroutine that converts errors that
  are plain strings to objects. It is used by Error.pm to convert textual
  errors to objects, and can be overridden by the user.
  
  It accepts a single argument which is a hash reference to named parameters.
  Currently the only named parameter passed is C<'text'> which is the text
  of the error, but others may be available in the future.
  
  For example the following code will cause Error.pm to throw objects of the
  class MyError::Bar by default:
  
      sub throw_MyError_Bar
      {
          my $args = shift;
          my $err = MyError::Bar->new();
          $err->{'MyBarText'} = $args->{'text'};
          return $err;
      }
  
      {
          local $Error::ObjectifyCallback = \&throw_MyError_Bar;
  
          # Error handling here.
      }
  
  =cut
  
  =head1 MESSAGE HANDLERS
  
  C<Error> also provides handlers to extend the output of the C<warn()> perl
  function, and to handle the printing of a thrown C<Error> that is not caught
  or otherwise handled. These are not installed by default, but are requested
  using the C<:warndie> tag in the C<use> line.
  
   use Error qw( :warndie );
  
  These new error handlers are installed in C<$SIG{__WARN__}> and
  C<$SIG{__DIE__}>. If these handlers are already defined when the tag is
  imported, the old values are stored, and used during the new code. Thus, to
  arrange for custom handling of warnings and errors, you will need to perform
  something like the following:
  
   BEGIN {
     $SIG{__WARN__} = sub {
       print STDERR "My special warning handler: $_[0]"
     };
   }
  
   use Error qw( :warndie );
  
  Note that setting C<$SIG{__WARN__}> after the C<:warndie> tag has been
  imported will overwrite the handler that C<Error> provides. If this cannot be
  avoided, then the tag can be explicitly C<import>ed later
  
   use Error;
  
   $SIG{__WARN__} = ...;
  
   import Error qw( :warndie );
  
  =head2 EXAMPLE
  
  The C<__DIE__> handler turns messages such as
  
   Can't call method "foo" on an undefined value at examples/warndie.pl line 16.
  
  into
  
   Unhandled perl error caught at toplevel:
  
     Can't call method "foo" on an undefined value
  
   Thrown from: examples/warndie.pl:16
  
   Full stack trace:
  
           main::inner('undef') called at examples/warndie.pl line 20
           main::outer('undef') called at examples/warndie.pl line 23
  
  =cut
  
  =head1 SEE ALSO
  
  See L<Exception::Class> for a different module providing Object-Oriented
  exception handling, along with a convenient syntax for declaring hierarchies
  for them. It doesn't provide Error's syntactic sugar of C<try { ... }>,
  C<catch { ... }>, etc. which may be a good thing or a bad thing based
  on what you want. (Because Error's syntactic sugar tends to break.)
  
  L<Error::Exception> aims to combine L<Error> and L<Exception::Class>
  "with correct stringification".
  
  L<TryCatch> and L<Try::Tiny> are similar in concept to Error.pm only providing
  a syntax that hopefully breaks less.
  
  =head1 KNOWN BUGS
  
  None, but that does not mean there are not any.
  
  =head1 AUTHORS
  
  Graham Barr <gbarr@pobox.com>
  
  The code that inspired me to write this was originally written by
  Peter Seibel <peter@weblogic.com> and adapted by Jesse Glick
  <jglick@sig.bsh.com>.
  
  C<:warndie> handlers added by Paul Evans <leonerd@leonerd.org.uk>
  
  =head1 MAINTAINER
  
  Shlomi Fish, L<http://www.shlomifish.org/> .
  
  =head1 PAST MAINTAINERS
  
  Arun Kumar U <u_arunkumar@yahoo.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8  Graham Barr. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
ERROR

$fatpacked{"Error/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_SIMPLE';
  # Error/Simple.pm
  #
  # Copyright (c) 2006 Shlomi Fish <shlomif@shlomifish.org>.
  # This file is free software; you can redistribute it and/or
  # modify it under the terms of the MIT/X11 license (whereas the licence
  # of the Error distribution as a whole is the GPLv1+ and the Artistic
  # licence).
  
  use strict;
  use warnings;
  
  use vars qw($VERSION);
  
  $VERSION = "0.17022";
  
  use Error;
  
  1;
  __END__
  
  =head1 NAME
  
  Error::Simple - the simple error sub-class of Error
  
  =head1 SYNOPSIS
  
      use base 'Error::Simple';
  
  =head1 DESCRIPTION
  
  The only purpose of this module is to allow one to say:
  
      use base 'Error::Simple';
  
  and the only thing it does is "use" Error.pm. Refer to the documentation
  of L<Error> for more information about Error::Simple.
  
  =head1 METHODS
  
  =head2 Error::Simple->new($text [, $value])
  
  Constructs an Error::Simple with the text C<$text> and the optional value
  C<$value>.
  
  =head2 $err->stringify()
  
  Error::Simple overloads this method.
  
  =head1 KNOWN BUGS
  
  None.
  
  =head1 AUTHORS
  
  Shlomi Fish ( L<http://www.shlomifish.org/> )
  
  =head1 SEE ALSO
  
  L<Error>
  
ERROR_SIMPLE

$fatpacked{"File/Slurper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SLURPER';
  package File::Slurper;
  $File::Slurper::VERSION = '0.012';
  use strict;
  use warnings;
  
  use Carp 'croak';
  use Exporter 5.57 'import';
  
  use Encode 2.11 qw/FB_CROAK STOP_AT_PARTIAL/;
  use PerlIO::encoding;
  
  our @EXPORT_OK = qw/read_binary read_text read_lines write_binary write_text read_dir/;
  
  sub read_binary {
  	my $filename = shift;
  
  	# This logic is a bit ugly, but gives a significant speed boost
  	# because slurpy readline is not optimized for non-buffered usage
  	open my $fh, '<:unix', $filename or croak "Couldn't open $filename: $!";
  	if (my $size = -s $fh) {
  		my $buf;
  		my ($pos, $read) = 0;
  		do {
  			defined($read = read $fh, ${$buf}, $size - $pos, $pos) or croak "Couldn't read $filename: $!";
  			$pos += $read;
  		} while ($read && $pos < $size);
  		return ${$buf};
  	}
  	else {
  		return do { local $/; <$fh> };
  	}
  }
  
  use constant {
  	CRLF_DEFAULT => $^O eq 'MSWin32',
  	HAS_UTF8_STRICT => scalar do { local $@; eval { require PerlIO::utf8_strict } },
  };
  
  sub _text_layers {
  	my ($encoding, $crlf) = @_;
  	$crlf = CRLF_DEFAULT if $crlf && $crlf eq 'auto';
  
  	if (HAS_UTF8_STRICT && $encoding =~ /^utf-?8\b/i) {
  		return $crlf ? ':unix:utf8_strict:crlf' : ':unix:utf8_strict';
  	}
  	else {
  		# non-ascii compatible encodings such as UTF-16 need encoding before crlf
  		return $crlf ? ":raw:encoding($encoding):crlf" : ":raw:encoding($encoding)";
  	}
  }
  
  sub read_text {
  	my ($filename, $encoding, $crlf) = @_;
  	$encoding ||= 'utf-8';
  	my $layer = _text_layers($encoding, $crlf);
  
  	local $PerlIO::encoding::fallback = STOP_AT_PARTIAL | FB_CROAK;
  	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
  	return do { local $/; <$fh> };
  }
  
  sub write_text {
  	my ($filename, undef, $encoding, $crlf) = @_;
  	$encoding ||= 'utf-8';
  	my $layer = _text_layers($encoding, $crlf);
  
  	local $PerlIO::encoding::fallback = STOP_AT_PARTIAL | FB_CROAK;
  	open my $fh, ">$layer", $filename or croak "Couldn't open $filename: $!";
  	print $fh $_[1] or croak "Couldn't write to $filename: $!";
  	close $fh or croak "Couldn't write to $filename: $!";
  	return;
  }
  
  sub write_binary {
  	my $filename = $_[0];
  	open my $fh, ">:raw", $filename or croak "Couldn't open $filename: $!";
  	print $fh $_[1] or croak "Couldn't write to $filename: $!";
  	close $fh or croak "Couldn't write to $filename: $!";
  	return;
  }
  
  sub read_lines {
  	my ($filename, $encoding, $crlf, $skip_chomp) = @_;
  	$encoding ||= 'utf-8';
  	my $layer = _text_layers($encoding, $crlf);
  
  	local $PerlIO::encoding::fallback = STOP_AT_PARTIAL | FB_CROAK;
  	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
  	return <$fh> if $skip_chomp;
  	my @buf = <$fh>;
  	close $fh;
  	chomp @buf;
  	return @buf;
  }
  
  sub read_dir {
  	my ($dirname) = @_;
  	opendir my ($dir), $dirname or croak "Could not open $dirname: $!";
  	return grep { not m/ \A \.\.? \z /x } readdir $dir;
  }
  
  1;
  
  # ABSTRACT: A simple, sane and efficient module to slurp a file
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::Slurper - A simple, sane and efficient module to slurp a file
  
  =head1 VERSION
  
  version 0.012
  
  =head1 SYNOPSIS
  
   use File::Slurper 'read_text';
   my $content = read_text($filename);
  
  =head1 DESCRIPTION
  
  This module provides functions for fast and correct slurping and spewing. All functions are optionally exported. All functions throw exceptions on errors, write functions don't return any meaningful value.
  
  =head1 FUNCTIONS
  
  =head2 read_text($filename, $encoding, $crlf)
  
  Reads file C<$filename> into a scalar and decodes it from C<$encoding> (which defaults to UTF-8). If C<$crlf> is true, crlf translation is performed. The default for this argument is off. The special value C<'auto'> will set it to a platform specific default value.
  
  =head2 read_binary($filename)
  
  Reads file C<$filename> into a scalar without any decoding or transformation.
  
  =head2 read_lines($filename, $encoding, $crlf, $skip_chomp)
  
  Reads file C<$filename> into a list/array line-by-line, after decoding from C<$encoding>, optional crlf translation and chomping.
  
  =head2 write_text($filename, $content, $encoding, $crlf)
  
  Writes C<$content> to file C<$filename>, encoding it to C<$encoding> (which defaults to UTF-8). It can also take a C<crlf> argument that works exactly as in read_text.
  
  =head2 write_binary($filename, $content)
  
  Writes C<$content> to file C<$filename> as binary data.
  
  =head2 read_dir($dirname)
  
  Open C<dirname> and return all entries except C<.> and C<..>.
  
  =head1 RATIONALE
  
  This module tries to make it as easy as possible to read and write files correctly and fast. The most correct way of doing this is not always obvious (e.g. L<#83126|https://rt.cpan.org/Public/Bug/Display.html?id=83126>), and just as often the most obvious correct way is not the fastest correct way. This module hides away all such complications behind an easy intuitive interface.
  
  =head1 DEPENDENCIES
  
  This module has an optional dependency on L<PerlIO::utf8_strict|PerlIO::utf8_strict>. Installing this will make UTF-8 encoded IO significantly faster, but should not otherwise affect the operation of this module. This may change into a dependency on the related Unicode::UTF8 in the future.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Path::Tiny|Path::Tiny>
  
  A minimalistic abstraction handling not only IO but also paths.
  
  =item * L<IO::All|IO::All>
  
  An attempt to expose as many IO related features as possible via a single API.
  
  =item * L<File::Slurp|File::Slurp>
  
  This is a previous generation file slurping module. It has a number of issues, as described L<here|http://blogs.perl.org/users/leon_timmermans/2015/08/fileslurp-is-broken-and-wrong.html>.
  
  =item * L<File::Slurp::Tiny|File::Slurp::Tiny>
  
  This was my previous attempt at a better file slurping module. It's mostly (but not entirely) a drop-in replacement for File::Slurp, which is both a feature (easy conversion) and a bug (interface issues).
  
  =back
  
  =head1 TODO
  
  =over 4
  
  =item * C<open_text>/C<open_binary>?
  
  =item * C<drain_handle>?
  
  =back
  
  =head1 AUTHOR
  
  Leon Timmermans <leont@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Leon Timmermans.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_SLURPER

$fatpacked{"Git.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT';
  =head1 NAME
  
  Git - Perl interface to the Git version control system
  
  =cut
  
  
  package Git;
  
  use 5.008;
  use strict;
  
  
  BEGIN {
  
  our ($VERSION, @ISA, @EXPORT, @EXPORT_OK);
  
  # Totally unstable API.
  $VERSION = '0.40';
  
  
  =head1 SYNOPSIS
  
    use Git;
  
    my $version = Git::command_oneline('version');
  
    git_cmd_try { Git::command_noisy('update-server-info') }
                '%s failed w/ code %d';
  
    my $repo = Git->repository (Directory => '/srv/git/cogito.git');
  
  
    my @revs = $repo->command('rev-list', '--since=last monday', '--all');
  
    my ($fh, $c) = $repo->command_output_pipe('rev-list', '--since=last monday', '--all');
    my $lastrev = <$fh>; chomp $lastrev;
    $repo->command_close_pipe($fh, $c);
  
    my $lastrev = $repo->command_oneline( [ 'rev-list', '--all' ],
                                          STDERR => 0 );
  
    my $sha1 = $repo->hash_and_insert_object('file.txt');
    my $tempfile = tempfile();
    my $size = $repo->cat_blob($sha1, $tempfile);
  
  =cut
  
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(git_cmd_try);
  
  # Methods which can be called as standalone functions as well:
  @EXPORT_OK = qw(command command_oneline command_noisy
                  command_output_pipe command_input_pipe command_close_pipe
                  command_bidi_pipe command_close_bidi_pipe
                  version exec_path html_path hash_object git_cmd_try
                  remote_refs prompt
                  get_tz_offset
                  credential credential_read credential_write
                  temp_acquire temp_is_locked temp_release temp_reset temp_path);
  
  
  =head1 DESCRIPTION
  
  This is the Git.pm from github's git/git, which is a mirror of the git source.
  I (cpan msouth, or current maintainer) update the VERSION string here, and 
  maintain this little bit of POD.  That's it.  The only reason you would
  need this is if you are using something like Git::Hooks and you are using
  a perlbrewed (or otherwise separate) perl from the one git is using on your
  system (e.g. if you have a dev perl that's separate from system perl and git
  uses the system perl.  Then the Git.pm gets installed in the system lib and you
  have no way of getting it from CPAN, so your code that uses modules that 
  depend on it doesn't work).  Except for this paragraph and the VERSION
  string, this is just a copy of the latests version of perl/Git.pm from 
  https://raw.github.com/git/git/master/perl/Git.pm .  Or, at least, it should
  be--let me know if it's out of date and I hadn't noticed.)
  
  This module provides Perl scripts easy way to interface the Git version control
  system. The modules have an easy and well-tested way to call arbitrary Git
  commands; in the future, the interface will also provide specialized methods
  for doing easily operations which are not totally trivial to do over
  the generic command interface.
  
  While some commands can be executed outside of any context (e.g. 'version'
  or 'init'), most operations require a repository context, which in practice
  means getting an instance of the Git object using the repository() constructor.
  (In the future, we will also get a new_repository() constructor.) All commands
  called as methods of the object are then executed in the context of the
  repository.
  
  Part of the "repository state" is also information about path to the attached
  working copy (unless you work with a bare repository). You can also navigate
  inside of the working copy using the C<wc_chdir()> method. (Note that
  the repository object is self-contained and will not change working directory
  of your process.)
  
  TODO: In the future, we might also do
  
  	my $remoterepo = $repo->remote_repository (Name => 'cogito', Branch => 'master');
  	$remoterepo ||= Git->remote_repository ('http://git.or.cz/cogito.git/');
  	my @refs = $remoterepo->refs();
  
  Currently, the module merely wraps calls to external Git tools. In the future,
  it will provide a much faster way to interact with Git by linking directly
  to libgit. This should be completely opaque to the user, though (performance
  increase notwithstanding).
  
  =cut
  
  
  use Carp qw(carp croak); # but croak is bad - throw instead
  use Error qw(:try);
  use Cwd qw(abs_path cwd);
  use IPC::Open2 qw(open2);
  use Fcntl qw(SEEK_SET SEEK_CUR);
  use Time::Local qw(timegm);
  }
  
  
  =head1 CONSTRUCTORS
  
  =over 4
  
  =item repository ( OPTIONS )
  
  =item repository ( DIRECTORY )
  
  =item repository ()
  
  Construct a new repository object.
  C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
  Possible options are:
  
  B<Repository> - Path to the Git repository.
  
  B<WorkingCopy> - Path to the associated working copy; not strictly required
  as many commands will happily crunch on a bare repository.
  
  B<WorkingSubdir> - Subdirectory in the working copy to work inside.
  Just left undefined if you do not want to limit the scope of operations.
  
  B<Directory> - Path to the Git working directory in its usual setup.
  The C<.git> directory is searched in the directory and all the parent
  directories; if found, C<WorkingCopy> is set to the directory containing
  it and C<Repository> to the C<.git> directory itself. If no C<.git>
  directory was found, the C<Directory> is assumed to be a bare repository,
  C<Repository> is set to point at it and C<WorkingCopy> is left undefined.
  If the C<$GIT_DIR> environment variable is set, things behave as expected
  as well.
  
  You should not use both C<Directory> and either of C<Repository> and
  C<WorkingCopy> - the results of that are undefined.
  
  Alternatively, a directory path may be passed as a single scalar argument
  to the constructor; it is equivalent to setting only the C<Directory> option
  field.
  
  Calling the constructor with no options whatsoever is equivalent to
  calling it with C<< Directory => '.' >>. In general, if you are building
  a standard porcelain command, simply doing C<< Git->repository() >> should
  do the right thing and setup the object to reflect exactly where the user
  is right now.
  
  =cut
  
  sub repository {
  	my $class = shift;
  	my @args = @_;
  	my %opts = ();
  	my $self;
  
  	if (defined $args[0]) {
  		if ($#args % 2 != 1) {
  			# Not a hash.
  			$#args == 0 or throw Error::Simple("bad usage");
  			%opts = ( Directory => $args[0] );
  		} else {
  			%opts = @args;
  		}
  	}
  
  	if (not defined $opts{Repository} and not defined $opts{WorkingCopy}
  		and not defined $opts{Directory}) {
  		$opts{Directory} = '.';
  	}
  
  	if (defined $opts{Directory}) {
  		-d $opts{Directory} or throw Error::Simple("Directory not found: $opts{Directory} $!");
  
  		my $search = Git->repository(WorkingCopy => $opts{Directory});
  		my $dir;
  		try {
  			$dir = $search->command_oneline(['rev-parse', '--git-dir'],
  			                                STDERR => 0);
  		} catch Git::Error::Command with {
  			$dir = undef;
  		};
  
  		if ($dir) {
  			$dir =~ m#^/# or $dir = $opts{Directory} . '/' . $dir;
  			$opts{Repository} = abs_path($dir);
  
  			# If --git-dir went ok, this shouldn't die either.
  			my $prefix = $search->command_oneline('rev-parse', '--show-prefix');
  			$dir = abs_path($opts{Directory}) . '/';
  			if ($prefix) {
  				if (substr($dir, -length($prefix)) ne $prefix) {
  					throw Error::Simple("rev-parse confused me - $dir does not have trailing $prefix");
  				}
  				substr($dir, -length($prefix)) = '';
  			}
  			$opts{WorkingCopy} = $dir;
  			$opts{WorkingSubdir} = $prefix;
  
  		} else {
  			# A bare repository? Let's see...
  			$dir = $opts{Directory};
  
  			unless (-d "$dir/refs" and -d "$dir/objects" and -e "$dir/HEAD") {
  				# Mimic git-rev-parse --git-dir error message:
  				throw Error::Simple("fatal: Not a git repository: $dir");
  			}
  			my $search = Git->repository(Repository => $dir);
  			try {
  				$search->command('symbolic-ref', 'HEAD');
  			} catch Git::Error::Command with {
  				# Mimic git-rev-parse --git-dir error message:
  				throw Error::Simple("fatal: Not a git repository: $dir");
  			}
  
  			$opts{Repository} = abs_path($dir);
  		}
  
  		delete $opts{Directory};
  	}
  
  	$self = { opts => \%opts };
  	bless $self, $class;
  }
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item command ( COMMAND [, ARGUMENTS... ] )
  
  =item command ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given Git C<COMMAND> (specify it without the 'git-'
  prefix), optionally with the specified extra C<ARGUMENTS>.
  
  The second more elaborate form can be used if you want to further adjust
  the command execution. Currently, only one option is supported:
  
  B<STDERR> - How to deal with the command's error output. By default (C<undef>)
  it is delivered to the caller's C<STDERR>. A false value (0 or '') will cause
  it to be thrown away. If you want to process it, you can get it in a filehandle
  you specify, but you must be extremely careful; if the error output is not
  very short and you want to read it in the same process as where you called
  C<command()>, you are set up for a nice deadlock!
  
  The method can be called without any instance or on a specified Git repository
  (in that case the command will be run in the repository context).
  
  In scalar context, it returns all the command output in a single string
  (verbatim).
  
  In array context, it returns an array containing lines printed to the
  command's stdout (without trailing newlines).
  
  In both cases, the command's stdin and stderr are the same as the caller's.
  
  =cut
  
  sub command {
  	my ($fh, $ctx) = command_output_pipe(@_);
  
  	if (not defined wantarray) {
  		# Nothing to pepper the possible exception with.
  		_cmd_close($ctx, $fh);
  
  	} elsif (not wantarray) {
  		local $/;
  		my $text = <$fh>;
  		try {
  			_cmd_close($ctx, $fh);
  		} catch Git::Error::Command with {
  			# Pepper with the output:
  			my $E = shift;
  			$E->{'-outputref'} = \$text;
  			throw $E;
  		};
  		return $text;
  
  	} else {
  		my @lines = <$fh>;
  		defined and chomp for @lines;
  		try {
  			_cmd_close($ctx, $fh);
  		} catch Git::Error::Command with {
  			my $E = shift;
  			$E->{'-outputref'} = \@lines;
  			throw $E;
  		};
  		return @lines;
  	}
  }
  
  
  =item command_oneline ( COMMAND [, ARGUMENTS... ] )
  
  =item command_oneline ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command()
  does but always return a scalar string containing the first line
  of the command's standard output.
  
  =cut
  
  sub command_oneline {
  	my ($fh, $ctx) = command_output_pipe(@_);
  
  	my $line = <$fh>;
  	defined $line and chomp $line;
  	try {
  		_cmd_close($ctx, $fh);
  	} catch Git::Error::Command with {
  		# Pepper with the output:
  		my $E = shift;
  		$E->{'-outputref'} = \$line;
  		throw $E;
  	};
  	return $line;
  }
  
  
  =item command_output_pipe ( COMMAND [, ARGUMENTS... ] )
  
  =item command_output_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command()
  does but return a pipe filehandle from which the command output can be
  read.
  
  The function can return C<($pipe, $ctx)> in array context.
  See C<command_close_pipe()> for details.
  
  =cut
  
  sub command_output_pipe {
  	_command_common_pipe('-|', @_);
  }
  
  
  =item command_input_pipe ( COMMAND [, ARGUMENTS... ] )
  
  =item command_input_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command_output_pipe()
  does but return an input pipe filehandle instead; the command output
  is not captured.
  
  The function can return C<($pipe, $ctx)> in array context.
  See C<command_close_pipe()> for details.
  
  =cut
  
  sub command_input_pipe {
  	_command_common_pipe('|-', @_);
  }
  
  
  =item command_close_pipe ( PIPE [, CTX ] )
  
  Close the C<PIPE> as returned from C<command_*_pipe()>, checking
  whether the command finished successfully. The optional C<CTX> argument
  is required if you want to see the command name in the error message,
  and it is the second value returned by C<command_*_pipe()> when
  called in array context. The call idiom is:
  
  	my ($fh, $ctx) = $r->command_output_pipe('status');
  	while (<$fh>) { ... }
  	$r->command_close_pipe($fh, $ctx);
  
  Note that you should not rely on whatever actually is in C<CTX>;
  currently it is simply the command name but in future the context might
  have more complicated structure.
  
  =cut
  
  sub command_close_pipe {
  	my ($self, $fh, $ctx) = _maybe_self(@_);
  	$ctx ||= '<unknown>';
  	_cmd_close($ctx, $fh);
  }
  
  =item command_bidi_pipe ( COMMAND [, ARGUMENTS... ] )
  
  Execute the given C<COMMAND> in the same way as command_output_pipe()
  does but return both an input pipe filehandle and an output pipe filehandle.
  
  The function will return return C<($pid, $pipe_in, $pipe_out, $ctx)>.
  See C<command_close_bidi_pipe()> for details.
  
  =cut
  
  sub command_bidi_pipe {
  	my ($pid, $in, $out);
  	my ($self) = _maybe_self(@_);
  	local %ENV = %ENV;
  	my $cwd_save = undef;
  	if ($self) {
  		shift;
  		$cwd_save = cwd();
  		_setup_git_cmd_env($self);
  	}
  	$pid = open2($in, $out, 'git', @_);
  	chdir($cwd_save) if $cwd_save;
  	return ($pid, $in, $out, join(' ', @_));
  }
  
  =item command_close_bidi_pipe ( PID, PIPE_IN, PIPE_OUT [, CTX] )
  
  Close the C<PIPE_IN> and C<PIPE_OUT> as returned from C<command_bidi_pipe()>,
  checking whether the command finished successfully. The optional C<CTX>
  argument is required if you want to see the command name in the error message,
  and it is the fourth value returned by C<command_bidi_pipe()>.  The call idiom
  is:
  
  	my ($pid, $in, $out, $ctx) = $r->command_bidi_pipe('cat-file --batch-check');
  	print $out "000000000\n";
  	while (<$in>) { ... }
  	$r->command_close_bidi_pipe($pid, $in, $out, $ctx);
  
  Note that you should not rely on whatever actually is in C<CTX>;
  currently it is simply the command name but in future the context might
  have more complicated structure.
  
  C<PIPE_IN> and C<PIPE_OUT> may be C<undef> if they have been closed prior to
  calling this function.  This may be useful in a query-response type of
  commands where caller first writes a query and later reads response, eg:
  
  	my ($pid, $in, $out, $ctx) = $r->command_bidi_pipe('cat-file --batch-check');
  	print $out "000000000\n";
  	close $out;
  	while (<$in>) { ... }
  	$r->command_close_bidi_pipe($pid, $in, undef, $ctx);
  
  This idiom may prevent potential dead locks caused by data sent to the output
  pipe not being flushed and thus not reaching the executed command.
  
  =cut
  
  sub command_close_bidi_pipe {
  	local $?;
  	my ($self, $pid, $in, $out, $ctx) = _maybe_self(@_);
  	_cmd_close($ctx, (grep { defined } ($in, $out)));
  	waitpid $pid, 0;
  	if ($? >> 8) {
  		throw Git::Error::Command($ctx, $? >>8);
  	}
  }
  
  
  =item command_noisy ( COMMAND [, ARGUMENTS... ] )
  
  Execute the given C<COMMAND> in the same way as command() does but do not
  capture the command output - the standard output is not redirected and goes
  to the standard output of the caller application.
  
  While the method is called command_noisy(), you might want to as well use
  it for the most silent Git commands which you know will never pollute your
  stdout but you want to avoid the overhead of the pipe setup when calling them.
  
  The function returns only after the command has finished running.
  
  =cut
  
  sub command_noisy {
  	my ($self, $cmd, @args) = _maybe_self(@_);
  	_check_valid_cmd($cmd);
  
  	my $pid = fork;
  	if (not defined $pid) {
  		throw Error::Simple("fork failed: $!");
  	} elsif ($pid == 0) {
  		_cmd_exec($self, $cmd, @args);
  	}
  	if (waitpid($pid, 0) > 0 and $?>>8 != 0) {
  		throw Git::Error::Command(join(' ', $cmd, @args), $? >> 8);
  	}
  }
  
  
  =item version ()
  
  Return the Git version in use.
  
  =cut
  
  sub version {
  	my $verstr = command_oneline('--version');
  	$verstr =~ s/^git version //;
  	$verstr;
  }
  
  
  =item exec_path ()
  
  Return path to the Git sub-command executables (the same as
  C<git --exec-path>). Useful mostly only internally.
  
  =cut
  
  sub exec_path { command_oneline('--exec-path') }
  
  
  =item html_path ()
  
  Return path to the Git html documentation (the same as
  C<git --html-path>). Useful mostly only internally.
  
  =cut
  
  sub html_path { command_oneline('--html-path') }
  
  
  =item get_tz_offset ( TIME )
  
  Return the time zone offset from GMT in the form +/-HHMM where HH is
  the number of hours from GMT and MM is the number of minutes.  This is
  the equivalent of what strftime("%z", ...) would provide on a GNU
  platform.
  
  If TIME is not supplied, the current local time is used.
  
  =cut
  
  sub get_tz_offset {
  	# some systmes don't handle or mishandle %z, so be creative.
  	my $t = shift || time;
  	my $gm = timegm(localtime($t));
  	my $sign = qw( + + - )[ $gm <=> $t ];
  	return sprintf("%s%02d%02d", $sign, (gmtime(abs($t - $gm)))[2,1]);
  }
  
  
  =item prompt ( PROMPT , ISPASSWORD  )
  
  Query user C<PROMPT> and return answer from user.
  
  Honours GIT_ASKPASS and SSH_ASKPASS environment variables for querying
  the user. If no *_ASKPASS variable is set or an error occoured,
  the terminal is tried as a fallback.
  If C<ISPASSWORD> is set and true, the terminal disables echo.
  
  =cut
  
  sub prompt {
  	my ($prompt, $isPassword) = @_;
  	my $ret;
  	if (exists $ENV{'GIT_ASKPASS'}) {
  		$ret = _prompt($ENV{'GIT_ASKPASS'}, $prompt);
  	}
  	if (!defined $ret && exists $ENV{'SSH_ASKPASS'}) {
  		$ret = _prompt($ENV{'SSH_ASKPASS'}, $prompt);
  	}
  	if (!defined $ret) {
  		print STDERR $prompt;
  		STDERR->flush;
  		if (defined $isPassword && $isPassword) {
  			require Term::ReadKey;
  			Term::ReadKey::ReadMode('noecho');
  			$ret = '';
  			while (defined(my $key = Term::ReadKey::ReadKey(0))) {
  				last if $key =~ /[\012\015]/; # \n\r
  				$ret .= $key;
  			}
  			Term::ReadKey::ReadMode('restore');
  			print STDERR "\n";
  			STDERR->flush;
  		} else {
  			chomp($ret = <STDIN>);
  		}
  	}
  	return $ret;
  }
  
  sub _prompt {
  	my ($askpass, $prompt) = @_;
  	return unless length $askpass;
  	$prompt =~ s/\n/ /g;
  	my $ret;
  	open my $fh, "-|", $askpass, $prompt or return;
  	$ret = <$fh>;
  	$ret =~ s/[\015\012]//g; # strip \r\n, chomp does not work on all systems (i.e. windows) as expected
  	close ($fh);
  	return $ret;
  }
  
  =item repo_path ()
  
  Return path to the git repository. Must be called on a repository instance.
  
  =cut
  
  sub repo_path { $_[0]->{opts}->{Repository} }
  
  
  =item wc_path ()
  
  Return path to the working copy. Must be called on a repository instance.
  
  =cut
  
  sub wc_path { $_[0]->{opts}->{WorkingCopy} }
  
  
  =item wc_subdir ()
  
  Return path to the subdirectory inside of a working copy. Must be called
  on a repository instance.
  
  =cut
  
  sub wc_subdir { $_[0]->{opts}->{WorkingSubdir} ||= '' }
  
  
  =item wc_chdir ( SUBDIR )
  
  Change the working copy subdirectory to work within. The C<SUBDIR> is
  relative to the working copy root directory (not the current subdirectory).
  Must be called on a repository instance attached to a working copy
  and the directory must exist.
  
  =cut
  
  sub wc_chdir {
  	my ($self, $subdir) = @_;
  	$self->wc_path()
  		or throw Error::Simple("bare repository");
  
  	-d $self->wc_path().'/'.$subdir
  		or throw Error::Simple("subdir not found: $subdir $!");
  	# Of course we will not "hold" the subdirectory so anyone
  	# can delete it now and we will never know. But at least we tried.
  
  	$self->{opts}->{WorkingSubdir} = $subdir;
  }
  
  
  =item config ( VARIABLE )
  
  Retrieve the configuration C<VARIABLE> in the same manner as C<config>
  does. In scalar context requires the variable to be set only one time
  (exception is thrown otherwise), in array context returns allows the
  variable to be set multiple times and returns all the values.
  
  =cut
  
  sub config {
  	return _config_common({}, @_);
  }
  
  
  =item config_bool ( VARIABLE )
  
  Retrieve the bool configuration C<VARIABLE>. The return value
  is usable as a boolean in perl (and C<undef> if it's not defined,
  of course).
  
  =cut
  
  sub config_bool {
  	my $val = scalar _config_common({'kind' => '--bool'}, @_);
  
  	# Do not rewrite this as return (defined $val && $val eq 'true')
  	# as some callers do care what kind of falsehood they receive.
  	if (!defined $val) {
  		return undef;
  	} else {
  		return $val eq 'true';
  	}
  }
  
  
  =item config_path ( VARIABLE )
  
  Retrieve the path configuration C<VARIABLE>. The return value
  is an expanded path or C<undef> if it's not defined.
  
  =cut
  
  sub config_path {
  	return _config_common({'kind' => '--path'}, @_);
  }
  
  
  =item config_int ( VARIABLE )
  
  Retrieve the integer configuration C<VARIABLE>. The return value
  is simple decimal number.  An optional value suffix of 'k', 'm',
  or 'g' in the config file will cause the value to be multiplied
  by 1024, 1048576 (1024^2), or 1073741824 (1024^3) prior to output.
  It would return C<undef> if configuration variable is not defined,
  
  =cut
  
  sub config_int {
  	return scalar _config_common({'kind' => '--int'}, @_);
  }
  
  # Common subroutine to implement bulk of what the config* family of methods
  # do. This curently wraps command('config') so it is not so fast.
  sub _config_common {
  	my ($opts) = shift @_;
  	my ($self, $var) = _maybe_self(@_);
  
  	try {
  		my @cmd = ('config', $opts->{'kind'} ? $opts->{'kind'} : ());
  		unshift @cmd, $self if $self;
  		if (wantarray) {
  			return command(@cmd, '--get-all', $var);
  		} else {
  			return command_oneline(@cmd, '--get', $var);
  		}
  	} catch Git::Error::Command with {
  		my $E = shift;
  		if ($E->value() == 1) {
  			# Key not found.
  			return;
  		} else {
  			throw $E;
  		}
  	};
  }
  
  =item get_colorbool ( NAME )
  
  Finds if color should be used for NAMEd operation from the configuration,
  and returns boolean (true for "use color", false for "do not use color").
  
  =cut
  
  sub get_colorbool {
  	my ($self, $var) = @_;
  	my $stdout_to_tty = (-t STDOUT) ? "true" : "false";
  	my $use_color = $self->command_oneline('config', '--get-colorbool',
  					       $var, $stdout_to_tty);
  	return ($use_color eq 'true');
  }
  
  =item get_color ( SLOT, COLOR )
  
  Finds color for SLOT from the configuration, while defaulting to COLOR,
  and returns the ANSI color escape sequence:
  
  	print $repo->get_color("color.interactive.prompt", "underline blue white");
  	print "some text";
  	print $repo->get_color("", "normal");
  
  =cut
  
  sub get_color {
  	my ($self, $slot, $default) = @_;
  	my $color = $self->command_oneline('config', '--get-color', $slot, $default);
  	if (!defined $color) {
  		$color = "";
  	}
  	return $color;
  }
  
  =item remote_refs ( REPOSITORY [, GROUPS [, REFGLOBS ] ] )
  
  This function returns a hashref of refs stored in a given remote repository.
  The hash is in the format C<refname =\> hash>. For tags, the C<refname> entry
  contains the tag object while a C<refname^{}> entry gives the tagged objects.
  
  C<REPOSITORY> has the same meaning as the appropriate C<git-ls-remote>
  argument; either a URL or a remote name (if called on a repository instance).
  C<GROUPS> is an optional arrayref that can contain 'tags' to return all the
  tags and/or 'heads' to return all the heads. C<REFGLOB> is an optional array
  of strings containing a shell-like glob to further limit the refs returned in
  the hash; the meaning is again the same as the appropriate C<git-ls-remote>
  argument.
  
  This function may or may not be called on a repository instance. In the former
  case, remote names as defined in the repository are recognized as repository
  specifiers.
  
  =cut
  
  sub remote_refs {
  	my ($self, $repo, $groups, $refglobs) = _maybe_self(@_);
  	my @args;
  	if (ref $groups eq 'ARRAY') {
  		foreach (@$groups) {
  			if ($_ eq 'heads') {
  				push (@args, '--heads');
  			} elsif ($_ eq 'tags') {
  				push (@args, '--tags');
  			} else {
  				# Ignore unknown groups for future
  				# compatibility
  			}
  		}
  	}
  	push (@args, $repo);
  	if (ref $refglobs eq 'ARRAY') {
  		push (@args, @$refglobs);
  	}
  
  	my @self = $self ? ($self) : (); # Ultra trickery
  	my ($fh, $ctx) = Git::command_output_pipe(@self, 'ls-remote', @args);
  	my %refs;
  	while (<$fh>) {
  		chomp;
  		my ($hash, $ref) = split(/\t/, $_, 2);
  		$refs{$ref} = $hash;
  	}
  	Git::command_close_pipe(@self, $fh, $ctx);
  	return \%refs;
  }
  
  
  =item ident ( TYPE | IDENTSTR )
  
  =item ident_person ( TYPE | IDENTSTR | IDENTARRAY )
  
  This suite of functions retrieves and parses ident information, as stored
  in the commit and tag objects or produced by C<var GIT_type_IDENT> (thus
  C<TYPE> can be either I<author> or I<committer>; case is insignificant).
  
  The C<ident> method retrieves the ident information from C<git var>
  and either returns it as a scalar string or as an array with the fields parsed.
  Alternatively, it can take a prepared ident string (e.g. from the commit
  object) and just parse it.
  
  C<ident_person> returns the person part of the ident - name and email;
  it can take the same arguments as C<ident> or the array returned by C<ident>.
  
  The synopsis is like:
  
  	my ($name, $email, $time_tz) = ident('author');
  	"$name <$email>" eq ident_person('author');
  	"$name <$email>" eq ident_person($name);
  	$time_tz =~ /^\d+ [+-]\d{4}$/;
  
  =cut
  
  sub ident {
  	my ($self, $type) = _maybe_self(@_);
  	my $identstr;
  	if (lc $type eq lc 'committer' or lc $type eq lc 'author') {
  		my @cmd = ('var', 'GIT_'.uc($type).'_IDENT');
  		unshift @cmd, $self if $self;
  		$identstr = command_oneline(@cmd);
  	} else {
  		$identstr = $type;
  	}
  	if (wantarray) {
  		return $identstr =~ /^(.*) <(.*)> (\d+ [+-]\d{4})$/;
  	} else {
  		return $identstr;
  	}
  }
  
  sub ident_person {
  	my ($self, @ident) = _maybe_self(@_);
  	$#ident == 0 and @ident = $self ? $self->ident($ident[0]) : ident($ident[0]);
  	return "$ident[0] <$ident[1]>";
  }
  
  
  =item hash_object ( TYPE, FILENAME )
  
  Compute the SHA1 object id of the given C<FILENAME> considering it is
  of the C<TYPE> object type (C<blob>, C<commit>, C<tree>).
  
  The method can be called without any instance or on a specified Git repository,
  it makes zero difference.
  
  The function returns the SHA1 hash.
  
  =cut
  
  # TODO: Support for passing FILEHANDLE instead of FILENAME
  sub hash_object {
  	my ($self, $type, $file) = _maybe_self(@_);
  	command_oneline('hash-object', '-t', $type, $file);
  }
  
  
  =item hash_and_insert_object ( FILENAME )
  
  Compute the SHA1 object id of the given C<FILENAME> and add the object to the
  object database.
  
  The function returns the SHA1 hash.
  
  =cut
  
  # TODO: Support for passing FILEHANDLE instead of FILENAME
  sub hash_and_insert_object {
  	my ($self, $filename) = @_;
  
  	carp "Bad filename \"$filename\"" if $filename =~ /[\r\n]/;
  
  	$self->_open_hash_and_insert_object_if_needed();
  	my ($in, $out) = ($self->{hash_object_in}, $self->{hash_object_out});
  
  	unless (print $out $filename, "\n") {
  		$self->_close_hash_and_insert_object();
  		throw Error::Simple("out pipe went bad");
  	}
  
  	chomp(my $hash = <$in>);
  	unless (defined($hash)) {
  		$self->_close_hash_and_insert_object();
  		throw Error::Simple("in pipe went bad");
  	}
  
  	return $hash;
  }
  
  sub _open_hash_and_insert_object_if_needed {
  	my ($self) = @_;
  
  	return if defined($self->{hash_object_pid});
  
  	($self->{hash_object_pid}, $self->{hash_object_in},
  	 $self->{hash_object_out}, $self->{hash_object_ctx}) =
  		$self->command_bidi_pipe(qw(hash-object -w --stdin-paths --no-filters));
  }
  
  sub _close_hash_and_insert_object {
  	my ($self) = @_;
  
  	return unless defined($self->{hash_object_pid});
  
  	my @vars = map { 'hash_object_' . $_ } qw(pid in out ctx);
  
  	command_close_bidi_pipe(@$self{@vars});
  	delete @$self{@vars};
  }
  
  =item cat_blob ( SHA1, FILEHANDLE )
  
  Prints the contents of the blob identified by C<SHA1> to C<FILEHANDLE> and
  returns the number of bytes printed.
  
  =cut
  
  sub cat_blob {
  	my ($self, $sha1, $fh) = @_;
  
  	$self->_open_cat_blob_if_needed();
  	my ($in, $out) = ($self->{cat_blob_in}, $self->{cat_blob_out});
  
  	unless (print $out $sha1, "\n") {
  		$self->_close_cat_blob();
  		throw Error::Simple("out pipe went bad");
  	}
  
  	my $description = <$in>;
  	if ($description =~ / missing$/) {
  		carp "$sha1 doesn't exist in the repository";
  		return -1;
  	}
  
  	if ($description !~ /^[0-9a-fA-F]{40} \S+ (\d+)$/) {
  		carp "Unexpected result returned from git cat-file";
  		return -1;
  	}
  
  	my $size = $1;
  
  	my $blob;
  	my $bytesLeft = $size;
  
  	while (1) {
  		last unless $bytesLeft;
  
  		my $bytesToRead = $bytesLeft < 1024 ? $bytesLeft : 1024;
  		my $read = read($in, $blob, $bytesToRead);
  		unless (defined($read)) {
  			$self->_close_cat_blob();
  			throw Error::Simple("in pipe went bad");
  		}
  		unless (print $fh $blob) {
  			$self->_close_cat_blob();
  			throw Error::Simple("couldn't write to passed in filehandle");
  		}
  		$bytesLeft -= $read;
  	}
  
  	# Skip past the trailing newline.
  	my $newline;
  	my $read = read($in, $newline, 1);
  	unless (defined($read)) {
  		$self->_close_cat_blob();
  		throw Error::Simple("in pipe went bad");
  	}
  	unless ($read == 1 && $newline eq "\n") {
  		$self->_close_cat_blob();
  		throw Error::Simple("didn't find newline after blob");
  	}
  
  	return $size;
  }
  
  sub _open_cat_blob_if_needed {
  	my ($self) = @_;
  
  	return if defined($self->{cat_blob_pid});
  
  	($self->{cat_blob_pid}, $self->{cat_blob_in},
  	 $self->{cat_blob_out}, $self->{cat_blob_ctx}) =
  		$self->command_bidi_pipe(qw(cat-file --batch));
  }
  
  sub _close_cat_blob {
  	my ($self) = @_;
  
  	return unless defined($self->{cat_blob_pid});
  
  	my @vars = map { 'cat_blob_' . $_ } qw(pid in out ctx);
  
  	command_close_bidi_pipe(@$self{@vars});
  	delete @$self{@vars};
  }
  
  
  =item credential_read( FILEHANDLE )
  
  Reads credential key-value pairs from C<FILEHANDLE>.  Reading stops at EOF or
  when an empty line is encountered.  Each line must be of the form C<key=value>
  with a non-empty key.  Function returns hash with all read values.  Any white
  space (other than new-line character) is preserved.
  
  =cut
  
  sub credential_read {
  	my ($self, $reader) = _maybe_self(@_);
  	my %credential;
  	while (<$reader>) {
  		chomp;
  		if ($_ eq '') {
  			last;
  		} elsif (!/^([^=]+)=(.*)$/) {
  			throw Error::Simple("unable to parse git credential data:\n$_");
  		}
  		$credential{$1} = $2;
  	}
  	return %credential;
  }
  
  =item credential_write( FILEHANDLE, CREDENTIAL_HASHREF )
  
  Writes credential key-value pairs from hash referenced by
  C<CREDENTIAL_HASHREF> to C<FILEHANDLE>.  Keys and values cannot contain
  new-lines or NUL bytes characters, and key cannot contain equal signs nor be
  empty (if they do Error::Simple is thrown).  Any white space is preserved.  If
  value for a key is C<undef>, it will be skipped.
  
  If C<'url'> key exists it will be written first.  (All the other key-value
  pairs are written in sorted order but you should not depend on that).  Once
  all lines are written, an empty line is printed.
  
  =cut
  
  sub credential_write {
  	my ($self, $writer, $credential) = _maybe_self(@_);
  	my ($key, $value);
  
  	# Check if $credential is valid prior to writing anything
  	while (($key, $value) = each %$credential) {
  		if (!defined $key || !length $key) {
  			throw Error::Simple("credential key empty or undefined");
  		} elsif ($key =~ /[=\n\0]/) {
  			throw Error::Simple("credential key contains invalid characters: $key");
  		} elsif (defined $value && $value =~ /[\n\0]/) {
  			throw Error::Simple("credential value for key=$key contains invalid characters: $value");
  		}
  	}
  
  	for $key (sort {
  		# url overwrites other fields, so it must come first
  		return -1 if $a eq 'url';
  		return  1 if $b eq 'url';
  		return $a cmp $b;
  	} keys %$credential) {
  		if (defined $credential->{$key}) {
  			print $writer $key, '=', $credential->{$key}, "\n";
  		}
  	}
  	print $writer "\n";
  }
  
  sub _credential_run {
  	my ($self, $credential, $op) = _maybe_self(@_);
  	my ($pid, $reader, $writer, $ctx) = command_bidi_pipe('credential', $op);
  
  	credential_write $writer, $credential;
  	close $writer;
  
  	if ($op eq "fill") {
  		%$credential = credential_read $reader;
  	}
  	if (<$reader>) {
  		throw Error::Simple("unexpected output from git credential $op response:\n$_\n");
  	}
  
  	command_close_bidi_pipe($pid, $reader, undef, $ctx);
  }
  
  =item credential( CREDENTIAL_HASHREF [, OPERATION ] )
  
  =item credential( CREDENTIAL_HASHREF, CODE )
  
  Executes C<git credential> for a given set of credentials and specified
  operation.  In both forms C<CREDENTIAL_HASHREF> needs to be a reference to
  a hash which stores credentials.  Under certain conditions the hash can
  change.
  
  In the first form, C<OPERATION> can be C<'fill'>, C<'approve'> or C<'reject'>,
  and function will execute corresponding C<git credential> sub-command.  If
  it's omitted C<'fill'> is assumed.  In case of C<'fill'> the values stored in
  C<CREDENTIAL_HASHREF> will be changed to the ones returned by the C<git
  credential fill> command.  The usual usage would look something like:
  
  	my %cred = (
  		'protocol' => 'https',
  		'host' => 'example.com',
  		'username' => 'bob'
  	);
  	Git::credential \%cred;
  	if (try_to_authenticate($cred{'username'}, $cred{'password'})) {
  		Git::credential \%cred, 'approve';
  		... do more stuff ...
  	} else {
  		Git::credential \%cred, 'reject';
  	}
  
  In the second form, C<CODE> needs to be a reference to a subroutine.  The
  function will execute C<git credential fill> to fill the provided credential
  hash, then call C<CODE> with C<CREDENTIAL_HASHREF> as the sole argument.  If
  C<CODE>'s return value is defined, the function will execute C<git credential
  approve> (if return value yields true) or C<git credential reject> (if return
  value is false).  If the return value is undef, nothing at all is executed;
  this is useful, for example, if the credential could neither be verified nor
  rejected due to an unrelated network error.  The return value is the same as
  what C<CODE> returns.  With this form, the usage might look as follows:
  
  	if (Git::credential {
  		'protocol' => 'https',
  		'host' => 'example.com',
  		'username' => 'bob'
  	}, sub {
  		my $cred = shift;
  		return !!try_to_authenticate($cred->{'username'},
  		                             $cred->{'password'});
  	}) {
  		... do more stuff ...
  	}
  
  =cut
  
  sub credential {
  	my ($self, $credential, $op_or_code) = (_maybe_self(@_), 'fill');
  
  	if ('CODE' eq ref $op_or_code) {
  		_credential_run $credential, 'fill';
  		my $ret = $op_or_code->($credential);
  		if (defined $ret) {
  			_credential_run $credential, $ret ? 'approve' : 'reject';
  		}
  		return $ret;
  	} else {
  		_credential_run $credential, $op_or_code;
  	}
  }
  
  { # %TEMP_* Lexical Context
  
  my (%TEMP_FILEMAP, %TEMP_FILES);
  
  =item temp_acquire ( NAME )
  
  Attempts to retrieve the temporary file mapped to the string C<NAME>. If an
  associated temp file has not been created this session or was closed, it is
  created, cached, and set for autoflush and binmode.
  
  Internally locks the file mapped to C<NAME>. This lock must be released with
  C<temp_release()> when the temp file is no longer needed. Subsequent attempts
  to retrieve temporary files mapped to the same C<NAME> while still locked will
  cause an error. This locking mechanism provides a weak guarantee and is not
  threadsafe. It does provide some error checking to help prevent temp file refs
  writing over one another.
  
  In general, the L<File::Handle> returned should not be closed by consumers as
  it defeats the purpose of this caching mechanism. If you need to close the temp
  file handle, then you should use L<File::Temp> or another temp file faculty
  directly. If a handle is closed and then requested again, then a warning will
  issue.
  
  =cut
  
  sub temp_acquire {
  	my $temp_fd = _temp_cache(@_);
  
  	$TEMP_FILES{$temp_fd}{locked} = 1;
  	$temp_fd;
  }
  
  =item temp_is_locked ( NAME )
  
  Returns true if the internal lock created by a previous C<temp_acquire()>
  call with C<NAME> is still in effect.
  
  When temp_acquire is called on a C<NAME>, it internally locks the temporary
  file mapped to C<NAME>.  That lock will not be released until C<temp_release()>
  is called with either the original C<NAME> or the L<File::Handle> that was
  returned from the original call to temp_acquire.
  
  Subsequent attempts to call C<temp_acquire()> with the same C<NAME> will fail
  unless there has been an intervening C<temp_release()> call for that C<NAME>
  (or its corresponding L<File::Handle> that was returned by the original
  C<temp_acquire()> call).
  
  If true is returned by C<temp_is_locked()> for a C<NAME>, an attempt to
  C<temp_acquire()> the same C<NAME> will cause an error unless
  C<temp_release> is first called on that C<NAME> (or its corresponding
  L<File::Handle> that was returned by the original C<temp_acquire()> call).
  
  =cut
  
  sub temp_is_locked {
  	my ($self, $name) = _maybe_self(@_);
  	my $temp_fd = \$TEMP_FILEMAP{$name};
  
  	defined $$temp_fd && $$temp_fd->opened && $TEMP_FILES{$$temp_fd}{locked};
  }
  
  =item temp_release ( NAME )
  
  =item temp_release ( FILEHANDLE )
  
  Releases a lock acquired through C<temp_acquire()>. Can be called either with
  the C<NAME> mapping used when acquiring the temp file or with the C<FILEHANDLE>
  referencing a locked temp file.
  
  Warns if an attempt is made to release a file that is not locked.
  
  The temp file will be truncated before being released. This can help to reduce
  disk I/O where the system is smart enough to detect the truncation while data
  is in the output buffers. Beware that after the temp file is released and
  truncated, any operations on that file may fail miserably until it is
  re-acquired. All contents are lost between each release and acquire mapped to
  the same string.
  
  =cut
  
  sub temp_release {
  	my ($self, $temp_fd, $trunc) = _maybe_self(@_);
  
  	if (exists $TEMP_FILEMAP{$temp_fd}) {
  		$temp_fd = $TEMP_FILES{$temp_fd};
  	}
  	unless ($TEMP_FILES{$temp_fd}{locked}) {
  		carp "Attempt to release temp file '",
  			$temp_fd, "' that has not been locked";
  	}
  	temp_reset($temp_fd) if $trunc and $temp_fd->opened;
  
  	$TEMP_FILES{$temp_fd}{locked} = 0;
  	undef;
  }
  
  sub _temp_cache {
  	my ($self, $name) = _maybe_self(@_);
  
  	_verify_require();
  
  	my $temp_fd = \$TEMP_FILEMAP{$name};
  	if (defined $$temp_fd and $$temp_fd->opened) {
  		if ($TEMP_FILES{$$temp_fd}{locked}) {
  			throw Error::Simple("Temp file with moniker '" .
  				$name . "' already in use");
  		}
  	} else {
  		if (defined $$temp_fd) {
  			# then we're here because of a closed handle.
  			carp "Temp file '", $name,
  				"' was closed. Opening replacement.";
  		}
  		my $fname;
  
  		my $tmpdir;
  		if (defined $self) {
  			$tmpdir = $self->repo_path();
  		}
  
  		($$temp_fd, $fname) = File::Temp::tempfile(
  			'Git_XXXXXX', UNLINK => 1, DIR => $tmpdir,
  			) or throw Error::Simple("couldn't open new temp file");
  
  		$$temp_fd->autoflush;
  		binmode $$temp_fd;
  		$TEMP_FILES{$$temp_fd}{fname} = $fname;
  	}
  	$$temp_fd;
  }
  
  sub _verify_require {
  	eval { require File::Temp; require File::Spec; };
  	$@ and throw Error::Simple($@);
  }
  
  =item temp_reset ( FILEHANDLE )
  
  Truncates and resets the position of the C<FILEHANDLE>.
  
  =cut
  
  sub temp_reset {
  	my ($self, $temp_fd) = _maybe_self(@_);
  
  	truncate $temp_fd, 0
  		or throw Error::Simple("couldn't truncate file");
  	sysseek($temp_fd, 0, SEEK_SET) and seek($temp_fd, 0, SEEK_SET)
  		or throw Error::Simple("couldn't seek to beginning of file");
  	sysseek($temp_fd, 0, SEEK_CUR) == 0 and tell($temp_fd) == 0
  		or throw Error::Simple("expected file position to be reset");
  }
  
  =item temp_path ( NAME )
  
  =item temp_path ( FILEHANDLE )
  
  Returns the filename associated with the given tempfile.
  
  =cut
  
  sub temp_path {
  	my ($self, $temp_fd) = _maybe_self(@_);
  
  	if (exists $TEMP_FILEMAP{$temp_fd}) {
  		$temp_fd = $TEMP_FILEMAP{$temp_fd};
  	}
  	$TEMP_FILES{$temp_fd}{fname};
  }
  
  sub END {
  	unlink values %TEMP_FILEMAP if %TEMP_FILEMAP;
  }
  
  } # %TEMP_* Lexical Context
  
  =back
  
  =head1 ERROR HANDLING
  
  All functions are supposed to throw Perl exceptions in case of errors.
  See the L<Error> module on how to catch those. Most exceptions are mere
  L<Error::Simple> instances.
  
  However, the C<command()>, C<command_oneline()> and C<command_noisy()>
  functions suite can throw C<Git::Error::Command> exceptions as well: those are
  thrown when the external command returns an error code and contain the error
  code as well as access to the captured command's output. The exception class
  provides the usual C<stringify> and C<value> (command's exit code) methods and
  in addition also a C<cmd_output> method that returns either an array or a
  string with the captured command output (depending on the original function
  call context; C<command_noisy()> returns C<undef>) and $<cmdline> which
  returns the command and its arguments (but without proper quoting).
  
  Note that the C<command_*_pipe()> functions cannot throw this exception since
  it has no idea whether the command failed or not. You will only find out
  at the time you C<close> the pipe; if you want to have that automated,
  use C<command_close_pipe()>, which can throw the exception.
  
  =cut
  
  {
  	package Git::Error::Command;
  
  	@Git::Error::Command::ISA = qw(Error);
  
  	sub new {
  		my $self = shift;
  		my $cmdline = '' . shift;
  		my $value = 0 + shift;
  		my $outputref = shift;
  		my(@args) = ();
  
  		local $Error::Depth = $Error::Depth + 1;
  
  		push(@args, '-cmdline', $cmdline);
  		push(@args, '-value', $value);
  		push(@args, '-outputref', $outputref);
  
  		$self->SUPER::new(-text => 'command returned error', @args);
  	}
  
  	sub stringify {
  		my $self = shift;
  		my $text = $self->SUPER::stringify;
  		$self->cmdline() . ': ' . $text . ': ' . $self->value() . "\n";
  	}
  
  	sub cmdline {
  		my $self = shift;
  		$self->{'-cmdline'};
  	}
  
  	sub cmd_output {
  		my $self = shift;
  		my $ref = $self->{'-outputref'};
  		defined $ref or undef;
  		if (ref $ref eq 'ARRAY') {
  			return @$ref;
  		} else { # SCALAR
  			return $$ref;
  		}
  	}
  }
  
  =over 4
  
  =item git_cmd_try { CODE } ERRMSG
  
  This magical statement will automatically catch any C<Git::Error::Command>
  exceptions thrown by C<CODE> and make your program die with C<ERRMSG>
  on its lips; the message will have %s substituted for the command line
  and %d for the exit status. This statement is useful mostly for producing
  more user-friendly error messages.
  
  In case of no exception caught the statement returns C<CODE>'s return value.
  
  Note that this is the only auto-exported function.
  
  =cut
  
  sub git_cmd_try(&$) {
  	my ($code, $errmsg) = @_;
  	my @result;
  	my $err;
  	my $array = wantarray;
  	try {
  		if ($array) {
  			@result = &$code;
  		} else {
  			$result[0] = &$code;
  		}
  	} catch Git::Error::Command with {
  		my $E = shift;
  		$err = $errmsg;
  		$err =~ s/\%s/$E->cmdline()/ge;
  		$err =~ s/\%d/$E->value()/ge;
  		# We can't croak here since Error.pm would mangle
  		# that to Error::Simple.
  	};
  	$err and croak $err;
  	return $array ? @result : $result[0];
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2006 by Petr Baudis E<lt>pasky@suse.czE<gt>.
  
  This module is free software; it may be used, copied, modified
  and distributed under the terms of the GNU General Public Licence,
  either version 2, or (at your option) any later version.
  
  =cut
  
  
  # Take raw method argument list and return ($obj, @args) in case
  # the method was called upon an instance and (undef, @args) if
  # it was called directly.
  sub _maybe_self {
  	UNIVERSAL::isa($_[0], 'Git') ? @_ : (undef, @_);
  }
  
  # Check if the command id is something reasonable.
  sub _check_valid_cmd {
  	my ($cmd) = @_;
  	$cmd =~ /^[a-z0-9A-Z_-]+$/ or throw Error::Simple("bad command: $cmd");
  }
  
  # Common backend for the pipe creators.
  sub _command_common_pipe {
  	my $direction = shift;
  	my ($self, @p) = _maybe_self(@_);
  	my (%opts, $cmd, @args);
  	if (ref $p[0]) {
  		($cmd, @args) = @{shift @p};
  		%opts = ref $p[0] ? %{$p[0]} : @p;
  	} else {
  		($cmd, @args) = @p;
  	}
  	_check_valid_cmd($cmd);
  
  	my $fh;
  	if ($^O eq 'MSWin32') {
  		# ActiveState Perl
  		#defined $opts{STDERR} and
  		#	warn 'ignoring STDERR option - running w/ ActiveState';
  		$direction eq '-|' or
  			die 'input pipe for ActiveState not implemented';
  		# the strange construction with *ACPIPE is just to
  		# explain the tie below that we want to bind to
  		# a handle class, not scalar. It is not known if
  		# it is something specific to ActiveState Perl or
  		# just a Perl quirk.
  		tie (*ACPIPE, 'Git::activestate_pipe', $cmd, @args);
  		$fh = *ACPIPE;
  
  	} else {
  		my $pid = open($fh, $direction);
  		if (not defined $pid) {
  			throw Error::Simple("open failed: $!");
  		} elsif ($pid == 0) {
  			if ($opts{STDERR}) {
  				open (STDERR, '>&', $opts{STDERR})
  					or die "dup failed: $!";
  			} elsif (defined $opts{STDERR}) {
  				open (STDERR, '>', '/dev/null')
  					or die "opening /dev/null failed: $!";
  			}
  			_cmd_exec($self, $cmd, @args);
  		}
  	}
  	return wantarray ? ($fh, join(' ', $cmd, @args)) : $fh;
  }
  
  # When already in the subprocess, set up the appropriate state
  # for the given repository and execute the git command.
  sub _cmd_exec {
  	my ($self, @args) = @_;
  	_setup_git_cmd_env($self);
  	_execv_git_cmd(@args);
  	die qq[exec "@args" failed: $!];
  }
  
  # set up the appropriate state for git command
  sub _setup_git_cmd_env {
  	my $self = shift;
  	if ($self) {
  		$self->repo_path() and $ENV{'GIT_DIR'} = $self->repo_path();
  		$self->repo_path() and $self->wc_path()
  			and $ENV{'GIT_WORK_TREE'} = $self->wc_path();
  		$self->wc_path() and chdir($self->wc_path());
  		$self->wc_subdir() and chdir($self->wc_subdir());
  	}
  }
  
  # Execute the given Git command ($_[0]) with arguments ($_[1..])
  # by searching for it at proper places.
  sub _execv_git_cmd { exec('git', @_); }
  
  # Close pipe to a subprocess.
  sub _cmd_close {
  	my $ctx = shift @_;
  	foreach my $fh (@_) {
  		if (close $fh) {
  			# nop
  		} elsif ($!) {
  			# It's just close, no point in fatalities
  			carp "error closing pipe: $!";
  		} elsif ($? >> 8) {
  			# The caller should pepper this.
  			throw Git::Error::Command($ctx, $? >> 8);
  		}
  		# else we might e.g. closed a live stream; the command
  		# dying of SIGPIPE would drive us here.
  	}
  }
  
  
  sub DESTROY {
  	my ($self) = @_;
  	$self->_close_hash_and_insert_object();
  	$self->_close_cat_blob();
  }
  
  
  # Pipe implementation for ActiveState Perl.
  
  package Git::activestate_pipe;
  use strict;
  
  sub TIEHANDLE {
  	my ($class, @params) = @_;
  	# FIXME: This is probably horrible idea and the thing will explode
  	# at the moment you give it arguments that require some quoting,
  	# but I have no ActiveState clue... --pasky
  	# Let's just hope ActiveState Perl does at least the quoting
  	# correctly.
  	my @data = qx{git @params};
  	bless { i => 0, data => \@data }, $class;
  }
  
  sub READLINE {
  	my $self = shift;
  	if ($self->{i} >= scalar @{$self->{data}}) {
  		return undef;
  	}
  	my $i = $self->{i};
  	if (wantarray) {
  		$self->{i} = $#{$self->{'data'}} + 1;
  		return splice(@{$self->{'data'}}, $i);
  	}
  	$self->{i} = $i + 1;
  	return $self->{'data'}->[ $i ];
  }
  
  sub CLOSE {
  	my $self = shift;
  	delete $self->{data};
  	delete $self->{i};
  }
  
  sub EOF {
  	my $self = shift;
  	return ($self->{i} >= scalar @{$self->{data}});
  }
  
  
  1; # Famous last words
GIT

$fatpacked{"JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON';
  package JSON;
  
  
  use strict;
  use Carp ();
  use base qw(Exporter);
  @JSON::EXPORT = qw(from_json to_json jsonToObj objToJson encode_json decode_json);
  
  BEGIN {
      $JSON::VERSION = '2.90';
      $JSON::DEBUG   = 0 unless (defined $JSON::DEBUG);
      $JSON::DEBUG   = $ENV{ PERL_JSON_DEBUG } if exists $ENV{ PERL_JSON_DEBUG };
  }
  
  my $Module_XS  = 'JSON::XS';
  my $Module_PP  = 'JSON::PP';
  my $Module_bp  = 'JSON::backportPP'; # included in JSON distribution
  my $PP_Version = '2.27203';
  my $XS_Version = '2.34';
  
  
  # XS and PP common methods
  
  my @PublicMethods = qw/
      ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref 
      allow_blessed convert_blessed filter_json_object filter_json_single_key_object 
      shrink max_depth max_size encode decode decode_prefix allow_unknown
  /;
  
  my @Properties = qw/
      ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref
      allow_blessed convert_blessed shrink max_depth max_size allow_unknown
  /;
  
  my @XSOnlyMethods = qw/allow_tags/; # Currently nothing
  
  my @PPOnlyMethods = qw/
      indent_length sort_by
      allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed
  /; # JSON::PP specific
  
  
  # used in _load_xs and _load_pp ($INSTALL_ONLY is not used currently)
  my $_INSTALL_DONT_DIE  = 1; # When _load_xs fails to load XS, don't die.
  my $_INSTALL_ONLY      = 2; # Don't call _set_methods()
  my $_ALLOW_UNSUPPORTED = 0;
  my $_UNIV_CONV_BLESSED = 0;
  my $_USSING_bpPP       = 0;
  
  
  # Check the environment variable to decide worker module. 
  
  unless ($JSON::Backend) {
      $JSON::DEBUG and  Carp::carp("Check used worker module...");
  
      my $backend = exists $ENV{PERL_JSON_BACKEND} ? $ENV{PERL_JSON_BACKEND} : 1;
  
      if ($backend eq '1' or $backend =~ /JSON::XS\s*,\s*JSON::PP/) {
          _load_xs($_INSTALL_DONT_DIE) or _load_pp();
      }
      elsif ($backend eq '0' or $backend eq 'JSON::PP') {
          _load_pp();
      }
      elsif ($backend eq '2' or $backend eq 'JSON::XS') {
          _load_xs();
      }
      elsif ($backend eq 'JSON::backportPP') {
          $_USSING_bpPP = 1;
          _load_pp();
      }
      else {
          Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid.";
      }
  }
  
  
  sub import {
      my $pkg = shift;
      my @what_to_export;
      my $no_export;
  
      for my $tag (@_) {
          if ($tag eq '-support_by_pp') {
              if (!$_ALLOW_UNSUPPORTED++) {
                  JSON::Backend::XS
                      ->support_by_pp(@PPOnlyMethods) if ($JSON::Backend eq $Module_XS);
              }
              next;
          }
          elsif ($tag eq '-no_export') {
              $no_export++, next;
          }
          elsif ( $tag eq '-convert_blessed_universally' ) {
              eval q|
                  require B;
                  *UNIVERSAL::TO_JSON = sub {
                      my $b_obj = B::svref_2object( $_[0] );
                      return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                              : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                              : undef
                              ;
                  }
              | if ( !$_UNIV_CONV_BLESSED++ );
              next;
          }
          push @what_to_export, $tag;
      }
  
      return if ($no_export);
  
      __PACKAGE__->export_to_level(1, $pkg, @what_to_export);
  }
  
  
  # OBSOLETED
  
  sub jsonToObj {
      my $alternative = 'from_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'decode';
      }
      Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";
      return JSON::from_json(@_);
  };
  
  sub objToJson {
      my $alternative = 'to_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'encode';
      }
      Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";
      JSON::to_json(@_);
  };
  
  
  # INTERFACES
  
  sub to_json ($@) {
      if (
          ref($_[0]) eq 'JSON'
          or (@_ > 2 and $_[0] eq 'JSON')
      ) {
          Carp::croak "to_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      $json->encode($_[0]);
  }
  
  
  sub from_json ($@) {
      if ( ref($_[0]) eq 'JSON' or $_[0] eq 'JSON' ) {
          Carp::croak "from_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      return $json->decode( $_[0] );
  }
  
  
  
  sub true  { $JSON::true  }
  
  sub false { $JSON::false }
  
  sub null  { undef; }
  
  
  sub require_xs_version { $XS_Version; }
  
  sub backend {
      my $proto = shift;
      $JSON::Backend;
  }
  
  #*module = *backend;
  
  
  sub is_xs {
      return $_[0]->backend eq $Module_XS;
  }
  
  
  sub is_pp {
      return not $_[0]->is_xs;
  }
  
  
  sub pureperl_only_methods { @PPOnlyMethods; }
  
  
  sub property {
      my ($self, $name, $value) = @_;
  
      if (@_ == 1) {
          my %props;
          for $name (@Properties) {
              my $method = 'get_' . $name;
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  $props{$name} = $value == 1 ? 0 : $value;
                  next;
              }
              $props{$name} = $self->$method();
          }
          return \%props;
      }
      elsif (@_ > 3) {
          Carp::croak('property() can take only the option within 2 arguments.');
      }
      elsif (@_ == 2) {
          if ( my $method = $self->can('get_' . $name) ) {
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  return $value == 1 ? 0 : $value;
              }
              $self->$method();
          }
      }
      else {
          $self->$name($value);
      }
  
  }
  
  
  
  # INTERNAL
  
  sub _load_xs {
      my $opt = shift;
  
      $JSON::DEBUG and Carp::carp "Load $Module_XS.";
  
      # if called after install module, overload is disable.... why?
      JSON::Boolean::_overrride_overload($Module_XS);
      JSON::Boolean::_overrride_overload($Module_PP);
  
      eval qq|
          use $Module_XS $XS_Version ();
      |;
  
      if ($@) {
          if (defined $opt and $opt & $_INSTALL_DONT_DIE) {
              $JSON::DEBUG and Carp::carp "Can't load $Module_XS...($@)";
              return 0;
          }
          Carp::croak $@;
      }
  
      unless (defined $opt and $opt & $_INSTALL_ONLY) {
          _set_module( $JSON::Backend = $Module_XS );
          my $data = join("", <DATA>); # this code is from Jcode 2.xx.
          close(DATA);
          eval $data;
          JSON::Backend::XS->init;
      }
  
      return 1;
  };
  
  
  sub _load_pp {
      my $opt = shift;
      my $backend = $_USSING_bpPP ? $Module_bp : $Module_PP;
  
      $JSON::DEBUG and Carp::carp "Load $backend.";
  
      # if called after install module, overload is disable.... why?
      JSON::Boolean::_overrride_overload($Module_XS);
      JSON::Boolean::_overrride_overload($backend);
  
      if ( $_USSING_bpPP ) {
          eval qq| require $backend |;
      }
      else {
          eval qq| use $backend $PP_Version () |;
      }
  
      if ($@) {
          if ( $backend eq $Module_PP ) {
              $JSON::DEBUG and Carp::carp "Can't load $Module_PP ($@), so try to load $Module_bp";
              $_USSING_bpPP++;
              $backend = $Module_bp;
              JSON::Boolean::_overrride_overload($backend);
              local $^W; # if PP installed but invalid version, backportPP redefines methods.
              eval qq| require $Module_bp |;
          }
          Carp::croak $@ if $@;
      }
  
      unless (defined $opt and $opt & $_INSTALL_ONLY) {
          _set_module( $JSON::Backend = $Module_PP ); # even if backportPP, set $Backend with 'JSON::PP'
          JSON::Backend::PP->init;
      }
  };
  
  
  sub _set_module {
      return if defined $JSON::true;
  
      my $module = shift;
  
      local $^W;
      no strict qw(refs);
  
      $JSON::true  = ${"$module\::true"};
      $JSON::false = ${"$module\::false"};
  
      push @JSON::ISA, $module;
      if ( JSON->is_xs and JSON->backend->VERSION < 3 ) {
          eval 'package JSON::PP::Boolean';
          push @{"$module\::Boolean::ISA"}, qw(JSON::PP::Boolean);
      }
  
      *{"JSON::is_bool"} = \&{"$module\::is_bool"};
  
      for my $method ($module eq $Module_XS ? @PPOnlyMethods : @XSOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported in $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  
  
  #
  # JSON Boolean
  #
  
  package JSON::Boolean;
  
  my %Installed;
  
  sub _overrride_overload {
      return; # this function is currently disable.
      return if ($Installed{ $_[0] }++);
  
      my $boolean = $_[0] . '::Boolean';
  
      eval sprintf(q|
          package %s;
          use overload (
              '""' => sub { ${$_[0]} == 1 ? 'true' : 'false' },
              'eq' => sub {
                  my ($obj, $op) = ref ($_[0]) ? ($_[0], $_[1]) : ($_[1], $_[0]);
                  if ($op eq 'true' or $op eq 'false') {
                      return "$obj" eq 'true' ? 'true' eq $op : 'false' eq $op;
                  }
                  else {
                      return $obj ? 1 == $op : 0 == $op;
                  }
              },
          );
      |, $boolean);
  
      if ($@) { Carp::croak $@; }
  
      if ( exists $INC{'JSON/XS.pm'} and $boolean eq 'JSON::XS::Boolean' ) {
          local $^W;
          my $true  = do { bless \(my $dummy = 1), $boolean };
          my $false = do { bless \(my $dummy = 0), $boolean };
          *JSON::XS::true  = sub () { $true };
          *JSON::XS::false = sub () { $false };
      }
      elsif ( exists $INC{'JSON/PP.pm'} and $boolean eq 'JSON::PP::Boolean' ) {
          local $^W;
          my $true  = do { bless \(my $dummy = 1), $boolean };
          my $false = do { bless \(my $dummy = 0), $boolean };
          *JSON::PP::true  = sub { $true };
          *JSON::PP::false = sub { $false };
      }
  
      return 1;
  }
  
  
  #
  # Helper classes for Backend Module (PP)
  #
  
  package JSON::Backend::PP;
  
  sub init {
      local $^W;
      no strict qw(refs); # this routine may be called after JSON::Backend::XS init was called.
      *{"JSON::decode_json"} = \&{"JSON::PP::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::PP::encode_json"};
      *{"JSON::PP::is_xs"}  = sub { 0 };
      *{"JSON::PP::is_pp"}  = sub { 1 };
      return 1;
  }
  
  #
  # To save memory, the below lines are read only when XS backend is used.
  #
  
  package JSON;
  
  1;
  __DATA__
  
  
  #
  # Helper classes for Backend Module (XS)
  #
  
  package JSON::Backend::XS;
  
  use constant INDENT_LENGTH_FLAG => 15 << 12;
  
  use constant UNSUPPORTED_ENCODE_FLAG => {
      ESCAPE_SLASH      => 0x00000010,
      ALLOW_BIGNUM      => 0x00000020,
      AS_NONBLESSED     => 0x00000040,
      EXPANDED          => 0x10000000, # for developer's
  };
  
  use constant UNSUPPORTED_DECODE_FLAG => {
      LOOSE             => 0x00000001,
      ALLOW_BIGNUM      => 0x00000002,
      ALLOW_BAREKEY     => 0x00000004,
      ALLOW_SINGLEQUOTE => 0x00000008,
      EXPANDED          => 0x20000000, # for developer's
  };
  
  
  sub init {
      local $^W;
      no strict qw(refs);
      *{"JSON::decode_json"} = \&{"JSON::XS::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::XS::encode_json"};
      *{"JSON::XS::is_xs"}  = sub { 1 };
      *{"JSON::XS::is_pp"}  = sub { 0 };
      return 1;
  }
  
  
  sub support_by_pp {
      my ($class, @methods) = @_;
  
      local $^W;
      no strict qw(refs);
  
      my $JSON_XS_encode_orignal     = \&JSON::XS::encode;
      my $JSON_XS_decode_orignal     = \&JSON::XS::decode;
      my $JSON_XS_incr_parse_orignal = \&JSON::XS::incr_parse;
  
      *JSON::XS::decode     = \&JSON::Backend::XS::Supportable::_decode;
      *JSON::XS::encode     = \&JSON::Backend::XS::Supportable::_encode;
      *JSON::XS::incr_parse = \&JSON::Backend::XS::Supportable::_incr_parse;
  
      *{JSON::XS::_original_decode}     = $JSON_XS_decode_orignal;
      *{JSON::XS::_original_encode}     = $JSON_XS_encode_orignal;
      *{JSON::XS::_original_incr_parse} = $JSON_XS_incr_parse_orignal;
  
      push @JSON::Backend::XS::Supportable::ISA, 'JSON';
  
      my $pkg = 'JSON::Backend::XS::Supportable';
  
      *{JSON::new} = sub {
          my $proto = JSON::XS->new; $$proto = 0;
          bless  $proto, $pkg;
      };
  
  
      for my $method (@methods) {
          my $flag = uc($method);
          my $type |= (UNSUPPORTED_ENCODE_FLAG->{$flag} || 0);
             $type |= (UNSUPPORTED_DECODE_FLAG->{$flag} || 0);
  
          next unless($type);
  
          $pkg->_make_unsupported_method($method => $type);
      }
  
  #    push @{"JSON::XS::Boolean::ISA"}, qw(JSON::PP::Boolean);
  #    push @{"JSON::PP::Boolean::ISA"}, qw(JSON::Boolean);
  
      $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
  
      return 1;
  }
  
  
  
  
  #
  # Helper classes for XS
  #
  
  package JSON::Backend::XS::Supportable;
  
  $Carp::Internal{'JSON::Backend::XS::Supportable'} = 1;
  
  sub _make_unsupported_method {
      my ($pkg, $method, $type) = @_;
  
      local $^W;
      no strict qw(refs);
  
      *{"$pkg\::$method"} = sub {
          local $^W;
          if (defined $_[1] ? $_[1] : 1) {
              ${$_[0]} |= $type;
          }
          else {
              ${$_[0]} &= ~$type;
          }
          $_[0];
      };
  
      *{"$pkg\::get_$method"} = sub {
          ${$_[0]} & $type ? 1 : '';
      };
  
  }
  
  
  sub _set_for_pp {
      JSON::_load_pp( $_INSTALL_ONLY );
  
      my $type  = shift;
      my $pp    = JSON::PP->new;
      my $prop = $_[0]->property;
  
      for my $name (keys %$prop) {
          $pp->$name( $prop->{$name} ? $prop->{$name} : 0 );
      }
  
      my $unsupported = $type eq 'encode' ? JSON::Backend::XS::UNSUPPORTED_ENCODE_FLAG
                                          : JSON::Backend::XS::UNSUPPORTED_DECODE_FLAG;
      my $flags       = ${$_[0]} || 0;
  
      for my $name (keys %$unsupported) {
          next if ($name eq 'EXPANDED'); # for developer's
          my $enable = ($flags & $unsupported->{$name}) ? 1 : 0;
          my $method = lc $name;
          $pp->$method($enable);
      }
  
      $pp->indent_length( $_[0]->get_indent_length );
  
      return $pp;
  }
  
  sub _encode { # using with PP encode
      if (${$_[0]}) {
          _set_for_pp('encode' => @_)->encode($_[1]);
      }
      else {
          $_[0]->_original_encode( $_[1] );
      }
  }
  
  
  sub _decode { # if unsupported-flag is set, use PP
      if (${$_[0]}) {
          _set_for_pp('decode' => @_)->decode($_[1]);
      }
      else {
          $_[0]->_original_decode( $_[1] );
      }
  }
  
  
  sub decode_prefix { # if unsupported-flag is set, use PP
      _set_for_pp('decode' => @_)->decode_prefix($_[1]);
  }
  
  
  sub _incr_parse {
      if (${$_[0]}) {
          _set_for_pp('decode' => @_)->incr_parse($_[1]);
      }
      else {
          $_[0]->_original_incr_parse( $_[1] );
      }
  }
  
  
  sub get_indent_length {
      ${$_[0]} << 4 >> 16;
  }
  
  
  sub indent_length {
      my $length = $_[1];
  
      if (!defined $length or $length > 15 or $length < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          local $^W;
          $length <<= 12;
          ${$_[0]} &= ~ JSON::Backend::XS::INDENT_LENGTH_FLAG;
          ${$_[0]} |= $length;
          *JSON::XS::encode = \&JSON::Backend::XS::Supportable::_encode;
      }
  
      $_[0];
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  JSON - JSON (JavaScript Object Notation) encoder/decoder
  
  =head1 SYNOPSIS
  
   use JSON; # imports encode_json, decode_json, to_json and from_json.
   
   # simple and fast interfaces (expect/generate UTF-8)
   
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
   
   # OO-interface
   
   $json = JSON->new->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # If you want to use PP only support features, call with '-support_by_pp'
   # When XS unsupported feature is enable, using PP (de|en)code instead of XS ones.
   
   use JSON -support_by_pp;
   
   # option-acceptable interfaces (expect/generate UNICODE by default)
   
   $json_text   = to_json( $perl_scalar, { ascii => 1, pretty => 1 } );
   $perl_scalar = from_json( $json_text, { utf8  => 1 } );
   
   # Between (en|de)code_json and (to|from)_json, if you want to write
   # a code which communicates to an outer world (encoded in UTF-8),
   # recommend to use (en|de)code_json.
   
  =head1 VERSION
  
      2.90
  
  This version is compatible with JSON::XS B<2.34> and later.
  (Not yet compatble to JSON::XS B<3.0x>.)
  
  
  =head1 NOTE
  
  JSON::PP was earlier included in the C<JSON> distribution, but
  has since Perl 5.14 been a core module. For this reason,
  L<JSON::PP> was removed from the JSON distribution and can now
  be found also in the Perl5 repository at
  
  =over
  
  =item * L<http://perl5.git.perl.org/perl.git>
  
  =back
  
  (The newest JSON::PP version still exists in CPAN.)
  
  Instead, the C<JSON> distribution will include JSON::backportPP
  for backwards computability. JSON.pm should thus work as it did
  before.
  
  =head1 DESCRIPTION
  
   *************************** CAUTION **************************************
   *                                                                        *
   * INCOMPATIBLE CHANGE (JSON::XS version 2.90)                            *
   *                                                                        *
   * JSON.pm had patched JSON::XS::Boolean and JSON::PP::Boolean internally *
   * on loading time for making these modules inherit JSON::Boolean.        *
   * But since JSON::XS v3.0 it use Types::Serialiser as boolean class.     *
   * Then now JSON.pm breaks boolean classe overload features and           *
   * -support_by_pp if JSON::XS v3.0 or later is installed.                 *
   *                                                                        *
   * JSON::true and JSON::false returned JSON::Boolean objects.             *
   * For workaround, they return JSON::PP::Boolean objects in this version. *
   *                                                                        *
   *     isa_ok(JSON::true, 'JSON::PP::Boolean');                           *
   *                                                                        *
   * And it discards a feature:                                             *
   *                                                                        *
   *     ok(JSON::true eq 'true');                                          *
   *                                                                        *
   * In other word, JSON::PP::Boolean overload numeric only.                *
   *                                                                        *
   *     ok( JSON::true == 1 );                                             *
   *                                                                        *
   **************************************************************************
  
   ************************** CAUTION ********************************
   * This is 'JSON module version 2' and there are many differences  *
   * to version 1.xx                                                 *
   * Please check your applications using old version.              *
   *   See to 'INCOMPATIBLE CHANGES TO OLD VERSION'                  *
   *******************************************************************
  
  JSON (JavaScript Object Notation) is a simple data format.
  See to L<http://www.json.org/> and C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>).
  
  This module converts Perl data structures to JSON and vice versa using either
  L<JSON::XS> or L<JSON::PP>.
  
  JSON::XS is the fastest and most proper JSON module on CPAN which must be
  compiled and installed in your environment.
  JSON::PP is a pure-Perl module which is bundled in this distribution and
  has a strong compatibility to JSON::XS.
  
  This module try to use JSON::XS by default and fail to it, use JSON::PP instead.
  So its features completely depend on JSON::XS or JSON::PP.
  
  See to L<BACKEND MODULE DECISION>.
  
  To distinguish the module name 'JSON' and the format type JSON,
  the former is quoted by CE<lt>E<gt> (its results vary with your using media),
  and the latter is left just as it is.
  
  Module name : C<JSON>
  
  Format type : JSON
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module (i.e. backend modules) knows how to handle Unicode, documents
  how and when it does so, and even documents what "correct" means.
  
  Even though there are limitations, this feature is available since Perl version 5.6.
  
  JSON::XS requires Perl 5.8.2 (but works correctly in 5.8.8 or later), so in older versions
  C<JSON> should call JSON::PP as the backend which can be used since Perl 5.005.
  
  With Perl 5.8.x JSON::PP works, but from 5.8.0 to 5.8.2, because of a Perl side problem,
  JSON::PP works slower in the versions. And in 5.005, the Unicode handling is not available.
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> for more information.
  
  See also to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>
  and L<JSON::XS/ENCODING/CODESET_FLAG_NOTES>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  L</MAPPING> section below to learn about those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security
  feature).
  
  See to L<JSON::XS/FEATURES> and L<JSON::PP/FEATURES>.
  
  =item * fast
  
  This module returns a JSON::XS object itself if available.
  Compared to other JSON modules and other serialisers such as Storable,
  JSON::XS usually compares favorably in terms of speed, too.
  
  If not available, C<JSON> returns a JSON::PP object instead of JSON::XS and
  it is very slow as pure-Perl.
  
  =item * simple to use
  
  This module has both a simple functional interface as well as an
  object oriented interface interface.
  
  =item * reasonably versatile output formats
  
  You can choose between the most compact guaranteed-single-line format possible
  (nice for simple line-based protocols), a pure-ASCII format (for when your transport
  is not 8-bit clean, still supports the whole Unicode range), or a pretty-printed
  format (for when you want to read that stuff). Or you can combine those features
  in whatever way you like.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  C<to_json> and C<from_json> are additional functions.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->new->utf8->decode($json_text)
  
  
  =head2 to_json
  
     $json_text = to_json($perl_scalar)
  
  Converts the given Perl data structure to a json string.
  
  This function call is functionally identical to:
  
     $json_text = JSON->new->encode($perl_scalar)
  
  Takes a hash reference as the second.
  
     $json_text = to_json($perl_scalar, $flag_hashref)
  
  So,
  
     $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
  
  equivalent to:
  
     $json_text = JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
  
  If you want to write a modern perl code which communicates to outer world,
  you should use C<encode_json> (supposed that JSON data are encoded in UTF-8).
  
  =head2 from_json
  
     $perl_scalar = from_json($json_text)
  
  The opposite of C<to_json>: expects a json string and tries
  to parse it, returning the resulting reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->decode($json_text)
  
  Takes a hash reference as the second.
  
      $perl_scalar = from_json($json_text, $flag_hashref)
  
  So,
  
      $perl_scalar = from_json($json_text, {utf8 => 1})
  
  equivalent to:
  
      $perl_scalar = JSON->new->utf8(1)->decode($json_text)
  
  If you want to write a modern perl code which communicates to outer world,
  you should use C<decode_json> (supposed that JSON data are encoded in UTF-8).
  
  =head2 JSON::is_bool
  
      $is_boolean = JSON::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::true or
  JSON::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::Boolean object.
  
  =head2 JSON::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::Boolean object.
  
  =head2 JSON::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl version is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable or C<from_json>.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
    # or
    $perl_scalar = from_json( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable or C<to_json>.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # or 
    $unicode_json_text = to_json( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 COMMON OBJECT-ORIENTED INTERFACE
  
  =head2 new
  
      $json = JSON->new
  
  Returns a new C<JSON> object inherited from either JSON::XS or JSON::PP
  that can be used to de/encode JSON strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
  This feature depends on the used Perl version and environment.
  
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.
  
    JSON->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::XS->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::XS->new->decode (decode "UTF-32LE", $jsontext);
  
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  The indent space length is three and JSON::XS cannot change the indent
  space length.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, identifying them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  The indent space length is three.
  With JSON::PP, you can also access C<indent_length> to change indent space length.
  
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =over
  
  =item convert_blessed_universally mode
  
  If use C<JSON> with C<-convert_blessed_universally>, the C<UNIVERSAL::TO_JSON>
  subroutine is defined as the below code:
  
     *UNIVERSAL::TO_JSON = sub {
         my $b_obj = B::svref_2object( $_[0] );
         return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                 : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                 : undef
                 ;
     }
  
  This will cause that C<encode> method converts simple blessed objects into
  JSON objects as non-blessed object.
  
     JSON -convert_blessed_universally;
     $json->allow_blessed->convert_blessed->encode( $blessed_object )
  
  This feature is experimental and may be removed in the future.
  
  =back
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  With JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible. This can save
  memory when your JSON texts are either very very long or you have many
  short strings. It will also try to downgrade any strings to octet-form
  if possible: perl stores strings internally either in an encoding called
  UTF-X or in octet-form. The latter cannot store everything but uses less
  space in general (and some buggy Perl or C code might even rely on that
  internal representation being used).
  
  With JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>. See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE> and L<JSON::PP/METHODS>.
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  Note that nesting is implemented by recursion in C. The default value has
  been chosen to be as large as typical operating systems allow without
  crashing. (JSON::XS)
  
  With JSON::PP as the backend, when a large value (100 or more) was set and
  it de/encodes a deep nested object/text, it may raise a warning
  'Deep recursion on subroutine' at the perl runtime phase.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS>, below, for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 property
  
      $boolean = $json->property($property_name)
  
  Returns a boolean value about above some properties.
  
  The available properties are C<ascii>, C<latin1>, C<utf8>,
  C<indent>,C<space_before>, C<space_after>, C<relaxed>, C<canonical>,
  C<allow_nonref>, C<allow_unknown>, C<allow_blessed>, C<convert_blessed>,
  C<shrink>, C<max_depth> and C<max_size>.
  
     $boolean = $json->property('utf8');
      => 0
     $json->utf8;
     $boolean = $json->property('utf8');
      => 1
  
  Sets the property with a given boolean value.
  
      $json = $json->property($property_name => $boolean);
  
  With no argument, it returns all the above properties as a hash reference.
  
      $flag_hashref = $json->property();
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  The backend module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthesis
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP SUPPORT METHODS
  
  The below methods are JSON::PP own methods, so when C<JSON> works
  with JSON::PP (i.e. the created object is a JSON::PP object), available.
  See to L<JSON::PP/JSON::PP OWN METHODS> in detail.
  
  If you use C<JSON> with additional C<-support_by_pp>, some methods
  are available even with JSON::XS. See to L<USE PP FEATURES EVEN THOUGH XS BACKEND>.
  
     BEING { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
     
     use JSON -support_by_pp;
     
     my $json = JSON->new;
     $json->allow_nonref->escape_slash->encode("/");
  
     # functional interfaces too.
     print to_json(["/"], {escape_slash => 1});
     print from_json('["foo"]', {utf8 => 1});
  
  If you do not want to all functions but C<-support_by_pp>,
  use C<-no_export>.
  
     use JSON -support_by_pp, -no_export;
     # functional interfaces are not exported.
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  any JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contrary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<MAPPING> about the conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See to L<JSON::PP/JSON::PP OWN METHODS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But by default
  JSON backend modules encode strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  With JSON::XS, The indent space length is 3 and cannot be changed.
  With JSON::PP, it sets the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  with 'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  See to L<JSON::PP/JSON::PP OWN METHODS>.
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the least significant bit.
  
  If the backend is JSON::PP and C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::true> and C<JSON::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::null> returns C<undef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same data structure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  In future, the ordered object feature will be added to JSON::PP using C<tie> mechanism.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::true]      # yields [false,true]
  
  =item JSON::true, JSON::false, JSON::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  With C<convert_blessed_universally> mode,  C<encode> converts blessed
  hash references or blessed array references (contains other blessed references)
  into JSON members and arrays.
  
     use JSON -convert_blessed_universally;
     JSON->new->allow_blessed->convert_blessed->encode( $blessed_object );
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  If the backend is JSON::PP and C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 JSON and ECMAscript
  
  See to L<JSON::XS/JSON and ECMAscript>.
  
  =head1 JSON and YAML
  
  JSON is not a subset of YAML.
  See to L<JSON::XS/JSON and YAML>.
  
  
  =head1 BACKEND MODULE DECISION
  
  When you use C<JSON>, C<JSON> tries to C<use> JSON::XS. If this call failed, it will
  C<uses> JSON::PP. The required JSON::XS version is I<2.2> or later.
  
  The C<JSON> constructor method returns an object inherited from the backend module,
  and JSON::XS object is a blessed scalar reference while JSON::PP is a blessed hash
  reference.
  
  So, your program should not depend on the backend module, especially
  returned objects should not be modified.
  
   my $json = JSON->new; # XS or PP?
   $json->{stash} = 'this is xs object'; # this code may raise an error!
  
  To check the backend module, there are some methods - C<backend>, C<is_pp> and C<is_xs>.
  
    JSON->backend; # 'JSON::XS' or 'JSON::PP'
    
    JSON->backend->is_pp: # 0 or 1
    
    JSON->backend->is_xs: # 1 or 0
    
    $json->is_xs; # 1 or 0
    
    $json->is_pp; # 0 or 1
  
  
  If you set an environment variable C<PERL_JSON_BACKEND>, the calling action will be changed.
  
  =over
  
  =item PERL_JSON_BACKEND = 0 or PERL_JSON_BACKEND = 'JSON::PP'
  
  Always use JSON::PP
  
  =item PERL_JSON_BACKEND == 1 or PERL_JSON_BACKEND = 'JSON::XS,JSON::PP'
  
  (The default) Use compiled JSON::XS if it is properly compiled & installed,
  otherwise use JSON::PP.
  
  =item PERL_JSON_BACKEND == 2 or PERL_JSON_BACKEND = 'JSON::XS'
  
  Always use compiled JSON::XS, die if it isn't properly compiled & installed.
  
  =item PERL_JSON_BACKEND = 'JSON::backportPP'
  
  Always use JSON::backportPP.
  JSON::backportPP is JSON::PP back port module.
  C<JSON> includes JSON::backportPP instead of JSON::PP.
  
  =back
  
  These ideas come from L<DBI::PurePerl> mechanism.
  
  example:
  
   BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::PP' }
   use JSON; # always uses JSON::PP
  
  In future, it may be able to specify another module.
  
  =head1 USE PP FEATURES EVEN THOUGH XS BACKEND
  
  Many methods are available with either JSON::XS or JSON::PP and
  when the backend module is JSON::XS, if any JSON::PP specific (i.e. JSON::XS unsupported)
  method is called, it will C<warn> and be noop.
  
  But If you C<use> C<JSON> passing the optional string C<-support_by_pp>,
  it makes a part of those unsupported methods available.
  This feature is achieved by using JSON::PP in C<de/encode>.
  
     BEGIN { $ENV{PERL_JSON_BACKEND} = 2 } # with JSON::XS
     use JSON -support_by_pp;
     my $json = JSON->new;
     $json->allow_nonref->escape_slash->encode("/");
  
  At this time, the returned object is a C<JSON::Backend::XS::Supportable>
  object (re-blessed XS object), and  by checking JSON::XS unsupported flags
  in de/encoding, can support some unsupported methods - C<loose>, C<allow_bignum>,
  C<allow_barekey>, C<allow_singlequote>, C<escape_slash> and C<indent_length>.
  
  When any unsupported methods are not enable, C<XS de/encode> will be
  used as is. The switch is achieved by changing the symbolic tables.
  
  C<-support_by_pp> is effective only when the backend module is JSON::XS
  and it makes the de/encoding speed down a bit.
  
  See to L<JSON::PP SUPPORT METHODS>.
  
  =head1 INCOMPATIBLE CHANGES TO OLD VERSION
  
  There are big incompatibility between new version (2.00) and old (1.xx).
  If you use old C<JSON> 1.xx in your code, please check it.
  
  See to L<Transition ways from 1.xx to 2.xx.>
  
  =over
  
  =item jsonToObj and objToJson are obsoleted.
  
  Non Perl-style name C<jsonToObj> and C<objToJson> are obsoleted
  (but not yet deleted from the source).
  If you use these functions in your code, please replace them
  with C<from_json> and C<to_json>.
  
  
  =item Global variables are no longer available.
  
  C<JSON> class variables - C<$JSON::AUTOCONVERT>, C<$JSON::BareKey>, etc...
  - are not available any longer.
  Instead, various features can be used through object methods.
  
  
  =item Package JSON::Converter and JSON::Parser are deleted.
  
  Now C<JSON> bundles with JSON::PP which can handle JSON more properly than them.
  
  =item Package JSON::NotString is deleted.
  
  There was C<JSON::NotString> class which represents JSON value C<true>, C<false>, C<null>
  and numbers. It was deleted and replaced by C<JSON::Boolean>.
  
  C<JSON::Boolean> represents C<true> and C<false>.
  
  C<JSON::Boolean> does not represent C<null>.
  
  C<JSON::null> returns C<undef>.
  
  C<JSON> makes L<JSON::XS::Boolean> and L<JSON::PP::Boolean> is-a relation
  to L<JSON::Boolean>.
  
  =item function JSON::Number is obsoleted.
  
  C<JSON::Number> is now needless because JSON::XS and JSON::PP have
  round-trip integrity.
  
  =item JSONRPC modules are deleted.
  
  Perl implementation of JSON-RPC protocol - C<JSONRPC >, C<JSONRPC::Transport::HTTP>
  and C<Apache::JSONRPC > are deleted in this distribution.
  Instead of them, there is L<JSON::RPC> which supports JSON-RPC protocol version 1.1.
  
  =back
  
  =head2 Transition ways from 1.xx to 2.xx.
  
  You should set C<suport_by_pp> mode firstly, because
  it is always successful for the below codes even with JSON::XS.
  
      use JSON -support_by_pp;
  
  =over
  
  =item Exported jsonToObj (simple)
  
    from_json($json_text);
  
  =item Exported objToJson (simple)
  
    to_json($perl_scalar);
  
  =item Exported jsonToObj (advanced)
  
    $flags = {allow_barekey => 1, allow_singlequote => 1};
    from_json($json_text, $flags);
  
  equivalent to:
  
    $JSON::BareKey = 1;
    $JSON::QuotApos = 1;
    jsonToObj($json_text);
  
  =item Exported objToJson (advanced)
  
    $flags = {allow_blessed => 1, allow_barekey => 1};
    to_json($perl_scalar, $flags);
  
  equivalent to:
  
    $JSON::BareKey = 1;
    objToJson($perl_scalar);
  
  =item jsonToObj as object method
  
    $json->decode($json_text);
  
  =item objToJson as object method
  
    $json->encode($perl_scalar);
  
  =item new method with parameters
  
  The C<new> method in 2.x takes any parameters no longer.
  You can set parameters instead;
  
     $json = JSON->new->pretty;
  
  =item $JSON::Pretty, $JSON::Indent, $JSON::Delimiter
  
  If C<indent> is enable, that means C<$JSON::Pretty> flag set. And
  C<$JSON::Delimiter> was substituted by C<space_before> and C<space_after>.
  In conclusion:
  
     $json->indent->space_before->space_after;
  
  Equivalent to:
  
    $json->pretty;
  
  To change indent length, use C<indent_length>.
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->pretty->indent_length(2)->encode($perl_scalar);
  
  =item $JSON::BareKey
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->allow_barekey->decode($json_text)
  
  =item $JSON::ConvBlessed
  
  use C<-convert_blessed_universally>. See to L<convert_blessed>.
  
  =item $JSON::QuotApos
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->allow_singlequote->decode($json_text)
  
  =item $JSON::SingleQuote
  
  Disable. C<JSON> does not make such a invalid JSON string any longer.
  
  =item $JSON::KeySort
  
    $json->canonical->encode($perl_scalar)
  
  This is the ascii sort.
  
  If you want to use with your own sort routine, check the C<sort_by> method.
  
  (Only with JSON::PP, even if C<-support_by_pp> is used currently.)
  
    $json->sort_by($sort_routine_ref)->encode($perl_scalar)
   
    $json->sort_by(sub { $JSON::PP::a <=> $JSON::PP::b })->encode($perl_scalar)
  
  Can't access C<$a> and C<$b> but C<$JSON::PP::a> and C<$JSON::PP::b>.
  
  =item $JSON::SkipInvalid
  
    $json->allow_unknown
  
  =item $JSON::AUTOCONVERT
  
  Needless. C<JSON> backend modules have the round-trip integrity.
  
  =item $JSON::UTF8
  
  Needless because C<JSON> (JSON::XS/JSON::PP) sets
  the UTF8 flag on properly.
  
      # With UTF8-flagged strings
  
      $json->allow_nonref;
      $str = chr(1000); # UTF8-flagged
  
      $json_text  = $json->utf8(0)->encode($str);
      utf8::is_utf8($json_text);
      # true
      $json_text  = $json->utf8(1)->encode($str);
      utf8::is_utf8($json_text);
      # false
  
      $str = '"' . chr(1000) . '"'; # UTF8-flagged
  
      $perl_scalar  = $json->utf8(0)->decode($str);
      utf8::is_utf8($perl_scalar);
      # true
      $perl_scalar  = $json->utf8(1)->decode($str);
      # died because of 'Wide character in subroutine'
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =item $JSON::UnMapping
  
  Disable. See to L<MAPPING>.
  
  =item $JSON::SelfConvert
  
  This option was deleted.
  Instead of it, if a given blessed object has the C<TO_JSON> method,
  C<TO_JSON> will be executed with C<convert_blessed>.
  
    $json->convert_blessed->encode($blessed_hashref_or_arrayref)
    # if need, call allow_blessed
  
  Note that it was C<toJson> in old version, but now not C<toJson> but C<TO_JSON>.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item example programs
  
  =back
  
  =head1 THREADS
  
  No test with JSON::PP. If with JSON::XS, See to L<JSON::XS/THREADS>.
  
  
  =head1 BUGS
  
  Please report bugs relevant to C<JSON> to E<lt>makamaka[at]cpan.orgE<gt>.
  
  
  =head1 SEE ALSO
  
  Most of the document is copied and modified from JSON::XS doc.
  
  L<JSON::XS>, L<JSON::PP>
  
  C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  JSON::XS was written by  Marc Lehmann <schmorp[at]schmorp.de>
  
  The release of this new version owes to the courtesy of Marc Lehmann.
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005-2013 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON

$fatpacked{"JSON/backportPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP';
  package # This is JSON::backportPP
      JSON::PP;
  
  # JSON-2.0
  
  use 5.005;
  use strict;
  use base qw(Exporter);
  use overload ();
  
  use Carp ();
  use B ();
  #use Devel::Peek;
  
  use vars qw($VERSION);
  $VERSION = '2.27204';
  
  @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
  
  # instead of hash-access, i tried index-access for speed.
  # but this method is not faster than what i expected. so it will be changed.
  
  use constant P_ASCII                => 0;
  use constant P_LATIN1               => 1;
  use constant P_UTF8                 => 2;
  use constant P_INDENT               => 3;
  use constant P_CANONICAL            => 4;
  use constant P_SPACE_BEFORE         => 5;
  use constant P_SPACE_AFTER          => 6;
  use constant P_ALLOW_NONREF         => 7;
  use constant P_SHRINK               => 8;
  use constant P_ALLOW_BLESSED        => 9;
  use constant P_CONVERT_BLESSED      => 10;
  use constant P_RELAXED              => 11;
  
  use constant P_LOOSE                => 12;
  use constant P_ALLOW_BIGNUM         => 13;
  use constant P_ALLOW_BAREKEY        => 14;
  use constant P_ALLOW_SINGLEQUOTE    => 15;
  use constant P_ESCAPE_SLASH         => 16;
  use constant P_AS_NONBLESSED        => 17;
  
  use constant P_ALLOW_UNKNOWN        => 18;
  
  use constant OLD_PERL => $] < 5.008 ? 1 : 0;
  
  BEGIN {
      my @xs_compati_bit_properties = qw(
              latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
              allow_blessed convert_blessed relaxed allow_unknown
      );
      my @pp_bit_properties = qw(
              allow_singlequote allow_bignum loose
              allow_barekey escape_slash as_nonblessed
      );
  
      # Perl version check, Unicode handling is enable?
      # Helper module sets @JSON::PP::_properties.
      if ($] < 5.008 ) {
          my $helper = $] >= 5.006 ? 'JSON::backportPP::Compat5006' : 'JSON::backportPP::Compat5005';
          eval qq| require $helper |;
          if ($@) { Carp::croak $@; }
      }
  
      for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
          my $flag_name = 'P_' . uc($name);
  
          eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$flag_name] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$flag_name] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
              }
          /;
      }
  
  }
  
  
  
  # Functions
  
  my %encode_allow_method
       = map {($_ => 1)} qw/utf8 pretty allow_nonref latin1 self_encode escape_slash
                            allow_blessed convert_blessed indent indent_length allow_bignum
                            as_nonblessed
                          /;
  my %decode_allow_method
       = map {($_ => 1)} qw/utf8 allow_nonref loose allow_singlequote allow_bignum
                            allow_barekey max_size relaxed/;
  
  
  my $JSON; # cache
  
  sub encode_json ($) { # encode
      ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
  }
  
  
  sub decode_json { # decode
      ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
  }
  
  # Obsoleted
  
  sub to_json($) {
     Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
  }
  
  
  sub from_json($) {
     Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
  }
  
  
  # Methods
  
  sub new {
      my $class = shift;
      my $self  = {
          max_depth   => 512,
          max_size    => 0,
          indent      => 0,
          FLAGS       => 0,
          fallback      => sub { encode_error('Invalid value. JSON can only reference.') },
          indent_length => 3,
      };
  
      bless $self, $class;
  }
  
  
  sub encode {
      return $_[0]->PP_encode_json($_[1]);
  }
  
  
  sub decode {
      return $_[0]->PP_decode_json($_[1], 0x00000000);
  }
  
  
  sub decode_prefix {
      return $_[0]->PP_decode_json($_[1], 0x00000001);
  }
  
  
  # accessor
  
  
  # pretty printing
  
  sub pretty {
      my ($self, $v) = @_;
      my $enable = defined $v ? $v : 1;
  
      if ($enable) { # indent_length(3) for JSON::XS compatibility
          $self->indent(1)->indent_length(3)->space_before(1)->space_after(1);
      }
      else {
          $self->indent(0)->space_before(0)->space_after(0);
      }
  
      $self;
  }
  
  # etc
  
  sub max_depth {
      my $max  = defined $_[1] ? $_[1] : 0x80000000;
      $_[0]->{max_depth} = $max;
      $_[0];
  }
  
  
  sub get_max_depth { $_[0]->{max_depth}; }
  
  
  sub max_size {
      my $max  = defined $_[1] ? $_[1] : 0;
      $_[0]->{max_size} = $max;
      $_[0];
  }
  
  
  sub get_max_size { $_[0]->{max_size}; }
  
  
  sub filter_json_object {
      $_[0]->{cb_object} = defined $_[1] ? $_[1] : 0;
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub filter_json_single_key_object {
      if (@_ > 1) {
          $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub indent_length {
      if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          $_[0]->{indent_length} = $_[1];
      }
      $_[0];
  }
  
  sub get_indent_length {
      $_[0]->{indent_length};
  }
  
  sub sort_by {
      $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
      $_[0];
  }
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.");
  }
  
  ###############################
  
  ###
  ### Perl => JSON
  ###
  
  
  { # Convert
  
      my $max_depth;
      my $indent;
      my $ascii;
      my $latin1;
      my $utf8;
      my $space_before;
      my $space_after;
      my $canonical;
      my $allow_blessed;
      my $convert_blessed;
  
      my $indent_length;
      my $escape_slash;
      my $bignum;
      my $as_nonblessed;
  
      my $depth;
      my $indent_count;
      my $keysort;
  
  
      sub PP_encode_json {
          my $self = shift;
          my $obj  = shift;
  
          $indent_count = 0;
          $depth        = 0;
  
          my $idx = $self->{PROPS};
  
          ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
              $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
           = @{$idx}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                      P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
  
          ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
  
          $keysort = $canonical ? sub { $a cmp $b } : undef;
  
          if ($self->{sort_by}) {
              $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                       : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                       : sub { $a cmp $b };
          }
  
          encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
               if(!ref $obj and !$idx->[ P_ALLOW_NONREF ]);
  
          my $str  = $self->object_to_json($obj);
  
          $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
  
          unless ($ascii or $latin1 or $utf8) {
              utf8::upgrade($str);
          }
  
          if ($idx->[ P_SHRINK ]) {
              utf8::downgrade($str, 1);
          }
  
          return $str;
      }
  
  
      sub object_to_json {
          my ($self, $obj) = @_;
          my $type = ref($obj);
  
          if($type eq 'HASH'){
              return $self->hash_to_json($obj);
          }
          elsif($type eq 'ARRAY'){
              return $self->array_to_json($obj);
          }
          elsif ($type) { # blessed object?
              if (blessed($obj)) {
  
                  return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
  
                  if ( $convert_blessed and $obj->can('TO_JSON') ) {
                      my $result = $obj->TO_JSON();
                      if ( defined $result and ref( $result ) ) {
                          if ( refaddr( $obj ) eq refaddr( $result ) ) {
                              encode_error( sprintf(
                                  "%s::TO_JSON method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
  
                      return $self->object_to_json( $result );
                  }
  
                  return "$obj" if ( $bignum and _is_bignum($obj) );
                  return $self->blessed_to_json($obj) if ($allow_blessed and $as_nonblessed); # will be removed.
  
                  encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                      . "nor convert_blessed settings are enabled", $obj)
                  ) unless ($allow_blessed);
  
                  return 'null';
              }
              else {
                  return $self->value_to_json($obj);
              }
          }
          else{
              return $self->value_to_json($obj);
          }
      }
  
  
      sub hash_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
          my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
  
          for my $k ( _sort( $obj ) ) {
              if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
              push @res, string_to_json( $self, $k )
                            .  $del
                            . ( $self->object_to_json( $obj->{$k} ) || $self->value_to_json( $obj->{$k} ) );
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return   '{' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' )  . '}';
      }
  
  
      sub array_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
  
          for my $v (@$obj){
              push @res, $self->object_to_json($v) || $self->value_to_json($v);
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '[' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' ) . ']';
      }
  
  
      sub value_to_json {
          my ($self, $value) = @_;
  
          return 'null' if(!defined $value);
  
          my $b_obj = B::svref_2object(\$value);  # for round trip problem
          my $flags = $b_obj->FLAGS;
  
          return $value # as is 
              if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?
  
          my $type = ref($value);
  
          if(!$type){
              return string_to_json($self, $value);
          }
          elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
              return $$value == 1 ? 'true' : 'false';
          }
          elsif ($type) {
              if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                  return $self->value_to_json("$value");
              }
  
              if ($type eq 'SCALAR' and defined $$value) {
                  return   $$value eq '1' ? 'true'
                         : $$value eq '0' ? 'false'
                         : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                         : encode_error("cannot encode reference to scalar");
              }
  
               if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                   return 'null';
               }
               else {
                   if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                      encode_error("cannot encode reference to scalar");
                   }
                   else {
                      encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                   }
               }
  
          }
          else {
              return $self->{fallback}->($value)
                   if ($self->{fallback} and ref($self->{fallback}) eq 'CODE');
              return 'null';
          }
  
      }
  
  
      my %esc = (
          "\n" => '\n',
          "\r" => '\r',
          "\t" => '\t',
          "\f" => '\f',
          "\b" => '\b',
          "\"" => '\"',
          "\\" => '\\\\',
          "\'" => '\\\'',
      );
  
  
      sub string_to_json {
          my ($self, $arg) = @_;
  
          $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
          $arg =~ s/\//\\\//g if ($escape_slash);
          $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
          if ($ascii) {
              $arg = JSON_PP_encode_ascii($arg);
          }
  
          if ($latin1) {
              $arg = JSON_PP_encode_latin1($arg);
          }
  
          if ($utf8) {
              utf8::encode($arg);
          }
  
          return '"' . $arg . '"';
      }
  
  
      sub blessed_to_json {
          my $reftype = reftype($_[1]) || '';
          if ($reftype eq 'HASH') {
              return $_[0]->hash_to_json($_[1]);
          }
          elsif ($reftype eq 'ARRAY') {
              return $_[0]->array_to_json($_[1]);
          }
          else {
              return 'null';
          }
      }
  
  
      sub encode_error {
          my $error  = shift;
          Carp::croak "$error";
      }
  
  
      sub _sort {
          defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
      }
  
  
      sub _up_indent {
          my $self  = shift;
          my $space = ' ' x $indent_length;
  
          my ($pre,$post) = ('','');
  
          $post = "\n" . $space x $indent_count;
  
          $indent_count++;
  
          $pre = "\n" . $space x $indent_count;
  
          return ($pre,$post);
      }
  
  
      sub _down_indent { $indent_count--; }
  
  
      sub PP_encode_box {
          {
              depth        => $depth,
              indent_count => $indent_count,
          };
      }
  
  } # Convert
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_surrogates { # from perlunicode
      my $uni = $_[0] - 0x10000;
      return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
  }
  
  
  sub _is_bignum {
      $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
  }
  
  
  
  #
  # JSON => Perl
  #
  
  my $max_intsize;
  
  BEGIN {
      my $checkint = 1111;
      for my $d (5..64) {
          $checkint .= 1;
          my $int   = eval qq| $checkint |;
          if ($int =~ /[eE]/) {
              $max_intsize = $d - 1;
              last;
          }
      }
  }
  
  { # PARSE 
  
      my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
          b    => "\x8",
          t    => "\x9",
          n    => "\xA",
          f    => "\xC",
          r    => "\xD",
          '\\' => '\\',
          '"'  => '"',
          '/'  => '/',
      );
  
      my $text; # json data
      my $at;   # offset
      my $ch;   # 1chracter
      my $len;  # text length (changed according to UTF8 or NON UTF8)
      # INTERNAL
      my $depth;          # nest counter
      my $encoding;       # json text encoding
      my $is_valid_utf8;  # temp variable
      my $utf8_len;       # utf8 byte length
      # FLAGS
      my $utf8;           # must be utf8
      my $max_depth;      # max nest number of objects and arrays
      my $max_size;
      my $relaxed;
      my $cb_object;
      my $cb_sk_object;
  
      my $F_HOOK;
  
      my $allow_bigint;   # using Math::BigInt
      my $singlequote;    # loosely quoting
      my $loose;          # 
      my $allow_barekey;  # bareKey
  
      # $opt flag
      # 0x00000001 .... decode_prefix
      # 0x10000000 .... incr_parse
  
      sub PP_decode_json {
          my ($self, $opt); # $opt is an effective flag during this decode_json.
  
          ($self, $text, $opt) = @_;
  
          ($at, $ch, $depth) = (0, '', 0);
  
          if ( !defined $text or ref $text ) {
              decode_error("malformed JSON string, neither array, object, number, string or atom");
          }
  
          my $idx = $self->{PROPS};
  
          ($utf8, $relaxed, $loose, $allow_bigint, $allow_barekey, $singlequote)
              = @{$idx}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
  
          if ( $utf8 ) {
              utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
          }
          else {
              utf8::upgrade( $text );
          }
  
          $len = length $text;
  
          ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
               = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
  
          if ($max_size > 1) {
              use bytes;
              my $bytes = length $text;
              decode_error(
                  sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                      , $bytes, $max_size), 1
              ) if ($bytes > $max_size);
          }
  
          # Currently no effect
          # should use regexp
          my @octets = unpack('C4', $text);
          $encoding =   ( $octets[0] and  $octets[1]) ? 'UTF-8'
                      : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
                      : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
                      : ( $octets[2]                ) ? 'UTF-16LE'
                      : (!$octets[2]                ) ? 'UTF-32LE'
                      : 'unknown';
  
          white(); # remove head white space
  
          my $valid_start = defined $ch; # Is there a first character for JSON structure?
  
          my $result = value();
  
          return undef if ( !$result && ( $opt & 0x10000000 ) ); # for incr_parse
  
          decode_error("malformed JSON string, neither array, object, number, string or atom") unless $valid_start;
  
          if ( !$idx->[ P_ALLOW_NONREF ] and !ref $result ) {
                  decode_error(
                  'JSON text must be an object or array (but found number, string, true, false or null,'
                         . ' use allow_nonref to allow this)', 1);
          }
  
          Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
  
          my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
  
          white(); # remove tail white space
  
          if ( $ch ) {
              return ( $result, $consumed ) if ($opt & 0x00000001); # all right if decode_prefix
              decode_error("garbage after JSON object");
          }
  
          ( $opt & 0x00000001 ) ? ( $result, $consumed ) : $result;
      }
  
  
      sub next_chr {
          return $ch = undef if($at >= $len);
          $ch = substr($text, $at++, 1);
      }
  
  
      sub value {
          white();
          return          if(!defined $ch);
          return object() if($ch eq '{');
          return array()  if($ch eq '[');
          return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
          return number() if($ch =~ /[0-9]/ or $ch eq '-');
          return word();
      }
  
      sub string {
          my ($i, $s, $t, $u);
          my $utf16;
          my $is_utf8;
  
          ($is_valid_utf8, $utf8_len) = ('', 0);
  
          $s = ''; # basically UTF8 flag on
  
          if($ch eq '"' or ($singlequote and $ch eq "'")){
              my $boundChar = $ch;
  
              OUTER: while( defined(next_chr()) ){
  
                  if($ch eq $boundChar){
                      next_chr();
  
                      if ($utf16) {
                          decode_error("missing low surrogate character in surrogate pair");
                      }
  
                      utf8::decode($s) if($is_utf8);
  
                      return $s;
                  }
                  elsif($ch eq '\\'){
                      next_chr();
                      if(exists $escapes{$ch}){
                          $s .= $escapes{$ch};
                      }
                      elsif($ch eq 'u'){ # UNICODE handling
                          my $u = '';
  
                          for(1..4){
                              $ch = next_chr();
                              last OUTER if($ch !~ /[0-9a-fA-F]/);
                              $u .= $ch;
                          }
  
                          # U+D800 - U+DBFF
                          if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                              $utf16 = $u;
                          }
                          # U+DC00 - U+DFFF
                          elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                              unless (defined $utf16) {
                                  decode_error("missing high surrogate character in surrogate pair");
                              }
                              $is_utf8 = 1;
                              $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                              $utf16 = undef;
                          }
                          else {
                              if (defined $utf16) {
                                  decode_error("surrogate pair expected");
                              }
  
                              if ( ( my $hex = hex( $u ) ) > 127 ) {
                                  $is_utf8 = 1;
                                  $s .= JSON_PP_decode_unicode($u) || next;
                              }
                              else {
                                  $s .= chr $hex;
                              }
                          }
  
                      }
                      else{
                          unless ($loose) {
                              $at -= 2;
                              decode_error('illegal backslash escape sequence in string');
                          }
                          $s .= $ch;
                      }
                  }
                  else{
  
                      if ( ord $ch  > 127 ) {
                          if ( $utf8 ) {
                              unless( $ch = is_valid_utf8($ch) ) {
                                  $at -= 1;
                                  decode_error("malformed UTF-8 character in JSON string");
                              }
                              else {
                                  $at += $utf8_len - 1;
                              }
                          }
                          else {
                              utf8::encode( $ch );
                          }
  
                          $is_utf8 = 1;
                      }
  
                      if (!$loose) {
                          if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                              $at--;
                              decode_error('invalid character encountered while parsing JSON string');
                          }
                      }
  
                      $s .= $ch;
                  }
              }
          }
  
          decode_error("unexpected end of string while parsing JSON string");
      }
  
  
      sub white {
          while( defined $ch  ){
              if($ch le ' '){
                  next_chr();
              }
              elsif($ch eq '/'){
                  next_chr();
                  if(defined $ch and $ch eq '/'){
                      1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                  }
                  elsif(defined $ch and $ch eq '*'){
                      next_chr();
                      while(1){
                          if(defined $ch){
                              if($ch eq '*'){
                                  if(defined(next_chr()) and $ch eq '/'){
                                      next_chr();
                                      last;
                                  }
                              }
                              else{
                                  next_chr();
                              }
                          }
                          else{
                              decode_error("Unterminated comment");
                          }
                      }
                      next;
                  }
                  else{
                      $at--;
                      decode_error("malformed JSON string, neither array, object, number, string or atom");
                  }
              }
              else{
                  if ($relaxed and $ch eq '#') { # correctly?
                      pos($text) = $at;
                      $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                      $at = pos($text);
                      next_chr;
                      next;
                  }
  
                  last;
              }
          }
      }
  
  
      sub array {
          my $a  = $_[0] || []; # you can use this code to use another array ref object.
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                      if (++$depth > $max_depth);
  
          next_chr();
          white();
  
          if(defined $ch and $ch eq ']'){
              --$depth;
              next_chr();
              return $a;
          }
          else {
              while(defined($ch)){
                  push @$a, value();
  
                  white();
  
                  if (!defined $ch) {
                      last;
                  }
  
                  if($ch eq ']'){
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq ']') {
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
              }
          }
  
          decode_error(", or ] expected while parsing array");
      }
  
  
      sub object {
          my $o = $_[0] || {}; # you can use this code to use another hash ref object.
          my $k;
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                  if (++$depth > $max_depth);
          next_chr();
          white();
  
          if(defined $ch and $ch eq '}'){
              --$depth;
              next_chr();
              if ($F_HOOK) {
                  return _json_object_hook($o);
              }
              return $o;
          }
          else {
              while (defined $ch) {
                  $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                  white();
  
                  if(!defined $ch or $ch ne ':'){
                      $at--;
                      decode_error("':' expected");
                  }
  
                  next_chr();
                  $o->{$k} = value();
                  white();
  
                  last if (!defined $ch);
  
                  if($ch eq '}'){
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq '}') {
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
              }
  
          }
  
          $at--;
          decode_error(", or } expected while parsing object/hash");
      }
  
  
      sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
          my $key;
          while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
              $key .= $ch;
              next_chr();
          }
          return $key;
      }
  
  
      sub word {
          my $word =  substr($text,$at-1,4);
  
          if($word eq 'true'){
              $at += 3;
              next_chr;
              return $JSON::PP::true;
          }
          elsif($word eq 'null'){
              $at += 3;
              next_chr;
              return undef;
          }
          elsif($word eq 'fals'){
              $at += 3;
              if(substr($text,$at,1) eq 'e'){
                  $at++;
                  next_chr;
                  return $JSON::PP::false;
              }
          }
  
          $at--; # for decode_error report
  
          decode_error("'null' expected")  if ($word =~ /^n/);
          decode_error("'true' expected")  if ($word =~ /^t/);
          decode_error("'false' expected") if ($word =~ /^f/);
          decode_error("malformed JSON string, neither array, object, number, string or atom");
      }
  
  
      sub number {
          my $n    = '';
          my $v;
  
          # According to RFC4627, hex or oct digits are invalid.
          if($ch eq '0'){
              my $peek = substr($text,$at,1);
              my $hex  = $peek =~ /[xX]/; # 0 or 1
  
              if($hex){
                  decode_error("malformed number (leading zero must not be followed by another digit)");
                  ($n) = ( substr($text, $at+1) =~ /^([0-9a-fA-F]+)/);
              }
              else{ # oct
                  ($n) = ( substr($text, $at) =~ /^([0-7]+)/);
                  if (defined $n and length $n > 1) {
                      decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
              }
  
              if(defined $n and length($n)){
                  if (!$hex and length($n) == 1) {
                     decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
                  $at += length($n) + $hex;
                  next_chr;
                  return $hex ? hex($n) : oct($n);
              }
          }
  
          if($ch eq '-'){
              $n = '-';
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after initial minus)");
              }
          }
  
          while(defined $ch and $ch =~ /\d/){
              $n .= $ch;
              next_chr;
          }
  
          if(defined $ch and $ch eq '.'){
              $n .= '.';
  
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after decimal point)");
              }
              else {
                  $n .= $ch;
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
          }
  
          if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
              $n .= $ch;
              next_chr;
  
              if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                  $n .= $ch;
                  next_chr;
                  if (!defined $ch or $ch =~ /\D/) {
                      decode_error("malformed number (no digits after exp sign)");
                  }
                  $n .= $ch;
              }
              elsif(defined($ch) and $ch =~ /\d/){
                  $n .= $ch;
              }
              else {
                  decode_error("malformed number (no digits after exp sign)");
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
  
          }
  
          $v .= $n;
  
          if ($v !~ /[.eE]/ and length $v > $max_intsize) {
              if ($allow_bigint) { # from Adam Sussman
                  require Math::BigInt;
                  return Math::BigInt->new($v);
              }
              else {
                  return "$v";
              }
          }
          elsif ($allow_bigint) {
              require Math::BigFloat;
              return Math::BigFloat->new($v);
          }
  
          return 0+$v;
      }
  
  
      sub is_valid_utf8 {
  
          $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                    : $_[0] =~ /[\xC2-\xDF]/  ? 2
                    : $_[0] =~ /[\xE0-\xEF]/  ? 3
                    : $_[0] =~ /[\xF0-\xF4]/  ? 4
                    : 0
                    ;
  
          return unless $utf8_len;
  
          my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
  
          return ( $is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x )  ? $is_valid_utf8 : '';
      }
  
  
      sub decode_error {
          my $error  = shift;
          my $no_rep = shift;
          my $str    = defined $text ? substr($text, $at) : '';
          my $mess   = '';
          my $type   = $] >= 5.008           ? 'U*'
                     : $] <  5.006           ? 'C*'
                     : utf8::is_utf8( $str ) ? 'U*' # 5.6
                     : 'C*'
                     ;
  
          for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
              $mess .=  $c == 0x07 ? '\a'
                      : $c == 0x09 ? '\t'
                      : $c == 0x0a ? '\n'
                      : $c == 0x0d ? '\r'
                      : $c == 0x0c ? '\f'
                      : $c <  0x20 ? sprintf('\x{%x}', $c)
                      : $c == 0x5c ? '\\\\'
                      : $c <  0x80 ? chr($c)
                      : sprintf('\x{%x}', $c)
                      ;
              if ( length $mess >= 20 ) {
                  $mess .= '...';
                  last;
              }
          }
  
          unless ( length $mess ) {
              $mess = '(end of string)';
          }
  
          Carp::croak (
              $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
          );
  
      }
  
  
      sub _json_object_hook {
          my $o    = $_[0];
          my @ks = keys %{$o};
  
          if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
              my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
              if (@val == 1) {
                  return $val[0];
              }
          }
  
          my @val = $cb_object->($o) if ($cb_object);
          if (@val == 0 or @val > 1) {
              return $o;
          }
          else {
              return $val[0];
          }
      }
  
  
      sub PP_decode_box {
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
      }
  
  } # PARSE
  
  
  sub _decode_surrogates { # from perlunicode
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
      my $un  = pack('U*', $uni);
      utf8::encode( $un );
      return $un;
  }
  
  
  sub _decode_unicode {
      my $un = pack('U', hex shift);
      utf8::encode( $un );
      return $un;
  }
  
  #
  # Setup for various Perl versions (the code from JSON::PP58)
  #
  
  BEGIN {
  
      unless ( defined &utf8::is_utf8 ) {
         require Encode;
         *utf8::is_utf8 = *Encode::is_utf8;
      }
  
      if ( $] >= 5.008 ) {
          *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
          *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
          *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
          *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
      }
  
      if ($] >= 5.008 and $] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
          package # hide from PAUSE
            JSON::PP;
          require subs;
          subs->import('join');
          eval q|
              sub join {
                  return '' if (@_ < 2);
                  my $j   = shift;
                  my $str = shift;
                  for (@_) { $str .= $j . $_; }
                  return $str;
              }
          |;
      }
  
  
      sub JSON::PP::incr_parse {
          local $Carp::CarpLevel = 1;
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
      }
  
  
      sub JSON::PP::incr_skip {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
      }
  
  
      sub JSON::PP::incr_reset {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
      }
  
      eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                  Carp::croak("incr_text can not be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ( $] >= 5.006 );
  
  } # Setup for various Perl versions (the code from JSON::PP58)
  
  
  ###############################
  # Utilities
  #
  
  BEGIN {
      eval 'require Scalar::Util';
      unless($@){
          *JSON::PP::blessed = \&Scalar::Util::blessed;
          *JSON::PP::reftype = \&Scalar::Util::reftype;
          *JSON::PP::refaddr = \&Scalar::Util::refaddr;
      }
      else{ # This code is from Scalar::Util.
          # warn $@;
          eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
          *JSON::PP::blessed = sub {
              local($@, $SIG{__DIE__}, $SIG{__WARN__});
              ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
          };
          my %tmap = qw(
              B::NULL   SCALAR
              B::HV     HASH
              B::AV     ARRAY
              B::CV     CODE
              B::IO     IO
              B::GV     GLOB
              B::REGEXP REGEXP
          );
          *JSON::PP::reftype = sub {
              my $r = shift;
  
              return undef unless length(ref($r));
  
              my $t = ref(B::svref_2object($r));
  
              return
                  exists $tmap{$t} ? $tmap{$t}
                : length(ref($$r)) ? 'REF'
                :                    'SCALAR';
          };
          *JSON::PP::refaddr = sub {
            return undef unless length(ref($_[0]));
  
            my $addr;
            if(defined(my $pkg = blessed($_[0]))) {
              $addr .= bless $_[0], 'Scalar::Util::Fake';
              bless $_[0], $pkg;
            }
            else {
              $addr .= $_[0]
            }
  
            $addr =~ /0x(\w+)/;
            local $^W;
            #no warnings 'portable';
            hex($1);
          }
      }
  }
  
  
  # shamelessly copied and modified from JSON::XS code.
  
  unless ( $INC{'JSON/PP.pm'} ) {
      eval q|
          package
              JSON::PP::Boolean;
  
          use overload (
              "0+"     => sub { ${$_[0]} },
              "++"     => sub { $_[0] = ${$_[0]} + 1 },
              "--"     => sub { $_[0] = ${$_[0]} - 1 },
              fallback => 1,
          );
      |;
  }
  
  $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
  $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
  
  sub is_bool { defined $_[0] and UNIVERSAL::isa($_[0], "JSON::PP::Boolean"); }
  
  sub true  { $JSON::PP::true  }
  sub false { $JSON::PP::false }
  sub null  { undef; }
  
  ###############################
  
  ###############################
  
  package # hide from PAUSE
    JSON::PP::IncrParser;
  
  use strict;
  
  use constant INCR_M_WS   => 0; # initial whitespace skipping
  use constant INCR_M_STR  => 1; # inside string
  use constant INCR_M_BS   => 2; # inside backslash
  use constant INCR_M_JSON => 3; # outside anything, count nesting
  use constant INCR_M_C0   => 4;
  use constant INCR_M_C1   => 5;
  
  use vars qw($VERSION);
  $VERSION = '1.01';
  
  my $unpack_format = $] < 5.006 ? 'C*' : 'U*';
  
  sub new {
      my ( $class ) = @_;
  
      bless {
          incr_nest    => 0,
          incr_text    => undef,
          incr_parsing => 0,
          incr_p       => 0,
      }, $class;
  }
  
  
  sub incr_parse {
      my ( $self, $coder, $text ) = @_;
  
      $self->{incr_text} = '' unless ( defined $self->{incr_text} );
  
      if ( defined $text ) {
          if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
              utf8::upgrade( $self->{incr_text} ) ;
              utf8::decode( $self->{incr_text} ) ;
          }
          $self->{incr_text} .= $text;
      }
  
  
      my $max_size = $coder->get_max_size;
  
      if ( defined wantarray ) {
  
          $self->{incr_mode} = INCR_M_WS unless defined $self->{incr_mode};
  
          if ( wantarray ) {
              my @ret;
  
              $self->{incr_parsing} = 1;
  
              do {
                  push @ret, $self->_incr_parse( $coder, $self->{incr_text} );
  
                  unless ( !$self->{incr_nest} and $self->{incr_mode} == INCR_M_JSON ) {
                      $self->{incr_mode} = INCR_M_WS if $self->{incr_mode} != INCR_M_STR;
                  }
  
              } until ( length $self->{incr_text} >= $self->{incr_p} );
  
              $self->{incr_parsing} = 0;
  
              return @ret;
          }
          else { # in scalar context
              $self->{incr_parsing} = 1;
              my $obj = $self->_incr_parse( $coder, $self->{incr_text} );
              $self->{incr_parsing} = 0 if defined $obj; # pointed by Martin J. Evans
              return $obj ? $obj : undef; # $obj is an empty string, parsing was completed.
          }
  
      }
  
  }
  
  
  sub _incr_parse {
      my ( $self, $coder, $text, $skip ) = @_;
      my $p = $self->{incr_p};
      my $restore = $p;
  
      my @obj;
      my $len = length $text;
  
      if ( $self->{incr_mode} == INCR_M_WS ) {
          while ( $len > $p ) {
              my $s = substr( $text, $p, 1 );
              $p++ and next if ( 0x20 >= unpack($unpack_format, $s) );
              $self->{incr_mode} = INCR_M_JSON;
              last;
         }
      }
  
      while ( $len > $p ) {
          my $s = substr( $text, $p++, 1 );
  
          if ( $s eq '"' ) {
              if (substr( $text, $p - 2, 1 ) eq '\\' ) {
                  next;
              }
  
              if ( $self->{incr_mode} != INCR_M_STR  ) {
                  $self->{incr_mode} = INCR_M_STR;
              }
              else {
                  $self->{incr_mode} = INCR_M_JSON;
                  unless ( $self->{incr_nest} ) {
                      last;
                  }
              }
          }
  
          if ( $self->{incr_mode} == INCR_M_JSON ) {
  
              if ( $s eq '[' or $s eq '{' ) {
                  if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                      Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                  }
              }
              elsif ( $s eq ']' or $s eq '}' ) {
                  last if ( --$self->{incr_nest} <= 0 );
              }
              elsif ( $s eq '#' ) {
                  while ( $len > $p ) {
                      last if substr( $text, $p++, 1 ) eq "\n";
                  }
              }
  
          }
  
      }
  
      $self->{incr_p} = $p;
  
      return if ( $self->{incr_mode} == INCR_M_STR and not $self->{incr_nest} );
      return if ( $self->{incr_mode} == INCR_M_JSON and $self->{incr_nest} > 0 );
  
      return '' unless ( length substr( $self->{incr_text}, 0, $p ) );
  
      local $Carp::CarpLevel = 2;
  
      $self->{incr_p} = $restore;
      $self->{incr_c} = $p;
  
      my ( $obj, $tail ) = $coder->PP_decode_json( substr( $self->{incr_text}, 0, $p ), 0x10000001 );
  
      $self->{incr_text} = substr( $self->{incr_text}, $p );
      $self->{incr_p} = 0;
  
      return $obj || '';
  }
  
  
  sub incr_text {
      if ( $_[0]->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
      $_[0]->{incr_text};
  }
  
  
  sub incr_skip {
      my $self  = shift;
      $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_c} );
      $self->{incr_p} = 0;
  }
  
  
  sub incr_reset {
      my $self = shift;
      $self->{incr_text}    = undef;
      $self->{incr_p}       = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
      $self->{incr_parsing} = 0;
  }
  
  ###############################
  
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  JSON::PP - JSON::XS compatible pure-Perl module.
  
  =head1 SYNOPSIS
  
   use JSON::PP;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = JSON::PP->new->ascii->pretty->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # Note that JSON version 2.0 and above will automatically use
   # JSON::XS or JSON::PP, so you should be able to just:
   
   use JSON;
  
  
  =head1 VERSION
  
      2.27200
  
  L<JSON::XS> 2.27 (~2.30) compatible.
  
  =head1 DESCRIPTION
  
  This module is L<JSON::XS> compatible pure Perl module.
  (Perl 5.8 or later is recommended)
  
  JSON::XS is the fastest and most proper JSON module on CPAN.
  It is written by Marc Lehmann in C, so must be compiled and
  installed in the used environment.
  
  JSON::PP is a pure-Perl module and has compatibility to JSON::XS.
  
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module knows how to handle Unicode (depending on Perl version).
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL> and
  L<UNICODE HANDLING ON PERLS>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types
  supported by JSON and Perl, the deserialised data structure is
  identical on the Perl level. (e.g. the string "2.0" doesn't suddenly
  become "2" just because it looks like a number). There I<are> minor
  exceptions to this, read the MAPPING section below to learn about
  those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a
  security feature). But when some options are set, loose checking
  features are available.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON::PP->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON::PP->new->utf8->decode($json_text)
  
  =head2 JSON::PP::is_bool
  
      $is_boolean = JSON::PP::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::PP::true or
  JSON::PP::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::PP::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl version is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON::PP->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 METHODS
  
  Basically, check to L<JSON> or L<JSON::XS>.
  
  =head2 new
  
      $json = JSON::PP->new
  
  Returns a new JSON::PP object that can be used to de/encode JSON
  strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  (See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>).
  
  In Perl 5.005, there is no character having high value (more than 255).
  See to L<UNICODE HANDLING ON PERLS>.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
    JSON::PP->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  See to L<UNICODE HANDLING ON PERLS>.
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  (In Perl 5.005, any character outside the range 0..255 does not exist.
  See to L<UNICODE HANDLING ON PERLS>.)
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> flags in one call to generate the most readable
  (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  The default indent space length is three.
  You can use C<indent_length> to change the length.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  If you want your own sorting routine, you can give a code reference
  or a subroutine name to C<sort_by>. See to C<JSON::PP OWN METHODS>.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON::PP->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::PP->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::PP
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  In JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible.
  It will also try to downgrade any strings to octet-form if possible.
  
  In JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>.
  See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
  
  When a large value (100 or more) was set and it de/encodes a deep nested object/text,
  it may raise a warning 'Deep recursion on subroutine' at the perl runtime phase.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthesis
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP OWN METHODS
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contrary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<JSON::XS/MAPPING> about the normal conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But default
  JSON::PP (as same as JSON::XS) encodes strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  JSON::XS indent space length is 3 and cannot be changed.
  JSON::PP set the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used
  in encoding JSON objects.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  =head1 INTERNAL
  
  For developers.
  
  =over
  
  =item PP_encode_box
  
  Returns
  
          {
              depth        => $depth,
              indent_count => $indent_count,
          }
  
  
  =item PP_decode_box
  
  Returns
  
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
  
  =back
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON::PP>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the least significant bit.
  
  When C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::PP::true . "\n";
      => true
     print JSON::PP::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::PP::null> returns C<undef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same data structure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::PP::true]      # yields [false,true]
  
  =item JSON::PP::true, JSON::PP::false, JSON::PP::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::PP::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  When C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 UNICODE HANDLING ON PERLS
  
  If you do not know about Unicode on Perl well,
  please check L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =head2 Perl 5.8 and later
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work properly.
  
      $json->allow_nonref->encode(chr hex 3042);
      $json->allow_nonref->encode(chr hex 12345);
  
  Returns C<"\u3042"> and C<"\ud808\udf45"> respectively.
  
      $json->allow_nonref->decode('"\u3042"');
      $json->allow_nonref->decode('"\ud808\udf45"');
  
  Returns UTF-8 encoded strings with UTF8 flag, regarded as C<U+3042> and C<U+12345>.
  
  Note that the versions from Perl 5.8.0 to 5.8.2, Perl built-in C<join> was broken,
  so JSON::PP wraps the C<join> with a subroutine. Thus JSON::PP works slow in the versions.
  
  
  =head2 Perl 5.6
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work.
  
  =head2 Perl 5.005
  
  Perl 5.005 is a byte semantics world -- all strings are sequences of bytes.
  That means the unicode handling is not available.
  
  In encoding,
  
      $json->allow_nonref->encode(chr hex 3042);  # hex 3042 is 12354.
      $json->allow_nonref->encode(chr hex 12345); # hex 12345 is 74565.
  
  Returns C<B> and C<E>, as C<chr> takes a value more than 255, it treats
  as C<$value % 256>, so the above codes are equivalent to :
  
      $json->allow_nonref->encode(chr 66);
      $json->allow_nonref->encode(chr 69);
  
  In decoding,
  
      $json->decode('"\u00e3\u0081\u0082"');
  
  The returned is a byte sequence C<0xE3 0x81 0x82> for UTF-8 encoded
  japanese character (C<HIRAGANA LETTER A>).
  And if it is represented in Unicode code point, C<U+3042>.
  
  Next, 
  
      $json->decode('"\u3042"');
  
  We ordinary expect the returned value is a Unicode character C<U+3042>.
  But here is 5.005 world. This is C<0xE3 0x81 0x82>.
  
      $json->decode('"\ud808\udf45"');
  
  This is not a character C<U+12345> but bytes - C<0xf0 0x92 0x8d 0x85>.
  
  
  =head1 TODO
  
  =over
  
  =item speed
  
  =item memory saving
  
  =back
  
  
  =head1 SEE ALSO
  
  Most of the document are copied and modified from JSON::XS doc.
  
  L<JSON::XS>
  
  RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
JSON_BACKPORTPP

$fatpacked{"JSON/backportPP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_BOOLEAN';
  =head1 NAME
  
  JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable
  and similar modules. See L<JSON::PP> for more info about this class.
  
  =cut
  
  use JSON::backportPP ();
  use strict;
  
  1;
  
  =head1 AUTHOR
  
  This idea is from L<JSON::XS::Boolean> written by
  Marc Lehmann <schmorp[at]schmorp.de>
  
  =cut
  
JSON_BACKPORTPP_BOOLEAN

$fatpacked{"JSON/backportPP/Compat5005.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5005';
  package # This is JSON::backportPP
      JSON::backportPP5005;
  
  use 5.005;
  use strict;
  
  my @properties;
  
  $JSON::PP5005::VERSION = '1.10';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          0; # It is considered that UTF8 flag off for Perl 5.005.
      }
  
      sub utf8::upgrade {
      }
  
      sub utf8::downgrade {
          1; # must always return true.
      }
  
      sub utf8::encode  {
      }
  
      sub utf8::decode {
      }
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
  
      # missing in B module.
      sub B::SVp_IOK () { 0x01000000; }
      sub B::SVp_NOK () { 0x02000000; }
      sub B::SVp_POK () { 0x04000000; }
  
      $INC{'bytes.pm'} = 1; # dummy
  }
  
  
  
  sub _encode_ascii {
      join('', map { $_ <= 127 ? chr($_) : sprintf('\u%04x', $_) } unpack('C*', $_[0]) );
  }
  
  
  sub _encode_latin1 {
      join('', map { chr($_) } unpack('C*', $_[0]) );
  }
  
  
  sub _decode_surrogates { # from http://homepage1.nifty.com/nomenclator/unicode/ucs_utf.htm
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00); # from perlunicode
      my $bit = unpack('B32', pack('N', $uni));
  
      if ( $bit =~ /^00000000000(...)(......)(......)(......)$/ ) {
          my ($w, $x, $y, $z) = ($1, $2, $3, $4);
          return pack('B*', sprintf('11110%s10%s10%s10%s', $w, $x, $y, $z));
      }
      else {
          Carp::croak("Invalid surrogate pair");
      }
  }
  
  
  sub _decode_unicode {
      my ($u) = @_;
      my ($utf8bit);
  
      if ( $u =~ /^00([89a-f][0-9a-f])$/i ) { # 0x80-0xff
           return pack( 'H2', $1 );
      }
  
      my $bit = unpack("B*", pack("H*", $u));
  
      if ( $bit =~ /^00000(.....)(......)$/ ) {
          $utf8bit = sprintf('110%s10%s', $1, $2);
      }
      elsif ( $bit =~ /^(....)(......)(......)$/ ) {
          $utf8bit = sprintf('1110%s10%s10%s', $1, $2, $3);
      }
      else {
          Carp::croak("Invalid escaped unicode");
      }
  
      return pack('B*', $utf8bit);
  }
  
  
  sub JSON::PP::incr_text {
      $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
      if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
  
      $_[0]->{_incr_parser}->{incr_text} = $_[1] if ( @_ > 1 );
      $_[0]->{_incr_parser}->{incr_text};
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP5005 - Helper module in using JSON::PP in Perl 5.005
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5005

$fatpacked{"JSON/backportPP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5006';
  package # This is JSON::backportPP
      JSON::backportPP56;
  
  use 5.006;
  use strict;
  
  my @properties;
  
  $JSON::PP56::VERSION = '1.08';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          my $len =  length $_[0]; # char length
          {
              use bytes; #  byte length;
              return $len != length $_[0]; # if !=, UTF8-flagged on.
          }
      }
  
  
      sub utf8::upgrade {
          ; # noop;
      }
  
  
      sub utf8::downgrade ($;$) {
          return 1 unless ( utf8::is_utf8( $_[0] ) );
  
          if ( _is_valid_utf8( $_[0] ) ) {
              my $downgrade;
              for my $c ( unpack( "U*", $_[0] ) ) {
                  if ( $c < 256 ) {
                      $downgrade .= pack("C", $c);
                  }
                  else {
                      $downgrade .= pack("U", $c);
                  }
              }
              $_[0] = $downgrade;
              return 1;
          }
          else {
              Carp::croak("Wide character in subroutine entry") unless ( $_[1] );
              0;
          }
      }
  
  
      sub utf8::encode ($) { # UTF8 flag off
          if ( utf8::is_utf8( $_[0] ) ) {
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
          else {
              $_[0] = pack( "U*", unpack( "C*", $_[0] ) );
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
      }
  
  
      sub utf8::decode ($) { # UTF8 flag on
          if ( _is_valid_utf8( $_[0] ) ) {
              utf8::downgrade( $_[0] );
              $_[0] = pack( "U*", unpack( "U*", $_[0] ) );
          }
      }
  
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&JSON::PP::_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&JSON::PP::_decode_unicode;
  
      unless ( defined &B::SVp_NOK ) { # missing in B module.
          eval q{ sub B::SVp_NOK () { 0x02000000; } };
      }
  
  }
  
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _unpack_emu { # for Perl 5.6 unpack warnings
      return   !utf8::is_utf8($_[0]) ? unpack('C*', $_[0]) 
             : _is_valid_utf8($_[0]) ? unpack('U*', $_[0])
             : unpack('C*', $_[0]);
  }
  
  
  sub _is_valid_utf8 {
      my $str = $_[0];
      my $is_utf8;
  
      while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg)
      {
          if (defined $1) {
              $is_utf8 = 1 if (!defined $is_utf8);
          }
          else {
              $is_utf8 = 0 if (!defined $is_utf8);
              if ($is_utf8) { # eventually, not utf8
                  return;
              }
          }
      }
  
      return $is_utf8;
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP56 - Helper module in using JSON::PP in Perl 5.6
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5006

$fatpacked{"Test/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER';
  package Test::Builder;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  BEGIN {
      if( $] < 5.008 ) {
          require Test::Builder::IO::Scalar;
      }
  }
  
  use Scalar::Util qw/blessed reftype weaken/;
  
  use Test2::Util qw/USE_THREADS try get_tid/;
  use Test2::API qw/context release/;
  # Make Test::Builder thread-safe for ithreads.
  BEGIN {
      warn "Test::Builder was loaded after Test2 initialization, this is not recommended."
          if Test2::API::test2_init_done() || Test2::API::test2_load_done();
  
      if (USE_THREADS) {
          require Test2::IPC;
          require Test2::IPC::Driver::Files;
          Test2::IPC::Driver::Files->import;
          Test2::API::test2_ipc_enable_polling();
          Test2::API::test2_no_wait(1);
          Test2::API::test2_ipc_enable_shm();
      }
  }
  
  use Test2::Event::Subtest;
  use Test2::Hub::Subtest;
  
  use Test::Builder::Formatter;
  use Test::Builder::TodoDiag;
  
  our $Level = 1;
  our $Test = $ENV{TB_NO_EARLY_INIT} ? undef : Test::Builder->new;
  
  sub _add_ts_hooks {
      my $self = shift;
  
      my $hub = $self->{Stack}->top;
  
      # Take a reference to the hash key, we do this to avoid closing over $self
      # which is the singleton. We use a reference because the value could change
      # in rare cases.
      my $epkgr = \$self->{Exported_To};
  
      #$hub->add_context_aquire(sub {$_[0]->{level} += $Level - 1});
  
      $hub->pre_filter(sub {
          my ($active_hub, $e) = @_;
  
          my $epkg = $$epkgr;
          my $cpkg = $e->{trace} ? $e->{trace}->{frame}->[0] : undef;
  
          no strict 'refs';
          no warnings 'once';
          my $todo;
          $todo = ${"$cpkg\::TODO"} if $cpkg;
          $todo = ${"$epkg\::TODO"} if $epkg && !$todo;
  
          return $e unless $todo;
  
          # Turn a diag into a todo diag
          return Test::Builder::TodoDiag->new(%$e) if ref($e) eq 'Test2::Event::Diag';
  
          if ($active_hub == $hub) {
              $e->set_todo($todo) if $e->can('set_todo');
              $e->add_amnesty({tag => 'TODO', details => $todo});
          }
          else {
              $e->add_amnesty({tag => 'TODO', details => $todo, inherited => 1});
          }
  
          # Set todo on ok's
          if ($e->isa('Test2::Event::Ok')) {
              $e->set_effective_pass(1);
  
              if (my $result = $e->get_meta(__PACKAGE__)) {
                  $result->{reason} ||= $todo;
                  $result->{type}   ||= 'todo';
                  $result->{ok}       = 1;
              }
          }
  
          return $e;
      }, inherit => 1);
  }
  
  {
      no warnings;
      INIT {
          use warnings;
          Test2::API::test2_load() unless Test2::API::test2_in_preload();
      }
  }
  
  sub new {
      my($class) = shift;
      unless($Test) {
          $Test = $class->create(singleton => 1);
  
          Test2::API::test2_add_callback_post_load(
              sub {
                  $Test->{Original_Pid} = $$ if !$Test->{Original_Pid} || $Test->{Original_Pid} == 0;
                  $Test->reset(singleton => 1);
                  $Test->_add_ts_hooks;
              }
          );
  
          # Non-TB tools normally expect 0 added to the level. $Level is normally 1. So
          # we only want the level to change if $Level != 1.
          # TB->ctx compensates for this later.
          Test2::API::test2_add_callback_context_aquire(sub { $_[0]->{level} += $Level - 1 });
  
          Test2::API::test2_add_callback_exit(sub { $Test->_ending(@_) });
  
          Test2::API::test2_ipc()->set_no_fatal(1) if USE_THREADS;
      }
      return $Test;
  }
  
  sub create {
      my $class = shift;
      my %params = @_;
  
      my $self = bless {}, $class;
      if ($params{singleton}) {
          $self->{Stack} = Test2::API::test2_stack();
      }
      else {
          $self->{Stack} = Test2::API::Stack->new;
          $self->{Stack}->new_hub(
              formatter => Test::Builder::Formatter->new,
              ipc       => Test2::API::test2_ipc(),
          );
  
          $self->reset(%params);
          $self->_add_ts_hooks;
      }
  
      return $self;
  }
  
  sub ctx {
      my $self = shift;
      context(
          # 1 for our frame, another for the -1 off of $Level in our hook at the top.
          level   => 2,
          fudge   => 1,
          stack   => $self->{Stack},
          hub     => $self->{Hub},
          wrapped => 1,
          @_
      );
  }
  
  sub parent {
      my $self = shift;
      my $ctx = $self->ctx;
      my $chub = $self->{Hub} || $ctx->hub;
      $ctx->release;
  
      my $meta = $chub->meta(__PACKAGE__, {});
      my $parent = $meta->{parent};
  
      return undef unless $parent;
  
      return bless {
          Original_Pid => $$,
          Stack => $self->{Stack},
          Hub => $parent,
      }, blessed($self);
  }
  
  sub child {
      my( $self, $name ) = @_;
  
      $name ||= "Child of " . $self->name;
      my $ctx = $self->ctx;
  
      my $parent = $ctx->hub;
      my $pmeta = $parent->meta(__PACKAGE__, {});
      $self->croak("You already have a child named ($pmeta->{child}) running")
          if $pmeta->{child};
  
      $pmeta->{child} = $name;
  
      # Clear $TODO for the child.
      my $orig_TODO = $self->find_TODO(undef, 1, undef);
  
      my $subevents = [];
  
      my $hub = $ctx->stack->new_hub(
          class => 'Test2::Hub::Subtest',
      );
  
      $hub->pre_filter(sub {
          my ($active_hub, $e) = @_;
  
          # Turn a diag into a todo diag
          return Test::Builder::TodoDiag->new(%$e) if ref($e) eq 'Test2::Event::Diag';
  
          return $e;
      }, inherit => 1) if $orig_TODO;
  
      $hub->listen(sub { push @$subevents => $_[1] });
  
      $hub->set_nested( $parent->nested + 1 );
  
      my $meta = $hub->meta(__PACKAGE__, {});
      $meta->{Name} = $name;
      $meta->{TODO} = $orig_TODO;
      $meta->{TODO_PKG} = $ctx->trace->package;
      $meta->{parent} = $parent;
      $meta->{Test_Results} = [];
      $meta->{subevents} = $subevents;
      $meta->{subtest_id} = $hub->id;
      $meta->{subtest_buffered} = $parent->format ? 0 : 1;
  
      $self->_add_ts_hooks;
  
      $ctx->release;
      return bless { Original_Pid => $$, Stack => $self->{Stack}, Hub => $hub, no_log_results => $self->{no_log_results} }, blessed($self);
  }
  
  sub finalize {
      my $self = shift;
      my $ok = 1;
      ($ok) = @_ if @_;
  
      my $st_ctx = $self->ctx;
      my $chub = $self->{Hub} || return $st_ctx->release;
  
      my $meta = $chub->meta(__PACKAGE__, {});
      if ($meta->{child}) {
          $self->croak("Can't call finalize() with child ($meta->{child}) active");
      }
  
      local $? = 0;     # don't fail if $subtests happened to set $? nonzero
  
      $self->{Stack}->pop($chub);
  
      $self->find_TODO($meta->{TODO_PKG}, 1, $meta->{TODO});
  
      my $parent = $self->parent;
      my $ctx = $parent->ctx;
      my $trace = $ctx->trace;
      delete $ctx->hub->meta(__PACKAGE__, {})->{child};
  
      $chub->finalize($trace->snapshot(hid => $chub->hid, nested => $chub->nested), 1)
          if $ok
          && $chub->count
          && !$chub->no_ending
          && !$chub->ended;
  
      my $plan   = $chub->plan || 0;
      my $count  = $chub->count;
      my $failed = $chub->failed;
      my $passed = $chub->is_passing;
  
      my $num_extra = $plan =~ m/\D/ ? 0 : $count - $plan;
      if ($count && $num_extra != 0) {
          my $s = $plan == 1 ? '' : 's';
          $st_ctx->diag(<<"FAIL");
  Looks like you planned $plan test$s but ran $count.
  FAIL
      }
  
      if ($failed) {
          my $s = $failed == 1 ? '' : 's';
  
          my $qualifier = $num_extra == 0 ? '' : ' run';
  
          $st_ctx->diag(<<"FAIL");
  Looks like you failed $failed test$s of $count$qualifier.
  FAIL
      }
  
      if (!$passed && !$failed && $count && !$num_extra) {
          $st_ctx->diag(<<"FAIL");
  All assertions inside the subtest passed, but errors were encountered.
  FAIL
      }
  
      $st_ctx->release;
  
      unless ($chub->bailed_out) {
          my $plan = $chub->plan;
          if ( $plan && $plan eq 'SKIP' ) {
              $parent->skip($chub->skip_reason, $meta->{Name});
          }
          elsif ( !$chub->count ) {
              $parent->ok( 0, sprintf q[No tests run for subtest "%s"], $meta->{Name} );
          }
          else {
              $parent->{subevents}  = $meta->{subevents};
              $parent->{subtest_id} = $meta->{subtest_id};
              $parent->{subtest_buffered} = $meta->{subtest_buffered};
              $parent->ok( $chub->is_passing, $meta->{Name} );
          }
      }
  
      $ctx->release;
      return $chub->is_passing;
  }
  
  sub subtest {
      my $self = shift;
      my ($name, $code, @args) = @_;
      my $ctx = $self->ctx;
      $ctx->throw("subtest()'s second argument must be a code ref")
          unless $code && reftype($code) eq 'CODE';
  
      $name ||= "Child of " . $self->name;
  
  
      $_->($name,$code,@args)
          for Test2::API::test2_list_pre_subtest_callbacks();
  
      $ctx->note("Subtest: $name");
  
      my $child = $self->child($name);
  
      my $start_pid = $$;
      my $st_ctx;
      my ($ok, $err, $finished, $child_error);
      T2_SUBTEST_WRAPPER: {
          my $ctx = $self->ctx;
          $st_ctx = $ctx->snapshot;
          $ctx->release;
          $ok = eval { local $Level = 1; $code->(@args); 1 };
          ($err, $child_error) = ($@, $?);
  
          # They might have done 'BEGIN { skip_all => "whatever" }'
          if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/ || (blessed($err) && blessed($err) eq 'Test::Builder::Exception')) {
              $ok  = undef;
              $err = undef;
          }
          else {
              $finished = 1;
          }
      }
  
      if ($start_pid != $$ && !$INC{'Test2/IPC.pm'}) {
          warn $ok ? "Forked inside subtest, but subtest never finished!\n" : $err;
          exit 255;
      }
  
      my $trace = $ctx->trace;
  
      if (!$finished) {
          if(my $bailed = $st_ctx->hub->bailed_out) {
              my $chub = $child->{Hub};
              $self->{Stack}->pop($chub);
              $ctx->bail($bailed->reason);
          }
          my $code = $st_ctx->hub->exit_code;
          $ok = !$code;
          $err = "Subtest ended with exit code $code" if $code;
      }
  
      my $st_hub  = $st_ctx->hub;
      my $plan  = $st_hub->plan;
      my $count = $st_hub->count;
  
      if (!$count && (!defined($plan) || "$plan" ne 'SKIP')) {
          $st_ctx->plan(0) unless defined $plan;
          $st_ctx->diag('No tests run!');
      }
  
      $child->finalize($st_ctx->trace);
  
      $ctx->release;
  
      die $err unless $ok;
  
      $? = $child_error if defined $child_error;
  
      return $st_hub->is_passing;
  }
  
  sub name {
      my $self = shift;
      my $ctx = $self->ctx;
      release $ctx, $ctx->hub->meta(__PACKAGE__, {})->{Name};
  }
  
  sub reset {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
      my ($self, %params) = @_;
  
      Test2::API::test2_set_is_end(0);
  
      # We leave this a global because it has to be localized and localizing
      # hash keys is just asking for pain.  Also, it was documented.
      $Level = 1;
  
      $self->{no_log_results} = $ENV{TEST_NO_LOG_RESULTS} ? 1 : 0
          unless $params{singleton};
  
      $self->{Original_Pid} = Test2::API::test2_in_preload() ? -1 : $$;
  
      my $ctx = $self->ctx;
      my $hub = $ctx->hub;
      $ctx->release;
      unless ($params{singleton}) {
          $hub->reset_state();
          $hub->_tb_reset();
      }
  
      $ctx = $self->ctx;
  
      my $meta = $ctx->hub->meta(__PACKAGE__, {});
      %$meta = (
          Name         => $0,
          Ending       => 0,
          Done_Testing => undef,
          Skip_All     => 0,
          Test_Results => [],
          parent       => $meta->{parent},
      );
  
      $self->{Exported_To} = undef unless $params{singleton};
  
      $self->{Orig_Handles} ||= do {
          my $format = $ctx->hub->format;
          my $out;
          if ($format && $format->isa('Test2::Formatter::TAP')) {
              $out = $format->handles;
          }
          $out ? [@$out] : [];
      };
  
      $self->use_numbers(1);
      $self->no_header(0) unless $params{singleton};
      $self->no_ending(0) unless $params{singleton};
      $self->reset_outputs;
  
      $ctx->release;
  
      return;
  }
  
  
  my %plan_cmds = (
      no_plan  => \&no_plan,
      skip_all => \&skip_all,
      tests    => \&_plan_tests,
  );
  
  sub plan {
      my( $self, $cmd, $arg ) = @_;
  
      return unless $cmd;
  
      my $ctx = $self->ctx;
      my $hub = $ctx->hub;
  
      $ctx->throw("You tried to plan twice") if $hub->plan;
  
      local $Level = $Level + 1;
  
      if( my $method = $plan_cmds{$cmd} ) {
          local $Level = $Level + 1;
          $self->$method($arg);
      }
      else {
          my @args = grep { defined } ( $cmd, $arg );
          $ctx->throw("plan() doesn't understand @args");
      }
  
      release $ctx, 1;
  }
  
  
  sub _plan_tests {
      my($self, $arg) = @_;
  
      my $ctx = $self->ctx;
  
      if($arg) {
          local $Level = $Level + 1;
          $self->expected_tests($arg);
      }
      elsif( !defined $arg ) {
          $ctx->throw("Got an undefined number of tests");
      }
      else {
          $ctx->throw("You said to run 0 tests");
      }
  
      $ctx->release;
  }
  
  
  sub expected_tests {
      my $self = shift;
      my($max) = @_;
  
      my $ctx = $self->ctx;
  
      if(@_) {
          $self->croak("Number of tests must be a positive integer.  You gave it '$max'")
            unless $max =~ /^\+?\d+$/;
  
          $ctx->plan($max);
      }
  
      my $hub = $ctx->hub;
  
      $ctx->release;
  
      my $plan = $hub->plan;
      return 0 unless $plan;
      return 0 if $plan =~ m/\D/;
      return $plan;
  }
  
  
  sub no_plan {
      my($self, $arg) = @_;
  
      my $ctx = $self->ctx;
  
      if (defined $ctx->hub->plan) {
          warn "Plan already set, no_plan() is a no-op, this will change to a hard failure in the future.";
          $ctx->release;
          return;
      }
  
      $ctx->alert("no_plan takes no arguments") if $arg;
  
      $ctx->hub->plan('NO PLAN');
  
      release $ctx, 1;
  }
  
  
  sub done_testing {
      my($self, $num_tests) = @_;
  
      my $ctx = $self->ctx;
  
      my $meta = $ctx->hub->meta(__PACKAGE__, {});
  
      if ($meta->{Done_Testing}) {
          my ($file, $line) = @{$meta->{Done_Testing}}[1,2];
          local $ctx->hub->{ended}; # OMG This is awful.
          $self->ok(0, "done_testing() was already called at $file line $line");
          $ctx->release;
          return;
      }
      $meta->{Done_Testing} = [$ctx->trace->call];
  
      my $plan = $ctx->hub->plan;
      my $count = $ctx->hub->count;
  
      # If done_testing() specified the number of tests, shut off no_plan
      if( defined $num_tests ) {
          $ctx->plan($num_tests) if !$plan || $plan eq 'NO PLAN';
      }
      elsif ($count && defined $num_tests && $count != $num_tests) {
          $self->ok(0, "planned to run @{[ $self->expected_tests ]} but done_testing() expects $num_tests");
      }
      else {
          $num_tests = $self->current_test;
      }
  
      if( $self->expected_tests && $num_tests != $self->expected_tests ) {
          $self->ok(0, "planned to run @{[ $self->expected_tests ]} ".
                       "but done_testing() expects $num_tests");
      }
  
      $ctx->plan($num_tests) if $ctx->hub->plan && $ctx->hub->plan eq 'NO PLAN';
  
      $ctx->hub->finalize($ctx->trace, 1);
  
      release $ctx, 1;
  }
  
  
  sub has_plan {
      my $self = shift;
  
      my $ctx = $self->ctx;
      my $plan = $ctx->hub->plan;
      $ctx->release;
  
      return( $plan ) if $plan && $plan !~ m/\D/;
      return('no_plan') if $plan && $plan eq 'NO PLAN';
      return(undef);
  }
  
  
  sub skip_all {
      my( $self, $reason ) = @_;
  
      my $ctx = $self->ctx;
  
      $ctx->hub->meta(__PACKAGE__, {})->{Skip_All} = $reason || 1;
  
      # Work around old perl bug
      if ($] < 5.020000) {
          my $begin = 0;
          my $level = 0;
          while (my @call = caller($level++)) {
              last unless @call && $call[0];
              next unless $call[3] =~ m/::BEGIN$/;
              $begin++;
              last;
          }
          # HACK!
          die 'Label not found for "last T2_SUBTEST_WRAPPER"' if $begin && $ctx->hub->meta(__PACKAGE__, {})->{parent};
      }
  
      $ctx->plan(0, SKIP => $reason);
  }
  
  
  sub exported_to {
      my( $self, $pack ) = @_;
  
      if( defined $pack ) {
          $self->{Exported_To} = $pack;
      }
      return $self->{Exported_To};
  }
  
  
  sub ok {
      my( $self, $test, $name ) = @_;
  
      my $ctx = $self->ctx;
  
      # $test might contain an object which we don't want to accidentally
      # store, so we turn it into a boolean.
      $test = $test ? 1 : 0;
  
      # In case $name is a string overloaded object, force it to stringify.
      no  warnings qw/uninitialized numeric/;
      $name = "$name" if defined $name;
  
      # Profiling showed that the regex here was a huge time waster, doing the
      # numeric addition first cuts our profile time from ~300ms to ~50ms
      $self->diag(<<"    ERR") if 0 + $name && $name =~ /^[\d\s]+$/;
      You named your test '$name'.  You shouldn't use numbers for your test names.
      Very confusing.
      ERR
      use warnings qw/uninitialized numeric/;
  
      my $trace = $ctx->{trace};
      my $hub   = $ctx->{hub};
  
      my $result = {
          ok => $test,
          actual_ok => $test,
          reason => '',
          type => '',
          (name => defined($name) ? $name : ''),
      };
  
      $hub->{_meta}->{+__PACKAGE__}->{Test_Results}[ $hub->{count} ] = $result unless $self->{no_log_results};
  
      my $orig_name = $name;
  
      my @attrs;
      my $subevents  = delete $self->{subevents};
      my $subtest_id = delete $self->{subtest_id};
      my $subtest_buffered = delete $self->{subtest_buffered};
      my $epkg = 'Test2::Event::Ok';
      if ($subevents) {
          $epkg = 'Test2::Event::Subtest';
          push @attrs => (subevents => $subevents, subtest_id => $subtest_id, buffered => $subtest_buffered);
      }
  
      my $e = bless {
          trace => bless( {%$trace}, 'Test2::EventFacet::Trace'),
          pass  => $test,
          name  => $name,
          _meta => {'Test::Builder' => $result},
          effective_pass => $test,
          @attrs,
      }, $epkg;
      $hub->send($e);
  
      $self->_ok_debug($trace, $orig_name) unless($test);
  
      $ctx->release;
      return $test;
  }
  
  sub _ok_debug {
      my $self = shift;
      my ($trace, $orig_name) = @_;
  
      my $is_todo = defined($self->todo);
  
      my $msg = $is_todo ? "Failed (TODO)" : "Failed";
  
      my (undef, $file, $line) = $trace->call;
      if (defined $orig_name) {
          $self->diag(qq[  $msg test '$orig_name'\n  at $file line $line.\n]);
      }
      else {
          $self->diag(qq[  $msg test at $file line $line.\n]);
      }
  }
  
  sub _diag_fh {
      my $self = shift;
      local $Level = $Level + 1;
      return $self->in_todo ? $self->todo_output : $self->failure_output;
  }
  
  sub _unoverload {
      my ($self, $type, $thing) = @_;
  
      return unless ref $$thing;
      return unless blessed($$thing) || scalar $self->_try(sub{ $$thing->isa('UNIVERSAL') });
      {
          local ($!, $@);
          require overload;
      }
      my $string_meth = overload::Method( $$thing, $type ) || return;
      $$thing = $$thing->$string_meth();
  }
  
  sub _unoverload_str {
      my $self = shift;
  
      $self->_unoverload( q[""], $_ ) for @_;
  }
  
  sub _unoverload_num {
      my $self = shift;
  
      $self->_unoverload( '0+', $_ ) for @_;
  
      for my $val (@_) {
          next unless $self->_is_dualvar($$val);
          $$val = $$val + 0;
      }
  }
  
  # This is a hack to detect a dualvar such as $!
  sub _is_dualvar {
      my( $self, $val ) = @_;
  
      # Objects are not dualvars.
      return 0 if ref $val;
  
      no warnings 'numeric';
      my $numval = $val + 0;
      return ($numval != 0 and $numval ne $val ? 1 : 0);
  }
  
  
  sub is_eq {
      my( $self, $got, $expect, $name ) = @_;
  
      my $ctx = $self->ctx;
  
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $expect ) {
          # undef only matches undef and nothing else
          my $test = !defined $got && !defined $expect;
  
          $self->ok( $test, $name );
          $self->_is_diag( $got, 'eq', $expect ) unless $test;
          $ctx->release;
          return $test;
      }
  
      release $ctx, $self->cmp_ok( $got, 'eq', $expect, $name );
  }
  
  
  sub is_num {
      my( $self, $got, $expect, $name ) = @_;
      my $ctx = $self->ctx;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $expect ) {
          # undef only matches undef and nothing else
          my $test = !defined $got && !defined $expect;
  
          $self->ok( $test, $name );
          $self->_is_diag( $got, '==', $expect ) unless $test;
          $ctx->release;
          return $test;
      }
  
      release $ctx, $self->cmp_ok( $got, '==', $expect, $name );
  }
  
  
  sub _diag_fmt {
      my( $self, $type, $val ) = @_;
  
      if( defined $$val ) {
          if( $type eq 'eq' or $type eq 'ne' ) {
              # quote and force string context
              $$val = "'$$val'";
          }
          else {
              # force numeric context
              $self->_unoverload_num($val);
          }
      }
      else {
          $$val = 'undef';
      }
  
      return;
  }
  
  
  sub _is_diag {
      my( $self, $got, $type, $expect ) = @_;
  
      $self->_diag_fmt( $type, $_ ) for \$got, \$expect;
  
      local $Level = $Level + 1;
      return $self->diag(<<"DIAGNOSTIC");
           got: $got
      expected: $expect
  DIAGNOSTIC
  
  }
  
  sub _isnt_diag {
      my( $self, $got, $type ) = @_;
  
      $self->_diag_fmt( $type, \$got );
  
      local $Level = $Level + 1;
      return $self->diag(<<"DIAGNOSTIC");
           got: $got
      expected: anything else
  DIAGNOSTIC
  }
  
  
  sub isnt_eq {
      my( $self, $got, $dont_expect, $name ) = @_;
      my $ctx = $self->ctx;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $dont_expect ) {
          # undef only matches undef and nothing else
          my $test = defined $got || defined $dont_expect;
  
          $self->ok( $test, $name );
          $self->_isnt_diag( $got, 'ne' ) unless $test;
          $ctx->release;
          return $test;
      }
  
      release $ctx, $self->cmp_ok( $got, 'ne', $dont_expect, $name );
  }
  
  sub isnt_num {
      my( $self, $got, $dont_expect, $name ) = @_;
      my $ctx = $self->ctx;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $dont_expect ) {
          # undef only matches undef and nothing else
          my $test = defined $got || defined $dont_expect;
  
          $self->ok( $test, $name );
          $self->_isnt_diag( $got, '!=' ) unless $test;
          $ctx->release;
          return $test;
      }
  
      release $ctx, $self->cmp_ok( $got, '!=', $dont_expect, $name );
  }
  
  
  sub like {
      my( $self, $thing, $regex, $name ) = @_;
      my $ctx = $self->ctx;
  
      local $Level = $Level + 1;
  
      release $ctx, $self->_regex_ok( $thing, $regex, '=~', $name );
  }
  
  sub unlike {
      my( $self, $thing, $regex, $name ) = @_;
      my $ctx = $self->ctx;
  
      local $Level = $Level + 1;
  
      release $ctx, $self->_regex_ok( $thing, $regex, '!~', $name );
  }
  
  
  my %numeric_cmps = map { ( $_, 1 ) } ( "<", "<=", ">", ">=", "==", "!=", "<=>" );
  
  # Bad, these are not comparison operators. Should we include more?
  my %cmp_ok_bl = map { ( $_, 1 ) } ( "=", "+=", ".=", "x=", "^=", "|=", "||=", "&&=", "...");
  
  sub cmp_ok {
      my( $self, $got, $type, $expect, $name ) = @_;
      my $ctx = $self->ctx;
  
      if ($cmp_ok_bl{$type}) {
          $ctx->throw("$type is not a valid comparison operator in cmp_ok()");
      }
  
      my ($test, $succ);
      my $error;
      {
          ## no critic (BuiltinFunctions::ProhibitStringyEval)
  
          local( $@, $!, $SIG{__DIE__} );    # isolate eval
  
          my($pack, $file, $line) = $ctx->trace->call();
  
          # This is so that warnings come out at the caller's level
          $succ = eval qq[
  #line $line "(eval in cmp_ok) $file"
  \$test = (\$got $type \$expect);
  1;
  ];
          $error = $@;
      }
      local $Level = $Level + 1;
      my $ok = $self->ok( $test, $name );
  
      # Treat overloaded objects as numbers if we're asked to do a
      # numeric comparison.
      my $unoverload
        = $numeric_cmps{$type}
        ? '_unoverload_num'
        : '_unoverload_str';
  
      $self->diag(<<"END") unless $succ;
  An error occurred while using $type:
  ------------------------------------
  $error
  ------------------------------------
  END
  
      unless($ok) {
          $self->$unoverload( \$got, \$expect );
  
          if( $type =~ /^(eq|==)$/ ) {
              $self->_is_diag( $got, $type, $expect );
          }
          elsif( $type =~ /^(ne|!=)$/ ) {
              no warnings;
              my $eq = ($got eq $expect || $got == $expect)
                  && (
                      (defined($got) xor defined($expect))
                   || (length($got)  !=  length($expect))
                  );
              use warnings;
  
              if ($eq) {
                  $self->_cmp_diag( $got, $type, $expect );
              }
              else {
                  $self->_isnt_diag( $got, $type );
              }
          }
          else {
              $self->_cmp_diag( $got, $type, $expect );
          }
      }
      return release $ctx, $ok;
  }
  
  sub _cmp_diag {
      my( $self, $got, $type, $expect ) = @_;
  
      $got    = defined $got    ? "'$got'"    : 'undef';
      $expect = defined $expect ? "'$expect'" : 'undef';
  
      local $Level = $Level + 1;
      return $self->diag(<<"DIAGNOSTIC");
      $got
          $type
      $expect
  DIAGNOSTIC
  }
  
  sub _caller_context {
      my $self = shift;
  
      my( $pack, $file, $line ) = $self->caller(1);
  
      my $code = '';
      $code .= "#line $line $file\n" if defined $file and defined $line;
  
      return $code;
  }
  
  
  sub BAIL_OUT {
      my( $self, $reason ) = @_;
  
      my $ctx = $self->ctx;
  
      $self->{Bailed_Out} = 1;
  
      $ctx->bail($reason);
  }
  
  
  {
      no warnings 'once';
      *BAILOUT = \&BAIL_OUT;
  }
  
  sub skip {
      my( $self, $why, $name ) = @_;
      $why ||= '';
      $name = '' unless defined $name;
      $self->_unoverload_str( \$why );
  
      my $ctx = $self->ctx;
  
      $ctx->hub->meta(__PACKAGE__, {})->{Test_Results}[ $ctx->hub->count ] = {
          'ok'      => 1,
          actual_ok => 1,
          name      => $name,
          type      => 'skip',
          reason    => $why,
      } unless $self->{no_log_results};
  
      $name =~ s|#|\\#|g;    # # in a name can confuse Test::Harness.
      $name =~ s{\n}{\n# }sg;
      $why =~ s{\n}{\n# }sg;
  
      my $tctx = $ctx->snapshot;
      $tctx->skip('', $why);
  
      return release $ctx, 1;
  }
  
  
  sub todo_skip {
      my( $self, $why ) = @_;
      $why ||= '';
  
      my $ctx = $self->ctx;
  
      $ctx->hub->meta(__PACKAGE__, {})->{Test_Results}[ $ctx->hub->count ] = {
          'ok'      => 1,
          actual_ok => 0,
          name      => '',
          type      => 'todo_skip',
          reason    => $why,
      } unless $self->{no_log_results};
  
      $why =~ s{\n}{\n# }sg;
      my $tctx = $ctx->snapshot;
      $tctx->send_event( 'Skip', todo => $why, todo_diag => 1, reason => $why, pass => 0);
  
      return release $ctx, 1;
  }
  
  
  sub maybe_regex {
      my( $self, $regex ) = @_;
      my $usable_regex = undef;
  
      return $usable_regex unless defined $regex;
  
      my( $re, $opts );
  
      # Check for qr/foo/
      if( _is_qr($regex) ) {
          $usable_regex = $regex;
      }
      # Check for '/foo/' or 'm,foo,'
      elsif(( $re, $opts )        = $regex =~ m{^ /(.*)/ (\w*) $ }sx              or
            ( undef, $re, $opts ) = $regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx
      )
      {
          $usable_regex = length $opts ? "(?$opts)$re" : $re;
      }
  
      return $usable_regex;
  }
  
  sub _is_qr {
      my $regex = shift;
  
      # is_regexp() checks for regexes in a robust manner, say if they're
      # blessed.
      return re::is_regexp($regex) if defined &re::is_regexp;
      return ref $regex eq 'Regexp';
  }
  
  sub _regex_ok {
      my( $self, $thing, $regex, $cmp, $name ) = @_;
  
      my $ok           = 0;
      my $usable_regex = $self->maybe_regex($regex);
      unless( defined $usable_regex ) {
          local $Level = $Level + 1;
          $ok = $self->ok( 0, $name );
          $self->diag("    '$regex' doesn't look much like a regex to me.");
          return $ok;
      }
  
      {
          my $test;
          my $context = $self->_caller_context;
  
          {
              ## no critic (BuiltinFunctions::ProhibitStringyEval)
  
              local( $@, $!, $SIG{__DIE__} );    # isolate eval
  
              # No point in issuing an uninit warning, they'll see it in the diagnostics
              no warnings 'uninitialized';
  
              $test = eval $context . q{$test = $thing =~ /$usable_regex/ ? 1 : 0};
          }
  
          $test = !$test if $cmp eq '!~';
  
          local $Level = $Level + 1;
          $ok = $self->ok( $test, $name );
      }
  
      unless($ok) {
          $thing = defined $thing ? "'$thing'" : 'undef';
          my $match = $cmp eq '=~' ? "doesn't match" : "matches";
  
          local $Level = $Level + 1;
          $self->diag( sprintf <<'DIAGNOSTIC', $thing, $match, $regex );
                    %s
      %13s '%s'
  DIAGNOSTIC
  
      }
  
      return $ok;
  }
  
  
  sub is_fh {
      my $self     = shift;
      my $maybe_fh = shift;
      return 0 unless defined $maybe_fh;
  
      return 1 if ref $maybe_fh  eq 'GLOB';    # its a glob ref
      return 1 if ref \$maybe_fh eq 'GLOB';    # its a glob
  
      return eval { $maybe_fh->isa("IO::Handle") } ||
             eval { tied($maybe_fh)->can('TIEHANDLE') };
  }
  
  
  sub level {
      my( $self, $level ) = @_;
  
      if( defined $level ) {
          $Level = $level;
      }
      return $Level;
  }
  
  
  sub use_numbers {
      my( $self, $use_nums ) = @_;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      unless ($format && $format->can('no_numbers') && $format->can('set_no_numbers')) {
          warn "The current formatter does not support 'use_numbers'" if $format;
          return release $ctx, 0;
      }
  
      $format->set_no_numbers(!$use_nums) if defined $use_nums;
  
      return release $ctx, $format->no_numbers ? 0 : 1;
  }
  
  BEGIN {
      for my $method (qw(no_header no_diag)) {
          my $set = "set_$method";
          my $code = sub {
              my( $self, $no ) = @_;
  
              my $ctx = $self->ctx;
              my $format = $ctx->hub->format;
              unless ($format && $format->can($set)) {
                  warn "The current formatter does not support '$method'" if $format;
                  $ctx->release;
                  return
              }
  
              $format->$set($no) if defined $no;
  
              return release $ctx, $format->$method ? 1 : 0;
          };
  
          no strict 'refs';    ## no critic
          *$method = $code;
      }
  }
  
  sub no_ending {
      my( $self, $no ) = @_;
  
      my $ctx = $self->ctx;
  
      $ctx->hub->set_no_ending($no) if defined $no;
  
      return release $ctx, $ctx->hub->no_ending;
  }
  
  sub diag {
      my $self = shift;
      return unless @_;
  
      my $text = join '' => map {defined($_) ? $_ : 'undef'} @_;
  
      if (Test2::API::test2_in_preload()) {
          chomp($text);
          $text =~ s/^/# /msg;
          print STDERR $text, "\n";
          return 0;
      }
  
      my $ctx = $self->ctx;
      $ctx->diag($text);
      $ctx->release;
      return 0;
  }
  
  
  sub note {
      my $self = shift;
      return unless @_;
  
      my $text = join '' => map {defined($_) ? $_ : 'undef'} @_;
  
      if (Test2::API::test2_in_preload()) {
          chomp($text);
          $text =~ s/^/# /msg;
          print STDOUT $text, "\n";
          return 0;
      }
  
      my $ctx = $self->ctx;
      $ctx->note($text);
      $ctx->release;
      return 0;
  }
  
  
  sub explain {
      my $self = shift;
  
      local ($@, $!);
      require Data::Dumper;
  
      return map {
          ref $_
            ? do {
              my $dumper = Data::Dumper->new( [$_] );
              $dumper->Indent(1)->Terse(1);
              $dumper->Sortkeys(1) if $dumper->can("Sortkeys");
              $dumper->Dump;
            }
            : $_
      } @_;
  }
  
  
  sub output {
      my( $self, $fh ) = @_;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      $ctx->release;
      return unless $format && $format->isa('Test2::Formatter::TAP');
  
      $format->handles->[Test2::Formatter::TAP::OUT_STD()] = $self->_new_fh($fh)
          if defined $fh;
  
      return $format->handles->[Test2::Formatter::TAP::OUT_STD()];
  }
  
  sub failure_output {
      my( $self, $fh ) = @_;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      $ctx->release;
      return unless $format && $format->isa('Test2::Formatter::TAP');
  
      $format->handles->[Test2::Formatter::TAP::OUT_ERR()] = $self->_new_fh($fh)
          if defined $fh;
  
      return $format->handles->[Test2::Formatter::TAP::OUT_ERR()];
  }
  
  sub todo_output {
      my( $self, $fh ) = @_;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      $ctx->release;
      return unless $format && $format->isa('Test::Builder::Formatter');
  
      $format->handles->[Test::Builder::Formatter::OUT_TODO()] = $self->_new_fh($fh)
          if defined $fh;
  
      return $format->handles->[Test::Builder::Formatter::OUT_TODO()];
  }
  
  sub _new_fh {
      my $self = shift;
      my($file_or_fh) = shift;
  
      my $fh;
      if( $self->is_fh($file_or_fh) ) {
          $fh = $file_or_fh;
      }
      elsif( ref $file_or_fh eq 'SCALAR' ) {
          # Scalar refs as filehandles was added in 5.8.
          if( $] >= 5.008 ) {
              open $fh, ">>", $file_or_fh
                or $self->croak("Can't open scalar ref $file_or_fh: $!");
          }
          # Emulate scalar ref filehandles with a tie.
          else {
              $fh = Test::Builder::IO::Scalar->new($file_or_fh)
                or $self->croak("Can't tie scalar ref $file_or_fh");
          }
      }
      else {
          open $fh, ">", $file_or_fh
            or $self->croak("Can't open test output log $file_or_fh: $!");
          _autoflush($fh);
      }
  
      return $fh;
  }
  
  sub _autoflush {
      my($fh) = shift;
      my $old_fh = select $fh;
      $| = 1;
      select $old_fh;
  
      return;
  }
  
  
  sub reset_outputs {
      my $self = shift;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      $ctx->release;
      return unless $format && $format->isa('Test2::Formatter::TAP');
      $format->set_handles([@{$self->{Orig_Handles}}]) if $self->{Orig_Handles};
  
      return;
  }
  
  
  sub carp {
      my $self = shift;
      my $ctx = $self->ctx;
      $ctx->alert(join "", @_);
      $ctx->release;
  }
  
  sub croak {
      my $self = shift;
      my $ctx = $self->ctx;
      $ctx->throw(join "", @_);
      $ctx->release;
  }
  
  
  sub current_test {
      my( $self, $num ) = @_;
  
      my $ctx = $self->ctx;
      my $hub = $ctx->hub;
  
      if( defined $num ) {
          $hub->set_count($num);
  
          unless ($self->{no_log_results}) {
              # If the test counter is being pushed forward fill in the details.
              my $test_results = $ctx->hub->meta(__PACKAGE__, {})->{Test_Results};
              if ($num > @$test_results) {
                  my $start = @$test_results ? @$test_results : 0;
                  for ($start .. $num - 1) {
                      $test_results->[$_] = {
                          'ok'      => 1,
                          actual_ok => undef,
                          reason    => 'incrementing test number',
                          type      => 'unknown',
                          name      => undef
                      };
                  }
              }
              # If backward, wipe history.  Its their funeral.
              elsif ($num < @$test_results) {
                  $#{$test_results} = $num - 1;
              }
          }
      }
      return release $ctx, $hub->count;
  }
  
  
  sub is_passing {
      my $self = shift;
  
      my $ctx = $self->ctx;
      my $hub = $ctx->hub;
  
      if( @_ ) {
          my ($bool) = @_;
          $hub->set_failed(0) if $bool;
          $hub->is_passing($bool);
      }
  
      return release $ctx, $hub->is_passing;
  }
  
  
  sub summary {
      my($self) = shift;
  
      return if $self->{no_log_results};
  
      my $ctx = $self->ctx;
      my $data = $ctx->hub->meta(__PACKAGE__, {})->{Test_Results};
      $ctx->release;
      return map { $_ ? $_->{'ok'} : () } @$data;
  }
  
  
  sub details {
      my $self = shift;
  
      return if $self->{no_log_results};
  
      my $ctx = $self->ctx;
      my $data = $ctx->hub->meta(__PACKAGE__, {})->{Test_Results};
      $ctx->release;
      return @$data;
  }
  
  
  sub find_TODO {
      my( $self, $pack, $set, $new_value ) = @_;
  
      my $ctx = $self->ctx;
  
      $pack ||= $ctx->trace->package || $self->exported_to;
      $ctx->release;
  
      return unless $pack;
  
      no strict 'refs';    ## no critic
      no warnings 'once';
      my $old_value = ${ $pack . '::TODO' };
      $set and ${ $pack . '::TODO' } = $new_value;
      return $old_value;
  }
  
  sub todo {
      my( $self, $pack ) = @_;
  
      local $Level = $Level + 1;
      my $ctx = $self->ctx;
      $ctx->release;
  
      my $meta = $ctx->hub->meta(__PACKAGE__, {todo => []})->{todo};
      return $meta->[-1]->[1] if $meta && @$meta;
  
      $pack ||= $ctx->trace->package;
  
      return unless $pack;
  
      no strict 'refs';    ## no critic
      no warnings 'once';
      return ${ $pack . '::TODO' };
  }
  
  sub in_todo {
      my $self = shift;
  
      local $Level = $Level + 1;
      my $ctx = $self->ctx;
      $ctx->release;
  
      my $meta = $ctx->hub->meta(__PACKAGE__, {todo => []})->{todo};
      return 1 if $meta && @$meta;
  
      my $pack = $ctx->trace->package || return 0;
  
      no strict 'refs';    ## no critic
      no warnings 'once';
      my $todo = ${ $pack . '::TODO' };
  
      return 0 unless defined $todo;
      return 0 if "$todo" eq '';
      return 1;
  }
  
  sub todo_start {
      my $self = shift;
      my $message = @_ ? shift : '';
  
      my $ctx = $self->ctx;
  
      my $hub = $ctx->hub;
      my $filter = $hub->pre_filter(sub {
          my ($active_hub, $e) = @_;
  
          # Turn a diag into a todo diag
          return Test::Builder::TodoDiag->new(%$e) if ref($e) eq 'Test2::Event::Diag';
  
          # Set todo on ok's
          if ($hub == $active_hub && $e->isa('Test2::Event::Ok')) {
              $e->set_todo($message);
              $e->set_effective_pass(1);
  
              if (my $result = $e->get_meta(__PACKAGE__)) {
                  $result->{reason} ||= $message;
                  $result->{type}   ||= 'todo';
                  $result->{ok}       = 1;
              }
          }
  
          return $e;
      }, inherit => 1);
  
      push @{$ctx->hub->meta(__PACKAGE__, {todo => []})->{todo}} => [$filter, $message];
  
      $ctx->release;
  
      return;
  }
  
  sub todo_end {
      my $self = shift;
  
      my $ctx = $self->ctx;
  
      my $set = pop @{$ctx->hub->meta(__PACKAGE__, {todo => []})->{todo}};
  
      $ctx->throw('todo_end() called without todo_start()') unless $set;
  
      $ctx->hub->pre_unfilter($set->[0]);
  
      $ctx->release;
  
      return;
  }
  
  
  sub caller {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
      my( $self ) = @_;
  
      my $ctx = $self->ctx;
  
      my $trace = $ctx->trace;
      $ctx->release;
      return wantarray ? $trace->call : $trace->package;
  }
  
  
  sub _try {
      my( $self, $code, %opts ) = @_;
  
      my $error;
      my $return;
      {
          local $!;               # eval can mess up $!
          local $@;               # don't set $@ in the test
          local $SIG{__DIE__};    # don't trip an outside DIE handler.
          $return = eval { $code->() };
          $error = $@;
      }
  
      die $error if $error and $opts{die_on_fail};
  
      return wantarray ? ( $return, $error ) : $return;
  }
  
  sub _ending {
      my $self = shift;
      my ($ctx, $real_exit_code, $new) = @_;
  
      unless ($ctx) {
          my $octx = $self->ctx;
          $ctx = $octx->snapshot;
          $octx->release;
      }
  
      return if $ctx->hub->no_ending;
      return if $ctx->hub->meta(__PACKAGE__, {})->{Ending}++;
  
      # Don't bother with an ending if this is a forked copy.  Only the parent
      # should do the ending.
      return unless $self->{Original_Pid} == $$;
  
      my $hub = $ctx->hub;
      return if $hub->bailed_out;
  
      my $plan  = $hub->plan;
      my $count = $hub->count;
      my $failed = $hub->failed;
      my $passed = $hub->is_passing;
      return unless $plan || $count || $failed;
  
      # Ran tests but never declared a plan or hit done_testing
      if( !$hub->plan and $hub->count ) {
          $self->diag("Tests were run but no plan was declared and done_testing() was not seen.");
  
          if($real_exit_code) {
              $self->diag(<<"FAIL");
  Looks like your test exited with $real_exit_code just after $count.
  FAIL
              $$new ||= $real_exit_code;
              return;
          }
  
          # But if the tests ran, handle exit code.
          if($failed > 0) {
              my $exit_code = $failed <= 254 ? $failed : 254;
              $$new ||= $exit_code;
              return;
          }
  
          $$new ||= 254;
          return;
      }
  
      if ($real_exit_code && !$count) {
          $self->diag("Looks like your test exited with $real_exit_code before it could output anything.");
          $$new ||= $real_exit_code;
          return;
      }
  
      return if $plan && "$plan" eq 'SKIP';
  
      if (!$count) {
          $self->diag('No tests run!');
          $$new ||= 255;
          return;
      }
  
      if ($real_exit_code) {
          $self->diag(<<"FAIL");
  Looks like your test exited with $real_exit_code just after $count.
  FAIL
          $$new ||= $real_exit_code;
          return;
      }
  
      if ($plan eq 'NO PLAN') {
          $ctx->plan( $count );
          $plan = $hub->plan;
      }
  
      # Figure out if we passed or failed and print helpful messages.
      my $num_extra = $count - $plan;
  
      if ($num_extra != 0) {
          my $s = $plan == 1 ? '' : 's';
          $self->diag(<<"FAIL");
  Looks like you planned $plan test$s but ran $count.
  FAIL
      }
  
      if ($failed) {
          my $s = $failed == 1 ? '' : 's';
  
          my $qualifier = $num_extra == 0 ? '' : ' run';
  
          $self->diag(<<"FAIL");
  Looks like you failed $failed test$s of $count$qualifier.
  FAIL
      }
  
      if (!$passed && !$failed && $count && !$num_extra) {
          $ctx->diag(<<"FAIL");
  All assertions passed, but errors were encountered.
  FAIL
      }
  
      my $exit_code = 0;
      if ($failed) {
          $exit_code = $failed <= 254 ? $failed : 254;
      }
      elsif ($num_extra != 0) {
          $exit_code = 255;
      }
      elsif (!$passed) {
          $exit_code = 255;
      }
  
      $$new ||= $exit_code;
      return;
  }
  
  # Some things used this even though it was private... I am looking at you
  # Test::Builder::Prefix...
  sub _print_comment {
      my( $self, $fh, @msgs ) = @_;
  
      return if $self->no_diag;
      return unless @msgs;
  
      # Prevent printing headers when compiling (i.e. -c)
      return if $^C;
  
      # Smash args together like print does.
      # Convert undef to 'undef' so its readable.
      my $msg = join '', map { defined($_) ? $_ : 'undef' } @msgs;
  
      # Escape the beginning, _print will take care of the rest.
      $msg =~ s/^/# /;
  
      local( $\, $", $, ) = ( undef, ' ', '' );
      print $fh $msg;
  
      return 0;
  }
  
  # This is used by Test::SharedFork to turn on IPC after the fact. Not
  # documenting because I do not want it used. The method name is borrowed from
  # Test::Builder 2
  # Once Test2 stuff goes stable this method will be removed and Test::SharedFork
  # will be made smarter.
  sub coordinate_forks {
      my $self = shift;
  
      {
          local ($@, $!);
          require Test2::IPC;
      }
      Test2::IPC->import;
      Test2::API::test2_ipc_enable_polling();
      Test2::API::test2_load();
      my $ipc = Test2::IPC::apply_ipc($self->{Stack});
      $ipc->set_no_fatal(1);
      Test2::API::test2_no_wait(1);
      Test2::API::test2_ipc_enable_shm();
  }
  
  sub no_log_results { $_[0]->{no_log_results} = 1 }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Test::Builder - Backend for building test libraries
  
  =head1 SYNOPSIS
  
    package My::Test::Module;
    use base 'Test::Builder::Module';
  
    my $CLASS = __PACKAGE__;
  
    sub ok {
        my($test, $name) = @_;
        my $tb = $CLASS->builder;
  
        $tb->ok($test, $name);
    }
  
  
  =head1 DESCRIPTION
  
  L<Test::Simple> and L<Test::More> have proven to be popular testing modules,
  but they're not always flexible enough.  Test::Builder provides a
  building block upon which to write your own test libraries I<which can
  work together>.
  
  =head2 Construction
  
  =over 4
  
  =item B<new>
  
    my $Test = Test::Builder->new;
  
  Returns a Test::Builder object representing the current state of the
  test.
  
  Since you only run one test per program C<new> always returns the same
  Test::Builder object.  No matter how many times you call C<new()>, you're
  getting the same object.  This is called a singleton.  This is done so that
  multiple modules share such global information as the test counter and
  where test output is going.
  
  If you want a completely new Test::Builder object different from the
  singleton, use C<create>.
  
  =item B<create>
  
    my $Test = Test::Builder->create;
  
  Ok, so there can be more than one Test::Builder object and this is how
  you get it.  You might use this instead of C<new()> if you're testing
  a Test::Builder based module, but otherwise you probably want C<new>.
  
  B<NOTE>: the implementation is not complete.  C<level>, for example, is still
  shared by B<all> Test::Builder objects, even ones created using this method.
  Also, the method name may change in the future.
  
  =item B<subtest>
  
      $builder->subtest($name, \&subtests, @args);
  
  See documentation of C<subtest> in Test::More.
  
  C<subtest> also, and optionally, accepts arguments which will be passed to the
  subtests reference.
  
  =item B<name>
  
   diag $builder->name;
  
  Returns the name of the current builder.  Top level builders default to C<$0>
  (the name of the executable).  Child builders are named via the C<child>
  method.  If no name is supplied, will be named "Child of $parent->name".
  
  =item B<reset>
  
    $Test->reset;
  
  Reinitializes the Test::Builder singleton to its original state.
  Mostly useful for tests run in persistent environments where the same
  test might be run multiple times in the same process.
  
  =back
  
  =head2 Setting up tests
  
  These methods are for setting up tests and declaring how many there
  are.  You usually only want to call one of these methods.
  
  =over 4
  
  =item B<plan>
  
    $Test->plan('no_plan');
    $Test->plan( skip_all => $reason );
    $Test->plan( tests => $num_tests );
  
  A convenient way to set up your tests.  Call this and Test::Builder
  will print the appropriate headers and take the appropriate actions.
  
  If you call C<plan()>, don't call any of the other methods below.
  
  =item B<expected_tests>
  
      my $max = $Test->expected_tests;
      $Test->expected_tests($max);
  
  Gets/sets the number of tests we expect this test to run and prints out
  the appropriate headers.
  
  
  =item B<no_plan>
  
    $Test->no_plan;
  
  Declares that this test will run an indeterminate number of tests.
  
  
  =item B<done_testing>
  
    $Test->done_testing();
    $Test->done_testing($num_tests);
  
  Declares that you are done testing, no more tests will be run after this point.
  
  If a plan has not yet been output, it will do so.
  
  $num_tests is the number of tests you planned to run.  If a numbered
  plan was already declared, and if this contradicts, a failing test
  will be run to reflect the planning mistake.  If C<no_plan> was declared,
  this will override.
  
  If C<done_testing()> is called twice, the second call will issue a
  failing test.
  
  If C<$num_tests> is omitted, the number of tests run will be used, like
  no_plan.
  
  C<done_testing()> is, in effect, used when you'd want to use C<no_plan>, but
  safer. You'd use it like so:
  
      $Test->ok($a == $b);
      $Test->done_testing();
  
  Or to plan a variable number of tests:
  
      for my $test (@tests) {
          $Test->ok($test);
      }
      $Test->done_testing(scalar @tests);
  
  
  =item B<has_plan>
  
    $plan = $Test->has_plan
  
  Find out whether a plan has been defined. C<$plan> is either C<undef> (no plan
  has been set), C<no_plan> (indeterminate # of tests) or an integer (the number
  of expected tests).
  
  =item B<skip_all>
  
    $Test->skip_all;
    $Test->skip_all($reason);
  
  Skips all the tests, using the given C<$reason>.  Exits immediately with 0.
  
  =item B<exported_to>
  
    my $pack = $Test->exported_to;
    $Test->exported_to($pack);
  
  Tells Test::Builder what package you exported your functions to.
  
  This method isn't terribly useful since modules which share the same
  Test::Builder object might get exported to different packages and only
  the last one will be honored.
  
  =back
  
  =head2 Running tests
  
  These actually run the tests, analogous to the functions in Test::More.
  
  They all return true if the test passed, false if the test failed.
  
  C<$name> is always optional.
  
  =over 4
  
  =item B<ok>
  
    $Test->ok($test, $name);
  
  Your basic test.  Pass if C<$test> is true, fail if $test is false.  Just
  like Test::Simple's C<ok()>.
  
  =item B<is_eq>
  
    $Test->is_eq($got, $expected, $name);
  
  Like Test::More's C<is()>.  Checks if C<$got eq $expected>.  This is the
  string version.
  
  C<undef> only ever matches another C<undef>.
  
  =item B<is_num>
  
    $Test->is_num($got, $expected, $name);
  
  Like Test::More's C<is()>.  Checks if C<$got == $expected>.  This is the
  numeric version.
  
  C<undef> only ever matches another C<undef>.
  
  =item B<isnt_eq>
  
    $Test->isnt_eq($got, $dont_expect, $name);
  
  Like L<Test::More>'s C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
  the string version.
  
  =item B<isnt_num>
  
    $Test->isnt_num($got, $dont_expect, $name);
  
  Like L<Test::More>'s C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
  the numeric version.
  
  =item B<like>
  
    $Test->like($thing, qr/$regex/, $name);
    $Test->like($thing, '/$regex/', $name);
  
  Like L<Test::More>'s C<like()>.  Checks if $thing matches the given C<$regex>.
  
  =item B<unlike>
  
    $Test->unlike($thing, qr/$regex/, $name);
    $Test->unlike($thing, '/$regex/', $name);
  
  Like L<Test::More>'s C<unlike()>.  Checks if $thing B<does not match> the
  given C<$regex>.
  
  =item B<cmp_ok>
  
    $Test->cmp_ok($thing, $type, $that, $name);
  
  Works just like L<Test::More>'s C<cmp_ok()>.
  
      $Test->cmp_ok($big_num, '!=', $other_big_num);
  
  =back
  
  =head2 Other Testing Methods
  
  These are methods which are used in the course of writing a test but are not themselves tests.
  
  =over 4
  
  =item B<BAIL_OUT>
  
      $Test->BAIL_OUT($reason);
  
  Indicates to the L<Test::Harness> that things are going so badly all
  testing should terminate.  This includes running any additional test
  scripts.
  
  It will exit with 255.
  
  =for deprecated
  BAIL_OUT() used to be BAILOUT()
  
  =item B<skip>
  
      $Test->skip;
      $Test->skip($why);
  
  Skips the current test, reporting C<$why>.
  
  =item B<todo_skip>
  
    $Test->todo_skip;
    $Test->todo_skip($why);
  
  Like C<skip()>, only it will declare the test as failing and TODO.  Similar
  to
  
      print "not ok $tnum # TODO $why\n";
  
  =begin _unimplemented
  
  =item B<skip_rest>
  
    $Test->skip_rest;
    $Test->skip_rest($reason);
  
  Like C<skip()>, only it skips all the rest of the tests you plan to run
  and terminates the test.
  
  If you're running under C<no_plan>, it skips once and terminates the
  test.
  
  =end _unimplemented
  
  =back
  
  
  =head2 Test building utility methods
  
  These methods are useful when writing your own test methods.
  
  =over 4
  
  =item B<maybe_regex>
  
    $Test->maybe_regex(qr/$regex/);
    $Test->maybe_regex('/$regex/');
  
  This method used to be useful back when Test::Builder worked on Perls
  before 5.6 which didn't have qr//.  Now its pretty useless.
  
  Convenience method for building testing functions that take regular
  expressions as arguments.
  
  Takes a quoted regular expression produced by C<qr//>, or a string
  representing a regular expression.
  
  Returns a Perl value which may be used instead of the corresponding
  regular expression, or C<undef> if its argument is not recognized.
  
  For example, a version of C<like()>, sans the useful diagnostic messages,
  could be written as:
  
    sub laconic_like {
        my ($self, $thing, $regex, $name) = @_;
        my $usable_regex = $self->maybe_regex($regex);
        die "expecting regex, found '$regex'\n"
            unless $usable_regex;
        $self->ok($thing =~ m/$usable_regex/, $name);
    }
  
  
  =item B<is_fh>
  
      my $is_fh = $Test->is_fh($thing);
  
  Determines if the given C<$thing> can be used as a filehandle.
  
  =cut
  
  
  =back
  
  
  =head2 Test style
  
  
  =over 4
  
  =item B<level>
  
      $Test->level($how_high);
  
  How far up the call stack should C<$Test> look when reporting where the
  test failed.
  
  Defaults to 1.
  
  Setting C<$Test::Builder::Level> overrides.  This is typically useful
  localized:
  
      sub my_ok {
          my $test = shift;
  
          local $Test::Builder::Level = $Test::Builder::Level + 1;
          $TB->ok($test);
      }
  
  To be polite to other functions wrapping your own you usually want to increment C<$Level> rather than set it to a constant.
  
  =item B<use_numbers>
  
      $Test->use_numbers($on_or_off);
  
  Whether or not the test should output numbers.  That is, this if true:
  
    ok 1
    ok 2
    ok 3
  
  or this if false
  
    ok
    ok
    ok
  
  Most useful when you can't depend on the test output order, such as
  when threads or forking is involved.
  
  Defaults to on.
  
  =item B<no_diag>
  
      $Test->no_diag($no_diag);
  
  If set true no diagnostics will be printed.  This includes calls to
  C<diag()>.
  
  =item B<no_ending>
  
      $Test->no_ending($no_ending);
  
  Normally, Test::Builder does some extra diagnostics when the test
  ends.  It also changes the exit code as described below.
  
  If this is true, none of that will be done.
  
  =item B<no_header>
  
      $Test->no_header($no_header);
  
  If set to true, no "1..N" header will be printed.
  
  =back
  
  =head2 Output
  
  Controlling where the test output goes.
  
  It's ok for your test to change where STDOUT and STDERR point to,
  Test::Builder's default output settings will not be affected.
  
  =over 4
  
  =item B<diag>
  
      $Test->diag(@msgs);
  
  Prints out the given C<@msgs>.  Like C<print>, arguments are simply
  appended together.
  
  Normally, it uses the C<failure_output()> handle, but if this is for a
  TODO test, the C<todo_output()> handle is used.
  
  Output will be indented and marked with a # so as not to interfere
  with test output.  A newline will be put on the end if there isn't one
  already.
  
  We encourage using this rather than calling print directly.
  
  Returns false.  Why?  Because C<diag()> is often used in conjunction with
  a failing test (C<ok() || diag()>) it "passes through" the failure.
  
      return ok(...) || diag(...);
  
  =for blame transfer
  Mark Fowler <mark@twoshortplanks.com>
  
  =item B<note>
  
      $Test->note(@msgs);
  
  Like C<diag()>, but it prints to the C<output()> handle so it will not
  normally be seen by the user except in verbose mode.
  
  =item B<explain>
  
      my @dump = $Test->explain(@msgs);
  
  Will dump the contents of any references in a human readable format.
  Handy for things like...
  
      is_deeply($have, $want) || diag explain $have;
  
  or
  
      is_deeply($have, $want) || note explain $have;
  
  =item B<output>
  
  =item B<failure_output>
  
  =item B<todo_output>
  
      my $filehandle = $Test->output;
      $Test->output($filehandle);
      $Test->output($filename);
      $Test->output(\$scalar);
  
  These methods control where Test::Builder will print its output.
  They take either an open C<$filehandle>, a C<$filename> to open and write to
  or a C<$scalar> reference to append to.  It will always return a C<$filehandle>.
  
  B<output> is where normal "ok/not ok" test output goes.
  
  Defaults to STDOUT.
  
  B<failure_output> is where diagnostic output on test failures and
  C<diag()> goes.  It is normally not read by Test::Harness and instead is
  displayed to the user.
  
  Defaults to STDERR.
  
  C<todo_output> is used instead of C<failure_output()> for the
  diagnostics of a failing TODO test.  These will not be seen by the
  user.
  
  Defaults to STDOUT.
  
  =item reset_outputs
  
    $tb->reset_outputs;
  
  Resets all the output filehandles back to their defaults.
  
  =item carp
  
    $tb->carp(@message);
  
  Warns with C<@message> but the message will appear to come from the
  point where the original test function was called (C<< $tb->caller >>).
  
  =item croak
  
    $tb->croak(@message);
  
  Dies with C<@message> but the message will appear to come from the
  point where the original test function was called (C<< $tb->caller >>).
  
  
  =back
  
  
  =head2 Test Status and Info
  
  =over 4
  
  =item B<no_log_results>
  
  This will turn off result long-term storage. Calling this method will make
  C<details> and C<summary> useless. You may want to use this if you are running
  enough tests to fill up all available memory.
  
      Test::Builder->new->no_log_results();
  
  There is no way to turn it back on.
  
  =item B<current_test>
  
      my $curr_test = $Test->current_test;
      $Test->current_test($num);
  
  Gets/sets the current test number we're on.  You usually shouldn't
  have to set this.
  
  If set forward, the details of the missing tests are filled in as 'unknown'.
  if set backward, the details of the intervening tests are deleted.  You
  can erase history if you really want to.
  
  
  =item B<is_passing>
  
     my $ok = $builder->is_passing;
  
  Indicates if the test suite is currently passing.
  
  More formally, it will be false if anything has happened which makes
  it impossible for the test suite to pass.  True otherwise.
  
  For example, if no tests have run C<is_passing()> will be true because
  even though a suite with no tests is a failure you can add a passing
  test to it and start passing.
  
  Don't think about it too much.
  
  
  =item B<summary>
  
      my @tests = $Test->summary;
  
  A simple summary of the tests so far.  True for pass, false for fail.
  This is a logical pass/fail, so todos are passes.
  
  Of course, test #1 is $tests[0], etc...
  
  
  =item B<details>
  
      my @tests = $Test->details;
  
  Like C<summary()>, but with a lot more detail.
  
      $tests[$test_num - 1] =
              { 'ok'       => is the test considered a pass?
                actual_ok  => did it literally say 'ok'?
                name       => name of the test (if any)
                type       => type of test (if any, see below).
                reason     => reason for the above (if any)
              };
  
  'ok' is true if Test::Harness will consider the test to be a pass.
  
  'actual_ok' is a reflection of whether or not the test literally
  printed 'ok' or 'not ok'.  This is for examining the result of 'todo'
  tests.
  
  'name' is the name of the test.
  
  'type' indicates if it was a special test.  Normal tests have a type
  of ''.  Type can be one of the following:
  
      skip        see skip()
      todo        see todo()
      todo_skip   see todo_skip()
      unknown     see below
  
  Sometimes the Test::Builder test counter is incremented without it
  printing any test output, for example, when C<current_test()> is changed.
  In these cases, Test::Builder doesn't know the result of the test, so
  its type is 'unknown'.  These details for these tests are filled in.
  They are considered ok, but the name and actual_ok is left C<undef>.
  
  For example "not ok 23 - hole count # TODO insufficient donuts" would
  result in this structure:
  
      $tests[22] =    # 23 - 1, since arrays start from 0.
        { ok        => 1,   # logically, the test passed since its todo
          actual_ok => 0,   # in absolute terms, it failed
          name      => 'hole count',
          type      => 'todo',
          reason    => 'insufficient donuts'
        };
  
  
  =item B<todo>
  
      my $todo_reason = $Test->todo;
      my $todo_reason = $Test->todo($pack);
  
  If the current tests are considered "TODO" it will return the reason,
  if any.  This reason can come from a C<$TODO> variable or the last call
  to C<todo_start()>.
  
  Since a TODO test does not need a reason, this function can return an
  empty string even when inside a TODO block.  Use C<< $Test->in_todo >>
  to determine if you are currently inside a TODO block.
  
  C<todo()> is about finding the right package to look for C<$TODO> in.  It's
  pretty good at guessing the right package to look at.  It first looks for
  the caller based on C<$Level + 1>, since C<todo()> is usually called inside
  a test function.  As a last resort it will use C<exported_to()>.
  
  Sometimes there is some confusion about where C<todo()> should be looking
  for the C<$TODO> variable.  If you want to be sure, tell it explicitly
  what $pack to use.
  
  =item B<find_TODO>
  
      my $todo_reason = $Test->find_TODO();
      my $todo_reason = $Test->find_TODO($pack);
  
  Like C<todo()> but only returns the value of C<$TODO> ignoring
  C<todo_start()>.
  
  Can also be used to set C<$TODO> to a new value while returning the
  old value:
  
      my $old_reason = $Test->find_TODO($pack, 1, $new_reason);
  
  =item B<in_todo>
  
      my $in_todo = $Test->in_todo;
  
  Returns true if the test is currently inside a TODO block.
  
  =item B<todo_start>
  
      $Test->todo_start();
      $Test->todo_start($message);
  
  This method allows you declare all subsequent tests as TODO tests, up until
  the C<todo_end> method has been called.
  
  The C<TODO:> and C<$TODO> syntax is generally pretty good about figuring out
  whether or not we're in a TODO test.  However, often we find that this is not
  possible to determine (such as when we want to use C<$TODO> but
  the tests are being executed in other packages which can't be inferred
  beforehand).
  
  Note that you can use this to nest "todo" tests
  
   $Test->todo_start('working on this');
   # lots of code
   $Test->todo_start('working on that');
   # more code
   $Test->todo_end;
   $Test->todo_end;
  
  This is generally not recommended, but large testing systems often have weird
  internal needs.
  
  We've tried to make this also work with the TODO: syntax, but it's not
  guaranteed and its use is also discouraged:
  
   TODO: {
       local $TODO = 'We have work to do!';
       $Test->todo_start('working on this');
       # lots of code
       $Test->todo_start('working on that');
       # more code
       $Test->todo_end;
       $Test->todo_end;
   }
  
  Pick one style or another of "TODO" to be on the safe side.
  
  
  =item C<todo_end>
  
   $Test->todo_end;
  
  Stops running tests as "TODO" tests.  This method is fatal if called without a
  preceding C<todo_start> method call.
  
  =item B<caller>
  
      my $package = $Test->caller;
      my($pack, $file, $line) = $Test->caller;
      my($pack, $file, $line) = $Test->caller($height);
  
  Like the normal C<caller()>, except it reports according to your C<level()>.
  
  C<$height> will be added to the C<level()>.
  
  If C<caller()> winds up off the top of the stack it report the highest context.
  
  =back
  
  =head1 EXIT CODES
  
  If all your tests passed, Test::Builder will exit with zero (which is
  normal).  If anything failed it will exit with how many failed.  If
  you run less (or more) tests than you planned, the missing (or extras)
  will be considered failures.  If no tests were ever run Test::Builder
  will throw a warning and exit with 255.  If the test died, even after
  having successfully completed all its tests, it will still be
  considered a failure and will exit with 255.
  
  So the exit codes are...
  
      0                   all tests successful
      255                 test died or all passed but wrong # of tests run
      any other number    how many failed (including missing or extras)
  
  If you fail more than 254 tests, it will be reported as 254.
  
  =head1 THREADS
  
  In perl 5.8.1 and later, Test::Builder is thread-safe.  The test number is
  shared by all threads.  This means if one thread sets the test number using
  C<current_test()> they will all be effected.
  
  While versions earlier than 5.8.1 had threads they contain too many
  bugs to support.
  
  Test::Builder is only thread-aware if threads.pm is loaded I<before>
  Test::Builder.
  
  =head1 MEMORY
  
  An informative hash, accessible via C<details()>, is stored for each
  test you perform.  So memory usage will scale linearly with each test
  run. Although this is not a problem for most test suites, it can
  become an issue if you do large (hundred thousands to million)
  combinatorics tests in the same run.
  
  In such cases, you are advised to either split the test file into smaller
  ones, or use a reverse approach, doing "normal" (code) compares and
  triggering C<fail()> should anything go unexpected.
  
  Future versions of Test::Builder will have a way to turn history off.
  
  
  =head1 EXAMPLES
  
  CPAN can provide the best examples.  L<Test::Simple>, L<Test::More>,
  L<Test::Exception> and L<Test::Differences> all use Test::Builder.
  
  =head1 SEE ALSO
  
  L<Test::Simple>, L<Test::More>, L<Test::Harness>
  
  =head1 AUTHORS
  
  Original code by chromatic, maintained by Michael G Schwern
  E<lt>schwern@pobox.comE<gt>
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by chromatic E<lt>chromatic@wgz.orgE<gt> and
                         Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
TEST_BUILDER

$fatpacked{"Test/Builder/Formatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_FORMATTER';
  package Test::Builder::Formatter;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  BEGIN { require Test2::Formatter::TAP; our @ISA = qw(Test2::Formatter::TAP) }
  
  use Test2::Util::HashBase qw/no_header no_diag/;
  
  BEGIN {
      *OUT_STD = Test2::Formatter::TAP->can('OUT_STD');
      *OUT_ERR = Test2::Formatter::TAP->can('OUT_ERR');
  
      my $todo = OUT_ERR() + 1;
      *OUT_TODO = sub() { $todo };
  }
  
  sub init {
      my $self = shift;
      $self->SUPER::init(@_);
      $self->{+HANDLES}->[OUT_TODO] = $self->{+HANDLES}->[OUT_STD];
  }
  
  sub plan_tap {
      my ($self, $f) = @_;
  
      return if $self->{+NO_HEADER};
      return $self->SUPER::plan_tap($f);
  }
  
  sub debug_tap {
      my ($self, $f, $num) = @_;
      return if $self->{+NO_DIAG};
      my @out = $self->SUPER::debug_tap($f, $num);
      $self->redirect(\@out) if @out && $f->{about}->{package} eq 'Test::Builder::TodoDiag';
      return @out;
  }
  
  sub info_tap {
      my ($self, $f) = @_;
      return if $self->{+NO_DIAG};
      my @out = $self->SUPER::info_tap($f);
      $self->redirect(\@out) if @out && $f->{about}->{package} eq 'Test::Builder::TodoDiag';
      return @out;
  }
  
  sub redirect {
      my ($self, $out) = @_;
      $_->[0] = OUT_TODO for @$out;
  }
  
  sub no_subtest_space { 1 }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::Builder::Formatter - Test::Builder subclass of Test2::Formatter::TAP
  
  =head1 DESCRIPTION
  
  This is what takes events and turns them into TAP.
  
  =head1 SYNOPSIS
  
      use Test::Builder; # Loads Test::Builder::Formatter for you
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST_BUILDER_FORMATTER

$fatpacked{"Test/Builder/IO/Scalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_IO_SCALAR';
  package Test::Builder::IO::Scalar;
  
  
  =head1 NAME
  
  Test::Builder::IO::Scalar - A copy of IO::Scalar for Test::Builder
  
  =head1 DESCRIPTION
  
  This is a copy of L<IO::Scalar> which ships with L<Test::Builder> to
  support scalar references as filehandles on Perl 5.6.  Newer
  versions of Perl simply use C<open()>'s built in support.
  
  L<Test::Builder> can not have dependencies on other modules without
  careful consideration, so its simply been copied into the distribution.
  
  =head1 COPYRIGHT and LICENSE
  
  This file came from the "IO-stringy" Perl5 toolkit.
  
  Copyright (c) 1996 by Eryq.  All rights reserved.
  Copyright (c) 1999,2001 by ZeeGee Software Inc.  All rights reserved.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =cut
  
  # This is copied code, I don't care.
  ##no critic
  
  use Carp;
  use strict;
  use vars qw($VERSION @ISA);
  use IO::Handle;
  
  use 5.005;
  
  ### The package version, both in 1.23 style *and* usable by MakeMaker:
  $VERSION = "2.114";
  
  ### Inheritance:
  @ISA = qw(IO::Handle);
  
  #==============================
  
  =head2 Construction
  
  =over 4
  
  =cut
  
  #------------------------------
  
  =item new [ARGS...]
  
  I<Class method.>
  Return a new, unattached scalar handle.
  If any arguments are given, they're sent to open().
  
  =cut
  
  sub new {
      my $proto = shift;
      my $class = ref($proto) || $proto;
      my $self = bless \do { local *FH }, $class;
      tie *$self, $class, $self;
      $self->open(@_);   ### open on anonymous by default
      $self;
  }
  sub DESTROY {
      shift->close;
  }
  
  #------------------------------
  
  =item open [SCALARREF]
  
  I<Instance method.>
  Open the scalar handle on a new scalar, pointed to by SCALARREF.
  If no SCALARREF is given, a "private" scalar is created to hold
  the file data.
  
  Returns the self object on success, undefined on error.
  
  =cut
  
  sub open {
      my ($self, $sref) = @_;
  
      ### Sanity:
      defined($sref) or do {my $s = ''; $sref = \$s};
      (ref($sref) eq "SCALAR") or croak "open() needs a ref to a scalar";
  
      ### Setup:
      *$self->{Pos} = 0;          ### seek position
      *$self->{SR}  = $sref;      ### scalar reference
      $self;
  }
  
  #------------------------------
  
  =item opened
  
  I<Instance method.>
  Is the scalar handle opened on something?
  
  =cut
  
  sub opened {
      *{shift()}->{SR};
  }
  
  #------------------------------
  
  =item close
  
  I<Instance method.>
  Disassociate the scalar handle from its underlying scalar.
  Done automatically on destroy.
  
  =cut
  
  sub close {
      my $self = shift;
      %{*$self} = ();
      1;
  }
  
  =back
  
  =cut
  
  
  
  #==============================
  
  =head2 Input and output
  
  =over 4
  
  =cut
  
  
  #------------------------------
  
  =item flush
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub flush { "0 but true" }
  
  #------------------------------
  
  =item getc
  
  I<Instance method.>
  Return the next character, or undef if none remain.
  
  =cut
  
  sub getc {
      my $self = shift;
  
      ### Return undef right away if at EOF; else, move pos forward:
      return undef if $self->eof;
      substr(${*$self->{SR}}, *$self->{Pos}++, 1);
  }
  
  #------------------------------
  
  =item getline
  
  I<Instance method.>
  Return the next line, or undef on end of string.
  Can safely be called in an array context.
  Currently, lines are delimited by "\n".
  
  =cut
  
  sub getline {
      my $self = shift;
  
      ### Return undef right away if at EOF:
      return undef if $self->eof;
  
      ### Get next line:
      my $sr = *$self->{SR};
      my $i  = *$self->{Pos};	        ### Start matching at this point.
  
      ### Minimal impact implementation!
      ### We do the fast fast thing (no regexps) if using the
      ### classic input record separator.
  
      ### Case 1: $/ is undef: slurp all...
      if    (!defined($/)) {
  	*$self->{Pos} = length $$sr;
          return substr($$sr, $i);
      }
  
      ### Case 2: $/ is "\n": zoom zoom zoom...
      elsif ($/ eq "\012") {
  
          ### Seek ahead for "\n"... yes, this really is faster than regexps.
          my $len = length($$sr);
          for (; $i < $len; ++$i) {
             last if ord (substr ($$sr, $i, 1)) == 10;
          }
  
          ### Extract the line:
          my $line;
          if ($i < $len) {                ### We found a "\n":
              $line = substr ($$sr, *$self->{Pos}, $i - *$self->{Pos} + 1);
              *$self->{Pos} = $i+1;            ### Remember where we finished up.
          }
          else {                          ### No "\n"; slurp the remainder:
              $line = substr ($$sr, *$self->{Pos}, $i - *$self->{Pos});
              *$self->{Pos} = $len;
          }
          return $line;
      }
  
      ### Case 3: $/ is ref to int. Do fixed-size records.
      ###        (Thanks to Dominique Quatravaux.)
      elsif (ref($/)) {
          my $len = length($$sr);
  		my $i = ${$/} + 0;
  		my $line = substr ($$sr, *$self->{Pos}, $i);
  		*$self->{Pos} += $i;
          *$self->{Pos} = $len if (*$self->{Pos} > $len);
  		return $line;
      }
  
      ### Case 4: $/ is either "" (paragraphs) or something weird...
      ###         This is Graham's general-purpose stuff, which might be
      ###         a tad slower than Case 2 for typical data, because
      ###         of the regexps.
      else {
          pos($$sr) = $i;
  
  	### If in paragraph mode, skip leading lines (and update i!):
          length($/) or
  	    (($$sr =~ m/\G\n*/g) and ($i = pos($$sr)));
  
          ### If we see the separator in the buffer ahead...
          if (length($/)
  	    ?  $$sr =~ m,\Q$/\E,g          ###   (ordinary sep) TBD: precomp!
              :  $$sr =~ m,\n\n,g            ###   (a paragraph)
              ) {
              *$self->{Pos} = pos $$sr;
              return substr($$sr, $i, *$self->{Pos}-$i);
          }
          ### Else if no separator remains, just slurp the rest:
          else {
              *$self->{Pos} = length $$sr;
              return substr($$sr, $i);
          }
      }
  }
  
  #------------------------------
  
  =item getlines
  
  I<Instance method.>
  Get all remaining lines.
  It will croak() if accidentally called in a scalar context.
  
  =cut
  
  sub getlines {
      my $self = shift;
      wantarray or croak("can't call getlines in scalar context!");
      my ($line, @lines);
      push @lines, $line while (defined($line = $self->getline));
      @lines;
  }
  
  #------------------------------
  
  =item print ARGS...
  
  I<Instance method.>
  Print ARGS to the underlying scalar.
  
  B<Warning:> this continues to always cause a seek to the end
  of the string, but if you perform seek()s and tell()s, it is
  still safer to explicitly seek-to-end before subsequent print()s.
  
  =cut
  
  sub print {
      my $self = shift;
      *$self->{Pos} = length(${*$self->{SR}} .= join('', @_) . (defined($\) ? $\ : ""));
      1;
  }
  sub _unsafe_print {
      my $self = shift;
      my $append = join('', @_) . $\;
      ${*$self->{SR}} .= $append;
      *$self->{Pos}   += length($append);
      1;
  }
  sub _old_print {
      my $self = shift;
      ${*$self->{SR}} .= join('', @_) . $\;
      *$self->{Pos} = length(${*$self->{SR}});
      1;
  }
  
  
  #------------------------------
  
  =item read BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Read some bytes from the scalar.
  Returns the number of bytes actually read, 0 on end-of-file, undef on error.
  
  =cut
  
  sub read {
      my $self = $_[0];
      my $n    = $_[2];
      my $off  = $_[3] || 0;
  
      my $read = substr(${*$self->{SR}}, *$self->{Pos}, $n);
      $n = length($read);
      *$self->{Pos} += $n;
      ($off ? substr($_[1], $off) : $_[1]) = $read;
      return $n;
  }
  
  #------------------------------
  
  =item write BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Write some bytes to the scalar.
  
  =cut
  
  sub write {
      my $self = $_[0];
      my $n    = $_[2];
      my $off  = $_[3] || 0;
  
      my $data = substr($_[1], $off, $n);
      $n = length($data);
      $self->print($data);
      return $n;
  }
  
  #------------------------------
  
  =item sysread BUF, LEN, [OFFSET]
  
  I<Instance method.>
  Read some bytes from the scalar.
  Returns the number of bytes actually read, 0 on end-of-file, undef on error.
  
  =cut
  
  sub sysread {
    my $self = shift;
    $self->read(@_);
  }
  
  #------------------------------
  
  =item syswrite BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Write some bytes to the scalar.
  
  =cut
  
  sub syswrite {
    my $self = shift;
    $self->write(@_);
  }
  
  =back
  
  =cut
  
  
  #==============================
  
  =head2 Seeking/telling and other attributes
  
  =over 4
  
  =cut
  
  
  #------------------------------
  
  =item autoflush
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub autoflush {}
  
  #------------------------------
  
  =item binmode
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub binmode {}
  
  #------------------------------
  
  =item clearerr
  
  I<Instance method.>  Clear the error and EOF flags.  A no-op.
  
  =cut
  
  sub clearerr { 1 }
  
  #------------------------------
  
  =item eof
  
  I<Instance method.>  Are we at end of file?
  
  =cut
  
  sub eof {
      my $self = shift;
      (*$self->{Pos} >= length(${*$self->{SR}}));
  }
  
  #------------------------------
  
  =item seek OFFSET, WHENCE
  
  I<Instance method.>  Seek to a given position in the stream.
  
  =cut
  
  sub seek {
      my ($self, $pos, $whence) = @_;
      my $eofpos = length(${*$self->{SR}});
  
      ### Seek:
      if    ($whence == 0) { *$self->{Pos} = $pos }             ### SEEK_SET
      elsif ($whence == 1) { *$self->{Pos} += $pos }            ### SEEK_CUR
      elsif ($whence == 2) { *$self->{Pos} = $eofpos + $pos}    ### SEEK_END
      else                 { croak "bad seek whence ($whence)" }
  
      ### Fixup:
      if (*$self->{Pos} < 0)       { *$self->{Pos} = 0 }
      if (*$self->{Pos} > $eofpos) { *$self->{Pos} = $eofpos }
      return 1;
  }
  
  #------------------------------
  
  =item sysseek OFFSET, WHENCE
  
  I<Instance method.> Identical to C<seek OFFSET, WHENCE>, I<q.v.>
  
  =cut
  
  sub sysseek {
      my $self = shift;
      $self->seek (@_);
  }
  
  #------------------------------
  
  =item tell
  
  I<Instance method.>
  Return the current position in the stream, as a numeric offset.
  
  =cut
  
  sub tell { *{shift()}->{Pos} }
  
  #------------------------------
  
  =item  use_RS [YESNO]
  
  I<Instance method.>
  B<Deprecated and ignored.>
  Obey the current setting of $/, like IO::Handle does?
  Default is false in 1.x, but cold-welded true in 2.x and later.
  
  =cut
  
  sub use_RS {
      my ($self, $yesno) = @_;
      carp "use_RS is deprecated and ignored; \$/ is always consulted\n";
   }
  
  #------------------------------
  
  =item setpos POS
  
  I<Instance method.>
  Set the current position, using the opaque value returned by C<getpos()>.
  
  =cut
  
  sub setpos { shift->seek($_[0],0) }
  
  #------------------------------
  
  =item getpos
  
  I<Instance method.>
  Return the current position in the string, as an opaque object.
  
  =cut
  
  *getpos = \&tell;
  
  
  #------------------------------
  
  =item sref
  
  I<Instance method.>
  Return a reference to the underlying scalar.
  
  =cut
  
  sub sref { *{shift()}->{SR} }
  
  
  #------------------------------
  # Tied handle methods...
  #------------------------------
  
  # Conventional tiehandle interface:
  sub TIEHANDLE {
      ((defined($_[1]) && UNIVERSAL::isa($_[1], __PACKAGE__))
       ? $_[1]
       : shift->new(@_));
  }
  sub GETC      { shift->getc(@_) }
  sub PRINT     { shift->print(@_) }
  sub PRINTF    { shift->print(sprintf(shift, @_)) }
  sub READ      { shift->read(@_) }
  sub READLINE  { wantarray ? shift->getlines(@_) : shift->getline(@_) }
  sub WRITE     { shift->write(@_); }
  sub CLOSE     { shift->close(@_); }
  sub SEEK      { shift->seek(@_); }
  sub TELL      { shift->tell(@_); }
  sub EOF       { shift->eof(@_); }
  sub FILENO    { -1 }
  
  #------------------------------------------------------------
  
  1;
  
  __END__
  
  
  
  =back
  
  =cut
  
  
  =head1 WARNINGS
  
  Perl's TIEHANDLE spec was incomplete prior to 5.005_57;
  it was missing support for C<seek()>, C<tell()>, and C<eof()>.
  Attempting to use these functions with an IO::Scalar will not work
  prior to 5.005_57. IO::Scalar will not have the relevant methods
  invoked; and even worse, this kind of bug can lie dormant for a while.
  If you turn warnings on (via C<$^W> or C<perl -w>),
  and you see something like this...
  
      attempt to seek on unopened filehandle
  
  ...then you are probably trying to use one of these functions
  on an IO::Scalar with an old Perl.  The remedy is to simply
  use the OO version; e.g.:
  
      $SH->seek(0,0);    ### GOOD: will work on any 5.005
      seek($SH,0,0);     ### WARNING: will only work on 5.005_57 and beyond
  
  
  =head1 VERSION
  
  $Id: Scalar.pm,v 1.6 2005/02/10 21:21:53 dfs Exp $
  
  
  =head1 AUTHORS
  
  =head2 Primary Maintainer
  
  David F. Skoll (F<dfs@roaringpenguin.com>).
  
  =head2 Principal author
  
  Eryq (F<eryq@zeegee.com>).
  President, ZeeGee Software Inc (F<http://www.zeegee.com>).
  
  
  =head2 Other contributors
  
  The full set of contributors always includes the folks mentioned
  in L<IO::Stringy/"CHANGE LOG">.  But just the same, special
  thanks to the following individuals for their invaluable contributions
  (if I've forgotten or misspelled your name, please email me!):
  
  I<Andy Glew,>
  for contributing C<getc()>.
  
  I<Brandon Browning,>
  for suggesting C<opened()>.
  
  I<David Richter,>
  for finding and fixing the bug in C<PRINTF()>.
  
  I<Eric L. Brine,>
  for his offset-using read() and write() implementations.
  
  I<Richard Jones,>
  for his patches to massively improve the performance of C<getline()>
  and add C<sysread> and C<syswrite>.
  
  I<B. K. Oxley (binkley),>
  for stringification and inheritance improvements,
  and sundry good ideas.
  
  I<Doug Wilson,>
  for the IO::Handle inheritance and automatic tie-ing.
  
  
  =head1 SEE ALSO
  
  L<IO::String>, which is quite similar but which was designed
  more-recently and with an IO::Handle-like interface in mind,
  so you could mix OO- and native-filehandle usage without using tied().
  
  I<Note:> as of version 2.x, these classes all work like
  their IO::Handle counterparts, so we have comparable
  functionality to IO::String.
  
  =cut
  
TEST_BUILDER_IO_SCALAR

$fatpacked{"Test/Builder/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_MODULE';
  package Test::Builder::Module;
  
  use strict;
  
  use Test::Builder;
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our $VERSION = '1.302120';
  
  
  =head1 NAME
  
  Test::Builder::Module - Base class for test modules
  
  =head1 SYNOPSIS
  
    # Emulates Test::Simple
    package Your::Module;
  
    my $CLASS = __PACKAGE__;
  
    use parent 'Test::Builder::Module';
    @EXPORT = qw(ok);
  
    sub ok ($;$) {
        my $tb = $CLASS->builder;
        return $tb->ok(@_);
    }
    
    1;
  
  
  =head1 DESCRIPTION
  
  This is a superclass for L<Test::Builder>-based modules.  It provides a
  handful of common functionality and a method of getting at the underlying
  L<Test::Builder> object.
  
  
  =head2 Importing
  
  Test::Builder::Module is a subclass of L<Exporter> which means your
  module is also a subclass of Exporter.  @EXPORT, @EXPORT_OK, etc...
  all act normally.
  
  A few methods are provided to do the C<< use Your::Module tests => 23 >> part
  for you.
  
  =head3 import
  
  Test::Builder::Module provides an C<import()> method which acts in the
  same basic way as L<Test::More>'s, setting the plan and controlling
  exporting of functions and variables.  This allows your module to set
  the plan independent of L<Test::More>.
  
  All arguments passed to C<import()> are passed onto 
  C<< Your::Module->builder->plan() >> with the exception of 
  C<< import =>[qw(things to import)] >>.
  
      use Your::Module import => [qw(this that)], tests => 23;
  
  says to import the functions C<this()> and C<that()> as well as set the plan
  to be 23 tests.
  
  C<import()> also sets the C<exported_to()> attribute of your builder to be
  the caller of the C<import()> function.
  
  Additional behaviors can be added to your C<import()> method by overriding
  C<import_extra()>.
  
  =cut
  
  sub import {
      my($class) = shift;
  
      Test2::API::test2_load() unless Test2::API::test2_in_preload();
  
      # Don't run all this when loading ourself.
      return 1 if $class eq 'Test::Builder::Module';
  
      my $test = $class->builder;
  
      my $caller = caller;
  
      $test->exported_to($caller);
  
      $class->import_extra( \@_ );
      my(@imports) = $class->_strip_imports( \@_ );
  
      $test->plan(@_);
  
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
      $class->Exporter::import(@imports);
  }
  
  sub _strip_imports {
      my $class = shift;
      my $list  = shift;
  
      my @imports = ();
      my @other   = ();
      my $idx     = 0;
      while( $idx <= $#{$list} ) {
          my $item = $list->[$idx];
  
          if( defined $item and $item eq 'import' ) {
              push @imports, @{ $list->[ $idx + 1 ] };
              $idx++;
          }
          else {
              push @other, $item;
          }
  
          $idx++;
      }
  
      @$list = @other;
  
      return @imports;
  }
  
  =head3 import_extra
  
      Your::Module->import_extra(\@import_args);
  
  C<import_extra()> is called by C<import()>.  It provides an opportunity for you
  to add behaviors to your module based on its import list.
  
  Any extra arguments which shouldn't be passed on to C<plan()> should be
  stripped off by this method.
  
  See L<Test::More> for an example of its use.
  
  B<NOTE> This mechanism is I<VERY ALPHA AND LIKELY TO CHANGE> as it
  feels like a bit of an ugly hack in its current form.
  
  =cut
  
  sub import_extra { }
  
  =head2 Builder
  
  Test::Builder::Module provides some methods of getting at the underlying
  Test::Builder object.
  
  =head3 builder
  
    my $builder = Your::Class->builder;
  
  This method returns the L<Test::Builder> object associated with Your::Class.
  It is not a constructor so you can call it as often as you like.
  
  This is the preferred way to get the L<Test::Builder> object.  You should
  I<not> get it via C<< Test::Builder->new >> as was previously
  recommended.
  
  The object returned by C<builder()> may change at runtime so you should
  call C<builder()> inside each function rather than store it in a global.
  
    sub ok {
        my $builder = Your::Class->builder;
  
        return $builder->ok(@_);
    }
  
  
  =cut
  
  sub builder {
      return Test::Builder->new;
  }
  
  1;
TEST_BUILDER_MODULE

$fatpacked{"Test/Builder/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TESTER';
  package Test::Builder::Tester;
  
  use strict;
  our $VERSION = '1.302120';
  
  use Test::Builder;
  use Symbol;
  use Carp;
  
  =head1 NAME
  
  Test::Builder::Tester - test testsuites that have been built with
  Test::Builder
  
  =head1 SYNOPSIS
  
      use Test::Builder::Tester tests => 1;
      use Test::More;
  
      test_out("not ok 1 - foo");
      test_fail(+1);
      fail("foo");
      test_test("fail works");
  
  =head1 DESCRIPTION
  
  A module that helps you test testing modules that are built with
  L<Test::Builder>.
  
  The testing system is designed to be used by performing a three step
  process for each test you wish to test.  This process starts with using
  C<test_out> and C<test_err> in advance to declare what the testsuite you
  are testing will output with L<Test::Builder> to stdout and stderr.
  
  You then can run the test(s) from your test suite that call
  L<Test::Builder>.  At this point the output of L<Test::Builder> is
  safely captured by L<Test::Builder::Tester> rather than being
  interpreted as real test output.
  
  The final stage is to call C<test_test> that will simply compare what you
  predeclared to what L<Test::Builder> actually outputted, and report the
  results back with a "ok" or "not ok" (with debugging) to the normal
  output.
  
  =cut
  
  ####
  # set up testing
  ####
  
  my $t = Test::Builder->new;
  
  ###
  # make us an exporter
  ###
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(test_out test_err test_fail test_diag test_test line_num);
  
  sub import {
      my $class = shift;
      my(@plan) = @_;
  
      my $caller = caller;
  
      $t->exported_to($caller);
      $t->plan(@plan);
  
      my @imports = ();
      foreach my $idx ( 0 .. $#plan ) {
          if( $plan[$idx] eq 'import' ) {
              @imports = @{ $plan[ $idx + 1 ] };
              last;
          }
      }
  
      __PACKAGE__->export_to_level( 1, __PACKAGE__, @imports );
  }
  
  ###
  # set up file handles
  ###
  
  # create some private file handles
  my $output_handle = gensym;
  my $error_handle  = gensym;
  
  # and tie them to this package
  my $out = tie *$output_handle, "Test::Builder::Tester::Tie", "STDOUT";
  my $err = tie *$error_handle,  "Test::Builder::Tester::Tie", "STDERR";
  
  ####
  # exported functions
  ####
  
  # for remembering that we're testing and where we're testing at
  my $testing = 0;
  my $testing_num;
  my $original_is_passing;
  
  # remembering where the file handles were originally connected
  my $original_output_handle;
  my $original_failure_handle;
  my $original_todo_handle;
  my $original_formatter;
  
  my $original_harness_env;
  
  # function that starts testing and redirects the filehandles for now
  sub _start_testing {
      # Hack for things that conditioned on Test-Stream being loaded
      $INC{'Test/Stream.pm'} ||= 'fake' if $INC{'Test/Moose/More.pm'};
      # even if we're running under Test::Harness pretend we're not
      # for now.  This needed so Test::Builder doesn't add extra spaces
      $original_harness_env = $ENV{HARNESS_ACTIVE} || 0;
      $ENV{HARNESS_ACTIVE} = 0;
  
      my $hub = $t->{Hub} || ($t->{Stack} ? $t->{Stack}->top : Test2::API::test2_stack->top);
      $original_formatter = $hub->format;
      unless ($original_formatter && $original_formatter->isa('Test::Builder::Formatter')) {
          my $fmt = Test::Builder::Formatter->new;
          $hub->format($fmt);
      }
  
      # remember what the handles were set to
      $original_output_handle  = $t->output();
      $original_failure_handle = $t->failure_output();
      $original_todo_handle    = $t->todo_output();
  
      # switch out to our own handles
      $t->output($output_handle);
      $t->failure_output($error_handle);
      $t->todo_output($output_handle);
  
      # clear the expected list
      $out->reset();
      $err->reset();
  
      # remember that we're testing
      $testing     = 1;
      $testing_num = $t->current_test;
      $t->current_test(0);
      $original_is_passing  = $t->is_passing;
      $t->is_passing(1);
  
      # look, we shouldn't do the ending stuff
      $t->no_ending(1);
  }
  
  =head2 Functions
  
  These are the six methods that are exported as default.
  
  =over 4
  
  =item test_out
  
  =item test_err
  
  Procedures for predeclaring the output that your test suite is
  expected to produce until C<test_test> is called.  These procedures
  automatically assume that each line terminates with "\n".  So
  
     test_out("ok 1","ok 2");
  
  is the same as
  
     test_out("ok 1\nok 2");
  
  which is even the same as
  
     test_out("ok 1");
     test_out("ok 2");
  
  Once C<test_out> or C<test_err> (or C<test_fail> or C<test_diag>) have
  been called, all further output from L<Test::Builder> will be
  captured by L<Test::Builder::Tester>.  This means that you will not
  be able perform further tests to the normal output in the normal way
  until you call C<test_test> (well, unless you manually meddle with the
  output filehandles)
  
  =cut
  
  sub test_out {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      $out->expect(@_);
  }
  
  sub test_err {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      $err->expect(@_);
  }
  
  =item test_fail
  
  Because the standard failure message that L<Test::Builder> produces
  whenever a test fails will be a common occurrence in your test error
  output, and because it has changed between Test::Builder versions, rather
  than forcing you to call C<test_err> with the string all the time like
  so
  
      test_err("# Failed test ($0 at line ".line_num(+1).")");
  
  C<test_fail> exists as a convenience function that can be called
  instead.  It takes one argument, the offset from the current line that
  the line that causes the fail is on.
  
      test_fail(+1);
  
  This means that the example in the synopsis could be rewritten
  more simply as:
  
     test_out("not ok 1 - foo");
     test_fail(+1);
     fail("foo");
     test_test("fail works");
  
  =cut
  
  sub test_fail {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      # work out what line we should be on
      my( $package, $filename, $line ) = caller;
      $line = $line + ( shift() || 0 );    # prevent warnings
  
      # expect that on stderr
      $err->expect("#     Failed test ($filename at line $line)");
  }
  
  =item test_diag
  
  As most of the remaining expected output to the error stream will be
  created by L<Test::Builder>'s C<diag> function, L<Test::Builder::Tester>
  provides a convenience function C<test_diag> that you can use instead of
  C<test_err>.
  
  The C<test_diag> function prepends comment hashes and spacing to the
  start and newlines to the end of the expected output passed to it and
  adds it to the list of expected error output.  So, instead of writing
  
     test_err("# Couldn't open file");
  
  you can write
  
     test_diag("Couldn't open file");
  
  Remember that L<Test::Builder>'s diag function will not add newlines to
  the end of output and test_diag will. So to check
  
     Test::Builder->new->diag("foo\n","bar\n");
  
  You would do
  
    test_diag("foo","bar")
  
  without the newlines.
  
  =cut
  
  sub test_diag {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      # expect the same thing, but prepended with "#     "
      local $_;
      $err->expect( map { "# $_" } @_ );
  }
  
  =item test_test
  
  Actually performs the output check testing the tests, comparing the
  data (with C<eq>) that we have captured from L<Test::Builder> against
  what was declared with C<test_out> and C<test_err>.
  
  This takes name/value pairs that effect how the test is run.
  
  =over
  
  =item title (synonym 'name', 'label')
  
  The name of the test that will be displayed after the C<ok> or C<not
  ok>.
  
  =item skip_out
  
  Setting this to a true value will cause the test to ignore if the
  output sent by the test to the output stream does not match that
  declared with C<test_out>.
  
  =item skip_err
  
  Setting this to a true value will cause the test to ignore if the
  output sent by the test to the error stream does not match that
  declared with C<test_err>.
  
  =back
  
  As a convenience, if only one argument is passed then this argument
  is assumed to be the name of the test (as in the above examples.)
  
  Once C<test_test> has been run test output will be redirected back to
  the original filehandles that L<Test::Builder> was connected to
  (probably STDOUT and STDERR,) meaning any further tests you run
  will function normally and cause success/errors for L<Test::Harness>.
  
  =cut
  
  sub test_test {
      # END the hack
      delete $INC{'Test/Stream.pm'} if $INC{'Test/Stream.pm'} && $INC{'Test/Stream.pm'} eq 'fake';
      # decode the arguments as described in the pod
      my $mess;
      my %args;
      if( @_ == 1 ) {
          $mess = shift
      }
      else {
          %args = @_;
          $mess = $args{name} if exists( $args{name} );
          $mess = $args{title} if exists( $args{title} );
          $mess = $args{label} if exists( $args{label} );
      }
  
      # er, are we testing?
      croak "Not testing.  You must declare output with a test function first."
        unless $testing;
  
  
      my $hub = $t->{Hub} || Test2::API::test2_stack->top;
      $hub->format($original_formatter);
  
      # okay, reconnect the test suite back to the saved handles
      $t->output($original_output_handle);
      $t->failure_output($original_failure_handle);
      $t->todo_output($original_todo_handle);
  
      # restore the test no, etc, back to the original point
      $t->current_test($testing_num);
      $testing = 0;
      $t->is_passing($original_is_passing);
  
      # re-enable the original setting of the harness
      $ENV{HARNESS_ACTIVE} = $original_harness_env;
  
      # check the output we've stashed
      unless( $t->ok( ( $args{skip_out} || $out->check ) &&
                      ( $args{skip_err} || $err->check ), $mess ) 
      )
      {
          # print out the diagnostic information about why this
          # test failed
  
          local $_;
  
          $t->diag( map { "$_\n" } $out->complaint )
            unless $args{skip_out} || $out->check;
  
          $t->diag( map { "$_\n" } $err->complaint )
            unless $args{skip_err} || $err->check;
      }
  }
  
  =item line_num
  
  A utility function that returns the line number that the function was
  called on.  You can pass it an offset which will be added to the
  result.  This is very useful for working out the correct text of
  diagnostic functions that contain line numbers.
  
  Essentially this is the same as the C<__LINE__> macro, but the
  C<line_num(+3)> idiom is arguably nicer.
  
  =cut
  
  sub line_num {
      my( $package, $filename, $line ) = caller;
      return $line + ( shift() || 0 );    # prevent warnings
  }
  
  =back
  
  In addition to the six exported functions there exists one
  function that can only be accessed with a fully qualified function
  call.
  
  =over 4
  
  =item color
  
  When C<test_test> is called and the output that your tests generate
  does not match that which you declared, C<test_test> will print out
  debug information showing the two conflicting versions.  As this
  output itself is debug information it can be confusing which part of
  the output is from C<test_test> and which was the original output from
  your original tests.  Also, it may be hard to spot things like
  extraneous whitespace at the end of lines that may cause your test to
  fail even though the output looks similar.
  
  To assist you C<test_test> can colour the background of the debug
  information to disambiguate the different types of output. The debug
  output will have its background coloured green and red.  The green
  part represents the text which is the same between the executed and
  actual output, the red shows which part differs.
  
  The C<color> function determines if colouring should occur or not.
  Passing it a true or false value will enable or disable colouring
  respectively, and the function called with no argument will return the
  current setting.
  
  To enable colouring from the command line, you can use the
  L<Text::Builder::Tester::Color> module like so:
  
     perl -Mlib=Text::Builder::Tester::Color test.t
  
  Or by including the L<Test::Builder::Tester::Color> module directly in
  the PERL5LIB.
  
  =cut
  
  my $color;
  
  sub color {
      $color = shift if @_;
      $color;
  }
  
  =back
  
  =head1 BUGS
  
  Test::Builder::Tester does not handle plans well. It has never done anything
  special with plans. This means that plans from outside Test::Builder::Tester
  will effect Test::Builder::Tester, worse plans when using Test::Builder::Tester
  will effect overall testing. At this point there are no plans to fix this bug
  as people have come to depend on it, and Test::Builder::Tester is now
  discouraged in favor of C<Test2::API::intercept()>. See
  L<https://github.com/Test-More/test-more/issues/667>
  
  Calls C<< Test::Builder->no_ending >> turning off the ending tests.
  This is needed as otherwise it will trip out because we've run more
  tests than we strictly should have and it'll register any failures we
  had that we were testing for as real failures.
  
  The color function doesn't work unless L<Term::ANSIColor> is
  compatible with your terminal. Additionally, L<Win32::Console::ANSI>
  must be installed on windows platforms for color output.
  
  Bugs (and requests for new features) can be reported to the author
  though GitHub:
  L<https://github.com/Test-More/test-more/issues>
  
  =head1 AUTHOR
  
  Copyright Mark Fowler E<lt>mark@twoshortplanks.comE<gt> 2002, 2004.
  
  Some code taken from L<Test::More> and L<Test::Catch>, written by
  Michael G Schwern E<lt>schwern@pobox.comE<gt>.  Hence, those parts
  Copyright Micheal G Schwern 2001.  Used and distributed with
  permission.
  
  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 NOTES
  
  Thanks to Richard Clamp E<lt>richardc@unixbeard.netE<gt> for letting
  me use his testing system to try this module out on.
  
  =head1 SEE ALSO
  
  L<Test::Builder>, L<Test::Builder::Tester::Color>, L<Test::More>.
  
  =cut
  
  1;
  
  ####################################################################
  # Helper class that is used to remember expected and received data
  
  package Test::Builder::Tester::Tie;
  
  ##
  # add line(s) to be expected
  
  sub expect {
      my $self = shift;
  
      my @checks = @_;
      foreach my $check (@checks) {
          $check = $self->_account_for_subtest($check);
          $check = $self->_translate_Failed_check($check);
          push @{ $self->{wanted} }, ref $check ? $check : "$check\n";
      }
  }
  
  sub _account_for_subtest {
      my( $self, $check ) = @_;
  
      my $hub = $t->{Stack}->top;
      my $nesting = $hub->isa('Test2::Hub::Subtest') ? $hub->nested : 0;
      return ref($check) ? $check : ('    ' x $nesting) . $check;
  }
  
  sub _translate_Failed_check {
      my( $self, $check ) = @_;
  
      if( $check =~ /\A(.*)#     (Failed .*test) \((.*?) at line (\d+)\)\Z(?!\n)/ ) {
          $check = "/\Q$1\E#\\s+\Q$2\E.*?\\n?.*?\Qat $3\E line \Q$4\E.*\\n?/";
      }
  
      return $check;
  }
  
  ##
  # return true iff the expected data matches the got data
  
  sub check {
      my $self = shift;
  
      # turn off warnings as these might be undef
      local $^W = 0;
  
      my @checks = @{ $self->{wanted} };
      my $got    = $self->{got};
      foreach my $check (@checks) {
          $check = "\Q$check\E" unless( $check =~ s,^/(.*)/$,$1, or ref $check );
          return 0 unless $got =~ s/^$check//;
      }
  
      return length $got == 0;
  }
  
  ##
  # a complaint message about the inputs not matching (to be
  # used for debugging messages)
  
  sub complaint {
      my $self   = shift;
      my $type   = $self->type;
      my $got    = $self->got;
      my $wanted = join '', @{ $self->wanted };
  
      # are we running in colour mode?
      if(Test::Builder::Tester::color) {
          # get color
          eval { require Term::ANSIColor };
          unless($@) {
              eval { require Win32::Console::ANSI } if 'MSWin32' eq $^O;  # support color on windows platforms
  
              # colours
  
              my $green = Term::ANSIColor::color("black") . Term::ANSIColor::color("on_green");
              my $red   = Term::ANSIColor::color("black") . Term::ANSIColor::color("on_red");
              my $reset = Term::ANSIColor::color("reset");
  
              # work out where the two strings start to differ
              my $char = 0;
              $char++ while substr( $got, $char, 1 ) eq substr( $wanted, $char, 1 );
  
              # get the start string and the two end strings
              my $start = $green . substr( $wanted, 0, $char );
              my $gotend    = $red . substr( $got,    $char ) . $reset;
              my $wantedend = $red . substr( $wanted, $char ) . $reset;
  
              # make the start turn green on and off
              $start =~ s/\n/$reset\n$green/g;
  
              # make the ends turn red on and off
              $gotend    =~ s/\n/$reset\n$red/g;
              $wantedend =~ s/\n/$reset\n$red/g;
  
              # rebuild the strings
              $got    = $start . $gotend;
              $wanted = $start . $wantedend;
          }
      }
  
      my @got = split "\n", $got;
      my @wanted = split "\n", $wanted;
  
      $got = "";
      $wanted = "";
  
      while (@got || @wanted) {
          my $g = shift @got    || "";
          my $w = shift @wanted || "";
          if ($g ne $w) {
              if($g =~ s/(\s+)$/    |> /g) {
                  $g .= ($_ eq ' ' ? '_' : '\t') for split '', $1;
              }
              if($w =~ s/(\s+)$/    |> /g) {
                  $w .= ($_ eq ' ' ? '_' : '\t') for split '', $1;
              }
              $g = "> $g";
              $w = "> $w";
          }
          else {
              $g = "  $g";
              $w = "  $w";
          }
          $got = $got ? "$got\n$g" : $g;
          $wanted = $wanted ? "$wanted\n$w" : $w;
      }
  
      return "$type is:\n" . "$got\nnot:\n$wanted\nas expected";
  }
  
  ##
  # forget all expected and got data
  
  sub reset {
      my $self = shift;
      %$self = (
          type   => $self->{type},
          got    => '',
          wanted => [],
      );
  }
  
  sub got {
      my $self = shift;
      return $self->{got};
  }
  
  sub wanted {
      my $self = shift;
      return $self->{wanted};
  }
  
  sub type {
      my $self = shift;
      return $self->{type};
  }
  
  ###
  # tie interface
  ###
  
  sub PRINT {
      my $self = shift;
      $self->{got} .= join '', @_;
  }
  
  sub TIEHANDLE {
      my( $class, $type ) = @_;
  
      my $self = bless { type => $type }, $class;
  
      $self->reset;
  
      return $self;
  }
  
  sub READ     { }
  sub READLINE { }
  sub GETC     { }
  sub FILENO   { }
  
  1;
TEST_BUILDER_TESTER

$fatpacked{"Test/Builder/Tester/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TESTER_COLOR';
  package Test::Builder::Tester::Color;
  
  use strict;
  our $VERSION = '1.302120';
  
  require Test::Builder::Tester;
  
  
  =head1 NAME
  
  Test::Builder::Tester::Color - turn on colour in Test::Builder::Tester
  
  =head1 SYNOPSIS
  
     When running a test script
  
       perl -MTest::Builder::Tester::Color test.t
  
  =head1 DESCRIPTION
  
  Importing this module causes the subroutine color in Test::Builder::Tester
  to be called with a true value causing colour highlighting to be turned
  on in debug output.
  
  The sole purpose of this module is to enable colour highlighting
  from the command line.
  
  =cut
  
  sub import {
      Test::Builder::Tester::color(1);
  }
  
  =head1 AUTHOR
  
  Copyright Mark Fowler E<lt>mark@twoshortplanks.comE<gt> 2002.
  
  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =head1 BUGS
  
  This module will have no effect unless Term::ANSIColor is installed.
  
  =head1 SEE ALSO
  
  L<Test::Builder::Tester>, L<Term::ANSIColor>
  
  =cut
  
  1;
TEST_BUILDER_TESTER_COLOR

$fatpacked{"Test/Builder/TodoDiag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TODODIAG';
  package Test::Builder::TodoDiag;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  BEGIN { require Test2::Event::Diag; our @ISA = qw(Test2::Event::Diag) }
  
  sub diagnostics { 0 }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->SUPER::facet_data();
      $out->{info}->[0]->{debug} = 0;
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::Builder::TodoDiag - Test::Builder subclass of Test2::Event::Diag
  
  =head1 DESCRIPTION
  
  This is used to encapsulate diag messages created inside TODO.
  
  =head1 SYNOPSIS
  
  You do not need to use this directly.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST_BUILDER_TODODIAG

$fatpacked{"Test/More.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MORE';
  package Test::More;
  
  use 5.006;
  use strict;
  use warnings;
  
  #---- perlcritic exemptions. ----#
  
  # We use a lot of subroutine prototypes
  ## no critic (Subroutines::ProhibitSubroutinePrototypes)
  
  # Can't use Carp because it might cause C<use_ok()> to accidentally succeed
  # even though the module being used forgot to use Carp.  Yes, this
  # actually happened.
  sub _carp {
      my( $file, $line ) = ( caller(1) )[ 1, 2 ];
      return warn @_, " at $file line $line\n";
  }
  
  our $VERSION = '1.302120';
  
  use Test::Builder::Module;
  our @ISA    = qw(Test::Builder::Module);
  our @EXPORT = qw(ok use_ok require_ok
    is isnt like unlike is_deeply
    cmp_ok
    skip todo todo_skip
    pass fail
    eq_array eq_hash eq_set
    $TODO
    plan
    done_testing
    can_ok isa_ok new_ok
    diag note explain
    subtest
    BAIL_OUT
  );
  
  =head1 NAME
  
  Test::More - yet another framework for writing test scripts
  
  =head1 SYNOPSIS
  
    use Test::More tests => 23;
    # or
    use Test::More skip_all => $reason;
    # or
    use Test::More;   # see done_testing()
  
    require_ok( 'Some::Module' );
  
    # Various ways to say "ok"
    ok($got eq $expected, $test_name);
  
    is  ($got, $expected, $test_name);
    isnt($got, $expected, $test_name);
  
    # Rather than print STDERR "# here's what went wrong\n"
    diag("here's what went wrong");
  
    like  ($got, qr/expected/, $test_name);
    unlike($got, qr/expected/, $test_name);
  
    cmp_ok($got, '==', $expected, $test_name);
  
    is_deeply($got_complex_structure, $expected_complex_structure, $test_name);
  
    SKIP: {
        skip $why, $how_many unless $have_some_feature;
  
        ok( foo(),       $test_name );
        is( foo(42), 23, $test_name );
    };
  
    TODO: {
        local $TODO = $why;
  
        ok( foo(),       $test_name );
        is( foo(42), 23, $test_name );
    };
  
    can_ok($module, @methods);
    isa_ok($object, $class);
  
    pass($test_name);
    fail($test_name);
  
    BAIL_OUT($why);
  
    # UNIMPLEMENTED!!!
    my @status = Test::More::status;
  
  
  =head1 DESCRIPTION
  
  B<STOP!> If you're just getting started writing tests, have a look at
  L<Test::Simple> first.  This is a drop in replacement for Test::Simple
  which you can switch to once you get the hang of basic testing.
  
  The purpose of this module is to provide a wide range of testing
  utilities.  Various ways to say "ok" with better diagnostics,
  facilities to skip tests, test future features and compare complicated
  data structures.  While you can do almost anything with a simple
  C<ok()> function, it doesn't provide good diagnostic output.
  
  
  =head2 I love it when a plan comes together
  
  Before anything else, you need a testing plan.  This basically declares
  how many tests your script is going to run to protect against premature
  failure.
  
  The preferred way to do this is to declare a plan when you C<use Test::More>.
  
    use Test::More tests => 23;
  
  There are cases when you will not know beforehand how many tests your
  script is going to run.  In this case, you can declare your tests at
  the end.
  
    use Test::More;
  
    ... run your tests ...
  
    done_testing( $number_of_tests_run );
  
  B<NOTE> C<done_testing()> should never be called in an C<END { ... }> block.
  
  Sometimes you really don't know how many tests were run, or it's too
  difficult to calculate.  In which case you can leave off
  $number_of_tests_run.
  
  In some cases, you'll want to completely skip an entire testing script.
  
    use Test::More skip_all => $skip_reason;
  
  Your script will declare a skip with the reason why you skipped and
  exit immediately with a zero (success).  See L<Test::Harness> for
  details.
  
  If you want to control what functions Test::More will export, you
  have to use the 'import' option.  For example, to import everything
  but 'fail', you'd do:
  
    use Test::More tests => 23, import => ['!fail'];
  
  Alternatively, you can use the C<plan()> function.  Useful for when you
  have to calculate the number of tests.
  
    use Test::More;
    plan tests => keys %Stuff * 3;
  
  or for deciding between running the tests at all:
  
    use Test::More;
    if( $^O eq 'MacOS' ) {
        plan skip_all => 'Test irrelevant on MacOS';
    }
    else {
        plan tests => 42;
    }
  
  =cut
  
  sub plan {
      my $tb = Test::More->builder;
  
      return $tb->plan(@_);
  }
  
  # This implements "use Test::More 'no_diag'" but the behavior is
  # deprecated.
  sub import_extra {
      my $class = shift;
      my $list  = shift;
  
      my @other = ();
      my $idx   = 0;
      my $import;
      while( $idx <= $#{$list} ) {
          my $item = $list->[$idx];
  
          if( defined $item and $item eq 'no_diag' ) {
              $class->builder->no_diag(1);
          }
          elsif( defined $item and $item eq 'import' ) {
              if ($import) {
                  push @$import, @{$list->[ ++$idx ]};
              }
              else {
                  $import = $list->[ ++$idx ];
                  push @other, $item, $import;
              }
          }
          else {
              push @other, $item;
          }
  
          $idx++;
      }
  
      @$list = @other;
  
      if ($class eq __PACKAGE__ && (!$import || grep $_ eq '$TODO', @$import)) {
          my $to = $class->builder->exported_to;
          no strict 'refs';
          *{"$to\::TODO"} = \our $TODO;
          if ($import) {
              @$import = grep $_ ne '$TODO', @$import;
          }
          else {
              push @$list, import => [grep $_ ne '$TODO', @EXPORT];
          }
      }
  
      return;
  }
  
  =over 4
  
  =item B<done_testing>
  
      done_testing();
      done_testing($number_of_tests);
  
  If you don't know how many tests you're going to run, you can issue
  the plan when you're done running tests.
  
  $number_of_tests is the same as C<plan()>, it's the number of tests you
  expected to run.  You can omit this, in which case the number of tests
  you ran doesn't matter, just the fact that your tests ran to
  conclusion.
  
  This is safer than and replaces the "no_plan" plan.
  
  B<Note:> You must never put C<done_testing()> inside an C<END { ... }> block.
  The plan is there to ensure your test does not exit before testing has
  completed. If you use an END block you completely bypass this protection.
  
  =back
  
  =cut
  
  sub done_testing {
      my $tb = Test::More->builder;
      $tb->done_testing(@_);
  }
  
  =head2 Test names
  
  By convention, each test is assigned a number in order.  This is
  largely done automatically for you.  However, it's often very useful to
  assign a name to each test.  Which would you rather see:
  
    ok 4
    not ok 5
    ok 6
  
  or
  
    ok 4 - basic multi-variable
    not ok 5 - simple exponential
    ok 6 - force == mass * acceleration
  
  The later gives you some idea of what failed.  It also makes it easier
  to find the test in your script, simply search for "simple
  exponential".
  
  All test functions take a name argument.  It's optional, but highly
  suggested that you use it.
  
  =head2 I'm ok, you're not ok.
  
  The basic purpose of this module is to print out either "ok #" or "not
  ok #" depending on if a given test succeeded or failed.  Everything
  else is just gravy.
  
  All of the following print "ok" or "not ok" depending on if the test
  succeeded or failed.  They all also return true or false,
  respectively.
  
  =over 4
  
  =item B<ok>
  
    ok($got eq $expected, $test_name);
  
  This simply evaluates any expression (C<$got eq $expected> is just a
  simple example) and uses that to determine if the test succeeded or
  failed.  A true expression passes, a false one fails.  Very simple.
  
  For example:
  
      ok( $exp{9} == 81,                   'simple exponential' );
      ok( Film->can('db_Main'),            'set_db()' );
      ok( $p->tests == 4,                  'saw tests' );
      ok( !grep(!defined $_, @items),      'all items defined' );
  
  (Mnemonic:  "This is ok.")
  
  $test_name is a very short description of the test that will be printed
  out.  It makes it very easy to find a test in your script when it fails
  and gives others an idea of your intentions.  $test_name is optional,
  but we B<very> strongly encourage its use.
  
  Should an C<ok()> fail, it will produce some diagnostics:
  
      not ok 18 - sufficient mucus
      #   Failed test 'sufficient mucus'
      #   in foo.t at line 42.
  
  This is the same as L<Test::Simple>'s C<ok()> routine.
  
  =cut
  
  sub ok ($;$) {
      my( $test, $name ) = @_;
      my $tb = Test::More->builder;
  
      return $tb->ok( $test, $name );
  }
  
  =item B<is>
  
  =item B<isnt>
  
    is  ( $got, $expected, $test_name );
    isnt( $got, $expected, $test_name );
  
  Similar to C<ok()>, C<is()> and C<isnt()> compare their two arguments
  with C<eq> and C<ne> respectively and use the result of that to
  determine if the test succeeded or failed.  So these:
  
      # Is the ultimate answer 42?
      is( ultimate_answer(), 42,          "Meaning of Life" );
  
      # $foo isn't empty
      isnt( $foo, '',     "Got some foo" );
  
  are similar to these:
  
      ok( ultimate_answer() eq 42,        "Meaning of Life" );
      ok( $foo ne '',     "Got some foo" );
  
  C<undef> will only ever match C<undef>.  So you can test a value
  against C<undef> like this:
  
      is($not_defined, undef, "undefined as expected");
  
  (Mnemonic:  "This is that."  "This isn't that.")
  
  So why use these?  They produce better diagnostics on failure.  C<ok()>
  cannot know what you are testing for (beyond the name), but C<is()> and
  C<isnt()> know what the test was and why it failed.  For example this
  test:
  
      my $foo = 'waffle';  my $bar = 'yarblokos';
      is( $foo, $bar,   'Is foo the same as bar?' );
  
  Will produce something like this:
  
      not ok 17 - Is foo the same as bar?
      #   Failed test 'Is foo the same as bar?'
      #   in foo.t at line 139.
      #          got: 'waffle'
      #     expected: 'yarblokos'
  
  So you can figure out what went wrong without rerunning the test.
  
  You are encouraged to use C<is()> and C<isnt()> over C<ok()> where possible,
  however do not be tempted to use them to find out if something is
  true or false!
  
    # XXX BAD!
    is( exists $brooklyn{tree}, 1, 'A tree grows in Brooklyn' );
  
  This does not check if C<exists $brooklyn{tree}> is true, it checks if
  it returns 1.  Very different.  Similar caveats exist for false and 0.
  In these cases, use C<ok()>.
  
    ok( exists $brooklyn{tree},    'A tree grows in Brooklyn' );
  
  A simple call to C<isnt()> usually does not provide a strong test but there
  are cases when you cannot say much more about a value than that it is
  different from some other value:
  
    new_ok $obj, "Foo";
  
    my $clone = $obj->clone;
    isa_ok $obj, "Foo", "Foo->clone";
  
    isnt $obj, $clone, "clone() produces a different object";
  
  For those grammatical pedants out there, there's an C<isn't()>
  function which is an alias of C<isnt()>.
  
  =cut
  
  sub is ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->is_eq(@_);
  }
  
  sub isnt ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->isnt_eq(@_);
  }
  
  *isn't = \&isnt;
  # ' to unconfuse syntax higlighters
  
  =item B<like>
  
    like( $got, qr/expected/, $test_name );
  
  Similar to C<ok()>, C<like()> matches $got against the regex C<qr/expected/>.
  
  So this:
  
      like($got, qr/expected/, 'this is like that');
  
  is similar to:
  
      ok( $got =~ m/expected/, 'this is like that');
  
  (Mnemonic "This is like that".)
  
  The second argument is a regular expression.  It may be given as a
  regex reference (i.e. C<qr//>) or (for better compatibility with older
  perls) as a string that looks like a regex (alternative delimiters are
  currently not supported):
  
      like( $got, '/expected/', 'this is like that' );
  
  Regex options may be placed on the end (C<'/expected/i'>).
  
  Its advantages over C<ok()> are similar to that of C<is()> and C<isnt()>.  Better
  diagnostics on failure.
  
  =cut
  
  sub like ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->like(@_);
  }
  
  =item B<unlike>
  
    unlike( $got, qr/expected/, $test_name );
  
  Works exactly as C<like()>, only it checks if $got B<does not> match the
  given pattern.
  
  =cut
  
  sub unlike ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->unlike(@_);
  }
  
  =item B<cmp_ok>
  
    cmp_ok( $got, $op, $expected, $test_name );
  
  Halfway between C<ok()> and C<is()> lies C<cmp_ok()>.  This allows you
  to compare two arguments using any binary perl operator.  The test
  passes if the comparison is true and fails otherwise.
  
      # ok( $got eq $expected );
      cmp_ok( $got, 'eq', $expected, 'this eq that' );
  
      # ok( $got == $expected );
      cmp_ok( $got, '==', $expected, 'this == that' );
  
      # ok( $got && $expected );
      cmp_ok( $got, '&&', $expected, 'this && that' );
      ...etc...
  
  Its advantage over C<ok()> is when the test fails you'll know what $got
  and $expected were:
  
      not ok 1
      #   Failed test in foo.t at line 12.
      #     '23'
      #         &&
      #     undef
  
  It's also useful in those cases where you are comparing numbers and
  C<is()>'s use of C<eq> will interfere:
  
      cmp_ok( $big_hairy_number, '==', $another_big_hairy_number );
  
  It's especially useful when comparing greater-than or smaller-than 
  relation between values:
  
      cmp_ok( $some_value, '<=', $upper_limit );
  
  
  =cut
  
  sub cmp_ok($$$;$) {
      my $tb = Test::More->builder;
  
      return $tb->cmp_ok(@_);
  }
  
  =item B<can_ok>
  
    can_ok($module, @methods);
    can_ok($object, @methods);
  
  Checks to make sure the $module or $object can do these @methods
  (works with functions, too).
  
      can_ok('Foo', qw(this that whatever));
  
  is almost exactly like saying:
  
      ok( Foo->can('this') && 
          Foo->can('that') && 
          Foo->can('whatever') 
        );
  
  only without all the typing and with a better interface.  Handy for
  quickly testing an interface.
  
  No matter how many @methods you check, a single C<can_ok()> call counts
  as one test.  If you desire otherwise, use:
  
      foreach my $meth (@methods) {
          can_ok('Foo', $meth);
      }
  
  =cut
  
  sub can_ok ($@) {
      my( $proto, @methods ) = @_;
      my $class = ref $proto || $proto;
      my $tb = Test::More->builder;
  
      unless($class) {
          my $ok = $tb->ok( 0, "->can(...)" );
          $tb->diag('    can_ok() called with empty class or reference');
          return $ok;
      }
  
      unless(@methods) {
          my $ok = $tb->ok( 0, "$class->can(...)" );
          $tb->diag('    can_ok() called with no methods');
          return $ok;
      }
  
      my @nok = ();
      foreach my $method (@methods) {
          $tb->_try( sub { $proto->can($method) } ) or push @nok, $method;
      }
  
      my $name = (@methods == 1) ? "$class->can('$methods[0]')" :
                                   "$class->can(...)"           ;
  
      my $ok = $tb->ok( !@nok, $name );
  
      $tb->diag( map "    $class->can('$_') failed\n", @nok );
  
      return $ok;
  }
  
  =item B<isa_ok>
  
    isa_ok($object,   $class, $object_name);
    isa_ok($subclass, $class, $object_name);
    isa_ok($ref,      $type,  $ref_name);
  
  Checks to see if the given C<< $object->isa($class) >>.  Also checks to make
  sure the object was defined in the first place.  Handy for this sort
  of thing:
  
      my $obj = Some::Module->new;
      isa_ok( $obj, 'Some::Module' );
  
  where you'd otherwise have to write
  
      my $obj = Some::Module->new;
      ok( defined $obj && $obj->isa('Some::Module') );
  
  to safeguard against your test script blowing up.
  
  You can also test a class, to make sure that it has the right ancestor:
  
      isa_ok( 'Vole', 'Rodent' );
  
  It works on references, too:
  
      isa_ok( $array_ref, 'ARRAY' );
  
  The diagnostics of this test normally just refer to 'the object'.  If
  you'd like them to be more specific, you can supply an $object_name
  (for example 'Test customer').
  
  =cut
  
  sub isa_ok ($$;$) {
      my( $thing, $class, $thing_name ) = @_;
      my $tb = Test::More->builder;
  
      my $whatami;
      if( !defined $thing ) {
          $whatami = 'undef';
      }
      elsif( ref $thing ) {
          $whatami = 'reference';
  
          local($@,$!);
          require Scalar::Util;
          if( Scalar::Util::blessed($thing) ) {
              $whatami = 'object';
          }
      }
      else {
          $whatami = 'class';
      }
  
      # We can't use UNIVERSAL::isa because we want to honor isa() overrides
      my( $rslt, $error ) = $tb->_try( sub { $thing->isa($class) } );
  
      if($error) {
          die <<WHOA unless $error =~ /^Can't (locate|call) method "isa"/;
  WHOA! I tried to call ->isa on your $whatami and got some weird error.
  Here's the error.
  $error
  WHOA
      }
  
      # Special case for isa_ok( [], "ARRAY" ) and like
      if( $whatami eq 'reference' ) {
          $rslt = UNIVERSAL::isa($thing, $class);
      }
  
      my($diag, $name);
      if( defined $thing_name ) {
          $name = "'$thing_name' isa '$class'";
          $diag = defined $thing ? "'$thing_name' isn't a '$class'" : "'$thing_name' isn't defined";
      }
      elsif( $whatami eq 'object' ) {
          my $my_class = ref $thing;
          $thing_name = qq[An object of class '$my_class'];
          $name = "$thing_name isa '$class'";
          $diag = "The object of class '$my_class' isn't a '$class'";
      }
      elsif( $whatami eq 'reference' ) {
          my $type = ref $thing;
          $thing_name = qq[A reference of type '$type'];
          $name = "$thing_name isa '$class'";
          $diag = "The reference of type '$type' isn't a '$class'";
      }
      elsif( $whatami eq 'undef' ) {
          $thing_name = 'undef';
          $name = "$thing_name isa '$class'";
          $diag = "$thing_name isn't defined";
      }
      elsif( $whatami eq 'class' ) {
          $thing_name = qq[The class (or class-like) '$thing'];
          $name = "$thing_name isa '$class'";
          $diag = "$thing_name isn't a '$class'";
      }
      else {
          die;
      }
  
      my $ok;
      if($rslt) {
          $ok = $tb->ok( 1, $name );
      }
      else {
          $ok = $tb->ok( 0, $name );
          $tb->diag("    $diag\n");
      }
  
      return $ok;
  }
  
  =item B<new_ok>
  
    my $obj = new_ok( $class );
    my $obj = new_ok( $class => \@args );
    my $obj = new_ok( $class => \@args, $object_name );
  
  A convenience function which combines creating an object and calling
  C<isa_ok()> on that object.
  
  It is basically equivalent to:
  
      my $obj = $class->new(@args);
      isa_ok $obj, $class, $object_name;
  
  If @args is not given, an empty list will be used.
  
  This function only works on C<new()> and it assumes C<new()> will return
  just a single object which isa C<$class>.
  
  =cut
  
  sub new_ok {
      my $tb = Test::More->builder;
      $tb->croak("new_ok() must be given at least a class") unless @_;
  
      my( $class, $args, $object_name ) = @_;
  
      $args ||= [];
  
      my $obj;
      my( $success, $error ) = $tb->_try( sub { $obj = $class->new(@$args); 1 } );
      if($success) {
          local $Test::Builder::Level = $Test::Builder::Level + 1;
          isa_ok $obj, $class, $object_name;
      }
      else {
          $class = 'undef' if !defined $class;
          $tb->ok( 0, "$class->new() died" );
          $tb->diag("    Error was:  $error");
      }
  
      return $obj;
  }
  
  =item B<subtest>
  
      subtest $name => \&code, @args;
  
  C<subtest()> runs the &code as its own little test with its own plan and
  its own result.  The main test counts this as a single test using the
  result of the whole subtest to determine if its ok or not ok.
  
  For example...
  
    use Test::More tests => 3;
   
    pass("First test");
  
    subtest 'An example subtest' => sub {
        plan tests => 2;
  
        pass("This is a subtest");
        pass("So is this");
    };
  
    pass("Third test");
  
  This would produce.
  
    1..3
    ok 1 - First test
        # Subtest: An example subtest
        1..2
        ok 1 - This is a subtest
        ok 2 - So is this
    ok 2 - An example subtest
    ok 3 - Third test
  
  A subtest may call C<skip_all>.  No tests will be run, but the subtest is
  considered a skip.
  
    subtest 'skippy' => sub {
        plan skip_all => 'cuz I said so';
        pass('this test will never be run');
    };
  
  Returns true if the subtest passed, false otherwise.
  
  Due to how subtests work, you may omit a plan if you desire.  This adds an
  implicit C<done_testing()> to the end of your subtest.  The following two
  subtests are equivalent:
  
    subtest 'subtest with implicit done_testing()', sub {
        ok 1, 'subtests with an implicit done testing should work';
        ok 1, '... and support more than one test';
        ok 1, '... no matter how many tests are run';
    };
  
    subtest 'subtest with explicit done_testing()', sub {
        ok 1, 'subtests with an explicit done testing should work';
        ok 1, '... and support more than one test';
        ok 1, '... no matter how many tests are run';
        done_testing();
    };
  
  Extra arguments given to C<subtest> are passed to the callback. For example:
  
      sub my_subtest {
          my $range = shift;
          ...
      }
  
      for my $range (1, 10, 100, 1000) {
          subtest "testing range $range", \&my_subtest, $range;
      }
  
  =cut
  
  sub subtest {
      my $tb = Test::More->builder;
      return $tb->subtest(@_);
  }
  
  =item B<pass>
  
  =item B<fail>
  
    pass($test_name);
    fail($test_name);
  
  Sometimes you just want to say that the tests have passed.  Usually
  the case is you've got some complicated condition that is difficult to
  wedge into an C<ok()>.  In this case, you can simply use C<pass()> (to
  declare the test ok) or fail (for not ok).  They are synonyms for
  C<ok(1)> and C<ok(0)>.
  
  Use these very, very, very sparingly.
  
  =cut
  
  sub pass (;$) {
      my $tb = Test::More->builder;
  
      return $tb->ok( 1, @_ );
  }
  
  sub fail (;$) {
      my $tb = Test::More->builder;
  
      return $tb->ok( 0, @_ );
  }
  
  =back
  
  
  =head2 Module tests
  
  Sometimes you want to test if a module, or a list of modules, can
  successfully load.  For example, you'll often want a first test which
  simply loads all the modules in the distribution to make sure they
  work before going on to do more complicated testing.
  
  For such purposes we have C<use_ok> and C<require_ok>.
  
  =over 4
  
  =item B<require_ok>
  
     require_ok($module);
     require_ok($file);
  
  Tries to C<require> the given $module or $file.  If it loads
  successfully, the test will pass.  Otherwise it fails and displays the
  load error.
  
  C<require_ok> will guess whether the input is a module name or a
  filename.
  
  No exception will be thrown if the load fails.
  
      # require Some::Module
      require_ok "Some::Module";
  
      # require "Some/File.pl";
      require_ok "Some/File.pl";
  
      # stop testing if any of your modules will not load
      for my $module (@module) {
          require_ok $module or BAIL_OUT "Can't load $module";
      }
  
  =cut
  
  sub require_ok ($) {
      my($module) = shift;
      my $tb = Test::More->builder;
  
      my $pack = caller;
  
      # Try to determine if we've been given a module name or file.
      # Module names must be barewords, files not.
      $module = qq['$module'] unless _is_module_name($module);
  
      my $code = <<REQUIRE;
  package $pack;
  require $module;
  1;
  REQUIRE
  
      my( $eval_result, $eval_error ) = _eval($code);
      my $ok = $tb->ok( $eval_result, "require $module;" );
  
      unless($ok) {
          chomp $eval_error;
          $tb->diag(<<DIAGNOSTIC);
      Tried to require '$module'.
      Error:  $eval_error
  DIAGNOSTIC
  
      }
  
      return $ok;
  }
  
  sub _is_module_name {
      my $module = shift;
  
      # Module names start with a letter.
      # End with an alphanumeric.
      # The rest is an alphanumeric or ::
      $module =~ s/\b::\b//g;
  
      return $module =~ /^[a-zA-Z]\w*$/ ? 1 : 0;
  }
  
  
  =item B<use_ok>
  
     BEGIN { use_ok($module); }
     BEGIN { use_ok($module, @imports); }
  
  Like C<require_ok>, but it will C<use> the $module in question and
  only loads modules, not files.
  
  If you just want to test a module can be loaded, use C<require_ok>.
  
  If you just want to load a module in a test, we recommend simply using
  C<use> directly.  It will cause the test to stop.
  
  It's recommended that you run C<use_ok()> inside a BEGIN block so its
  functions are exported at compile-time and prototypes are properly
  honored.
  
  If @imports are given, they are passed through to the use.  So this:
  
     BEGIN { use_ok('Some::Module', qw(foo bar)) }
  
  is like doing this:
  
     use Some::Module qw(foo bar);
  
  Version numbers can be checked like so:
  
     # Just like "use Some::Module 1.02"
     BEGIN { use_ok('Some::Module', 1.02) }
  
  Don't try to do this:
  
     BEGIN {
         use_ok('Some::Module');
  
         ...some code that depends on the use...
         ...happening at compile time...
     }
  
  because the notion of "compile-time" is relative.  Instead, you want:
  
    BEGIN { use_ok('Some::Module') }
    BEGIN { ...some code that depends on the use... }
  
  If you want the equivalent of C<use Foo ()>, use a module but not
  import anything, use C<require_ok>.
  
    BEGIN { require_ok "Foo" }
  
  =cut
  
  sub use_ok ($;@) {
      my( $module, @imports ) = @_;
      @imports = () unless @imports;
      my $tb = Test::More->builder;
  
      my %caller;
      @caller{qw/pack file line sub args want eval req strict warn/} = caller(0);
  
      my ($pack, $filename, $line, $warn) = @caller{qw/pack file line warn/};
      $filename =~ y/\n\r/_/; # so it doesn't run off the "#line $line $f" line
  
      my $code;
      if( @imports == 1 and $imports[0] =~ /^\d+(?:\.\d+)?$/ ) {
          # probably a version check.  Perl needs to see the bare number
          # for it to work with non-Exporter based modules.
          $code = <<USE;
  package $pack;
  BEGIN { \${^WARNING_BITS} = \$args[-1] if defined \$args[-1] }
  #line $line $filename
  use $module $imports[0];
  1;
  USE
      }
      else {
          $code = <<USE;
  package $pack;
  BEGIN { \${^WARNING_BITS} = \$args[-1] if defined \$args[-1] }
  #line $line $filename
  use $module \@{\$args[0]};
  1;
  USE
      }
  
      my ($eval_result, $eval_error) = _eval($code, \@imports, $warn);
      my $ok = $tb->ok( $eval_result, "use $module;" );
  
      unless($ok) {
          chomp $eval_error;
          $@ =~ s{^BEGIN failed--compilation aborted at .*$}
                  {BEGIN failed--compilation aborted at $filename line $line.}m;
          $tb->diag(<<DIAGNOSTIC);
      Tried to use '$module'.
      Error:  $eval_error
  DIAGNOSTIC
  
      }
  
      return $ok;
  }
  
  sub _eval {
      my( $code, @args ) = @_;
  
      # Work around oddities surrounding resetting of $@ by immediately
      # storing it.
      my( $sigdie, $eval_result, $eval_error );
      {
          local( $@, $!, $SIG{__DIE__} );    # isolate eval
          $eval_result = eval $code;              ## no critic (BuiltinFunctions::ProhibitStringyEval)
          $eval_error  = $@;
          $sigdie      = $SIG{__DIE__} || undef;
      }
      # make sure that $code got a chance to set $SIG{__DIE__}
      $SIG{__DIE__} = $sigdie if defined $sigdie;
  
      return( $eval_result, $eval_error );
  }
  
  
  =back
  
  
  =head2 Complex data structures
  
  Not everything is a simple eq check or regex.  There are times you
  need to see if two data structures are equivalent.  For these
  instances Test::More provides a handful of useful functions.
  
  B<NOTE> I'm not quite sure what will happen with filehandles.
  
  =over 4
  
  =item B<is_deeply>
  
    is_deeply( $got, $expected, $test_name );
  
  Similar to C<is()>, except that if $got and $expected are references, it
  does a deep comparison walking each data structure to see if they are
  equivalent.  If the two structures are different, it will display the
  place where they start differing.
  
  C<is_deeply()> compares the dereferenced values of references, the
  references themselves (except for their type) are ignored.  This means
  aspects such as blessing and ties are not considered "different".
  
  C<is_deeply()> currently has very limited handling of function reference
  and globs.  It merely checks if they have the same referent.  This may
  improve in the future.
  
  L<Test::Differences> and L<Test::Deep> provide more in-depth functionality
  along these lines.
  
  B<NOTE> is_deeply() has limitations when it comes to comparing strings and
  refs:
  
      my $path = path('.');
      my $hash = {};
      is_deeply( $path, "$path" ); # ok
      is_deeply( $hash, "$hash" ); # fail
  
  This happens because is_deeply will unoverload all arguments unconditionally.
  It is probably best not to use is_deeply with overloading. For legacy reasons
  this is not likely to ever be fixed. If you would like a much better tool for
  this you should see L<Test2::Suite> Specifically L<Test2::Tools::Compare> has
  an C<is()> function that works like C<is_deeply> with many improvements.
  
  =cut
  
  our( @Data_Stack, %Refs_Seen );
  my $DNE = bless [], 'Does::Not::Exist';
  
  sub _dne {
      return ref $_[0] eq ref $DNE;
  }
  
  ## no critic (Subroutines::RequireArgUnpacking)
  sub is_deeply {
      my $tb = Test::More->builder;
  
      unless( @_ == 2 or @_ == 3 ) {
          my $msg = <<'WARNING';
  is_deeply() takes two or three args, you gave %d.
  This usually means you passed an array or hash instead 
  of a reference to it
  WARNING
          chop $msg;    # clip off newline so carp() will put in line/file
  
          _carp sprintf $msg, scalar @_;
  
          return $tb->ok(0);
      }
  
      my( $got, $expected, $name ) = @_;
  
      $tb->_unoverload_str( \$expected, \$got );
  
      my $ok;
      if( !ref $got and !ref $expected ) {    # neither is a reference
          $ok = $tb->is_eq( $got, $expected, $name );
      }
      elsif( !ref $got xor !ref $expected ) {    # one's a reference, one isn't
          $ok = $tb->ok( 0, $name );
          $tb->diag( _format_stack({ vals => [ $got, $expected ] }) );
      }
      else {                                     # both references
          local @Data_Stack = ();
          if( _deep_check( $got, $expected ) ) {
              $ok = $tb->ok( 1, $name );
          }
          else {
              $ok = $tb->ok( 0, $name );
              $tb->diag( _format_stack(@Data_Stack) );
          }
      }
  
      return $ok;
  }
  
  sub _format_stack {
      my(@Stack) = @_;
  
      my $var       = '$FOO';
      my $did_arrow = 0;
      foreach my $entry (@Stack) {
          my $type = $entry->{type} || '';
          my $idx = $entry->{'idx'};
          if( $type eq 'HASH' ) {
              $var .= "->" unless $did_arrow++;
              $var .= "{$idx}";
          }
          elsif( $type eq 'ARRAY' ) {
              $var .= "->" unless $did_arrow++;
              $var .= "[$idx]";
          }
          elsif( $type eq 'REF' ) {
              $var = "\${$var}";
          }
      }
  
      my @vals = @{ $Stack[-1]{vals} }[ 0, 1 ];
      my @vars = ();
      ( $vars[0] = $var ) =~ s/\$FOO/     \$got/;
      ( $vars[1] = $var ) =~ s/\$FOO/\$expected/;
  
      my $out = "Structures begin differing at:\n";
      foreach my $idx ( 0 .. $#vals ) {
          my $val = $vals[$idx];
          $vals[$idx]
            = !defined $val ? 'undef'
            : _dne($val)    ? "Does not exist"
            : ref $val      ? "$val"
            :                 "'$val'";
      }
  
      $out .= "$vars[0] = $vals[0]\n";
      $out .= "$vars[1] = $vals[1]\n";
  
      $out =~ s/^/    /msg;
      return $out;
  }
  
  sub _type {
      my $thing = shift;
  
      return '' if !ref $thing;
  
      for my $type (qw(Regexp ARRAY HASH REF SCALAR GLOB CODE VSTRING)) {
          return $type if UNIVERSAL::isa( $thing, $type );
      }
  
      return '';
  }
  
  =back
  
  
  =head2 Diagnostics
  
  If you pick the right test function, you'll usually get a good idea of
  what went wrong when it failed.  But sometimes it doesn't work out
  that way.  So here we have ways for you to write your own diagnostic
  messages which are safer than just C<print STDERR>.
  
  =over 4
  
  =item B<diag>
  
    diag(@diagnostic_message);
  
  Prints a diagnostic message which is guaranteed not to interfere with
  test output.  Like C<print> @diagnostic_message is simply concatenated
  together.
  
  Returns false, so as to preserve failure.
  
  Handy for this sort of thing:
  
      ok( grep(/foo/, @users), "There's a foo user" ) or
          diag("Since there's no foo, check that /etc/bar is set up right");
  
  which would produce:
  
      not ok 42 - There's a foo user
      #   Failed test 'There's a foo user'
      #   in foo.t at line 52.
      # Since there's no foo, check that /etc/bar is set up right.
  
  You might remember C<ok() or diag()> with the mnemonic C<open() or
  die()>.
  
  B<NOTE> The exact formatting of the diagnostic output is still
  changing, but it is guaranteed that whatever you throw at it won't
  interfere with the test.
  
  =item B<note>
  
    note(@diagnostic_message);
  
  Like C<diag()>, except the message will not be seen when the test is run
  in a harness.  It will only be visible in the verbose TAP stream.
  
  Handy for putting in notes which might be useful for debugging, but
  don't indicate a problem.
  
      note("Tempfile is $tempfile");
  
  =cut
  
  sub diag {
      return Test::More->builder->diag(@_);
  }
  
  sub note {
      return Test::More->builder->note(@_);
  }
  
  =item B<explain>
  
    my @dump = explain @diagnostic_message;
  
  Will dump the contents of any references in a human readable format.
  Usually you want to pass this into C<note> or C<diag>.
  
  Handy for things like...
  
      is_deeply($have, $want) || diag explain $have;
  
  or
  
      note explain \%args;
      Some::Class->method(%args);
  
  =cut
  
  sub explain {
      return Test::More->builder->explain(@_);
  }
  
  =back
  
  
  =head2 Conditional tests
  
  Sometimes running a test under certain conditions will cause the
  test script to die.  A certain function or method isn't implemented
  (such as C<fork()> on MacOS), some resource isn't available (like a 
  net connection) or a module isn't available.  In these cases it's
  necessary to skip tests, or declare that they are supposed to fail
  but will work in the future (a todo test).
  
  For more details on the mechanics of skip and todo tests see
  L<Test::Harness>.
  
  The way Test::More handles this is with a named block.  Basically, a
  block of tests which can be skipped over or made todo.  It's best if I
  just show you...
  
  =over 4
  
  =item B<SKIP: BLOCK>
  
    SKIP: {
        skip $why, $how_many if $condition;
  
        ...normal testing code goes here...
    }
  
  This declares a block of tests that might be skipped, $how_many tests
  there are, $why and under what $condition to skip them.  An example is
  the easiest way to illustrate:
  
      SKIP: {
          eval { require HTML::Lint };
  
          skip "HTML::Lint not installed", 2 if $@;
  
          my $lint = new HTML::Lint;
          isa_ok( $lint, "HTML::Lint" );
  
          $lint->parse( $html );
          is( $lint->errors, 0, "No errors found in HTML" );
      }
  
  If the user does not have HTML::Lint installed, the whole block of
  code I<won't be run at all>.  Test::More will output special ok's
  which Test::Harness interprets as skipped, but passing, tests.
  
  It's important that $how_many accurately reflects the number of tests
  in the SKIP block so the # of tests run will match up with your plan.
  If your plan is C<no_plan> $how_many is optional and will default to 1.
  
  It's perfectly safe to nest SKIP blocks.  Each SKIP block must have
  the label C<SKIP>, or Test::More can't work its magic.
  
  You don't skip tests which are failing because there's a bug in your
  program, or for which you don't yet have code written.  For that you
  use TODO.  Read on.
  
  =cut
  
  ## no critic (Subroutines::RequireFinalReturn)
  sub skip {
      my( $why, $how_many ) = @_;
      my $tb = Test::More->builder;
  
      # If the plan is set, and is static, then skip needs a count. If the plan
      # is 'no_plan' we are fine. As well if plan is undefined then we are
      # waiting for done_testing.
      unless (defined $how_many) {
          my $plan = $tb->has_plan;
          _carp "skip() needs to know \$how_many tests are in the block"
              if $plan && $plan =~ m/^\d+$/;
          $how_many = 1;
      }
  
      if( defined $how_many and $how_many =~ /\D/ ) {
          _carp
            "skip() was passed a non-numeric number of tests.  Did you get the arguments backwards?";
          $how_many = 1;
      }
  
      for( 1 .. $how_many ) {
          $tb->skip($why);
      }
  
      no warnings 'exiting';
      last SKIP;
  }
  
  =item B<TODO: BLOCK>
  
      TODO: {
          local $TODO = $why if $condition;
  
          ...normal testing code goes here...
      }
  
  Declares a block of tests you expect to fail and $why.  Perhaps it's
  because you haven't fixed a bug or haven't finished a new feature:
  
      TODO: {
          local $TODO = "URI::Geller not finished";
  
          my $card = "Eight of clubs";
          is( URI::Geller->your_card, $card, 'Is THIS your card?' );
  
          my $spoon;
          URI::Geller->bend_spoon;
          is( $spoon, 'bent',    "Spoon bending, that's original" );
      }
  
  With a todo block, the tests inside are expected to fail.  Test::More
  will run the tests normally, but print out special flags indicating
  they are "todo".  L<Test::Harness> will interpret failures as being ok.
  Should anything succeed, it will report it as an unexpected success.
  You then know the thing you had todo is done and can remove the
  TODO flag.
  
  The nice part about todo tests, as opposed to simply commenting out a
  block of tests, is it's like having a programmatic todo list.  You know
  how much work is left to be done, you're aware of what bugs there are,
  and you'll know immediately when they're fixed.
  
  Once a todo test starts succeeding, simply move it outside the block.
  When the block is empty, delete it.
  
  
  =item B<todo_skip>
  
      TODO: {
          todo_skip $why, $how_many if $condition;
  
          ...normal testing code...
      }
  
  With todo tests, it's best to have the tests actually run.  That way
  you'll know when they start passing.  Sometimes this isn't possible.
  Often a failing test will cause the whole program to die or hang, even
  inside an C<eval BLOCK> with and using C<alarm>.  In these extreme
  cases you have no choice but to skip over the broken tests entirely.
  
  The syntax and behavior is similar to a C<SKIP: BLOCK> except the
  tests will be marked as failing but todo.  L<Test::Harness> will
  interpret them as passing.
  
  =cut
  
  sub todo_skip {
      my( $why, $how_many ) = @_;
      my $tb = Test::More->builder;
  
      unless( defined $how_many ) {
          # $how_many can only be avoided when no_plan is in use.
          _carp "todo_skip() needs to know \$how_many tests are in the block"
            unless $tb->has_plan eq 'no_plan';
          $how_many = 1;
      }
  
      for( 1 .. $how_many ) {
          $tb->todo_skip($why);
      }
  
      no warnings 'exiting';
      last TODO;
  }
  
  =item When do I use SKIP vs. TODO?
  
  B<If it's something the user might not be able to do>, use SKIP.
  This includes optional modules that aren't installed, running under
  an OS that doesn't have some feature (like C<fork()> or symlinks), or maybe
  you need an Internet connection and one isn't available.
  
  B<If it's something the programmer hasn't done yet>, use TODO.  This
  is for any code you haven't written yet, or bugs you have yet to fix,
  but want to put tests in your testing script (always a good idea).
  
  
  =back
  
  
  =head2 Test control
  
  =over 4
  
  =item B<BAIL_OUT>
  
      BAIL_OUT($reason);
  
  Indicates to the harness that things are going so badly all testing
  should terminate.  This includes the running of any additional test scripts.
  
  This is typically used when testing cannot continue such as a critical
  module failing to compile or a necessary external utility not being
  available such as a database connection failing.
  
  The test will exit with 255.
  
  For even better control look at L<Test::Most>.
  
  =cut
  
  sub BAIL_OUT {
      my $reason = shift;
      my $tb     = Test::More->builder;
  
      $tb->BAIL_OUT($reason);
  }
  
  =back
  
  
  =head2 Discouraged comparison functions
  
  The use of the following functions is discouraged as they are not
  actually testing functions and produce no diagnostics to help figure
  out what went wrong.  They were written before C<is_deeply()> existed
  because I couldn't figure out how to display a useful diff of two
  arbitrary data structures.
  
  These functions are usually used inside an C<ok()>.
  
      ok( eq_array(\@got, \@expected) );
  
  C<is_deeply()> can do that better and with diagnostics.  
  
      is_deeply( \@got, \@expected );
  
  They may be deprecated in future versions.
  
  =over 4
  
  =item B<eq_array>
  
    my $is_eq = eq_array(\@got, \@expected);
  
  Checks if two arrays are equivalent.  This is a deep check, so
  multi-level structures are handled correctly.
  
  =cut
  
  #'#
  sub eq_array {
      local @Data_Stack = ();
      _deep_check(@_);
  }
  
  sub _eq_array {
      my( $a1, $a2 ) = @_;
  
      if( grep _type($_) ne 'ARRAY', $a1, $a2 ) {
          warn "eq_array passed a non-array ref";
          return 0;
      }
  
      return 1 if $a1 eq $a2;
  
      my $ok = 1;
      my $max = $#$a1 > $#$a2 ? $#$a1 : $#$a2;
      for( 0 .. $max ) {
          my $e1 = $_ > $#$a1 ? $DNE : $a1->[$_];
          my $e2 = $_ > $#$a2 ? $DNE : $a2->[$_];
  
          next if _equal_nonrefs($e1, $e2);
  
          push @Data_Stack, { type => 'ARRAY', idx => $_, vals => [ $e1, $e2 ] };
          $ok = _deep_check( $e1, $e2 );
          pop @Data_Stack if $ok;
  
          last unless $ok;
      }
  
      return $ok;
  }
  
  sub _equal_nonrefs {
      my( $e1, $e2 ) = @_;
  
      return if ref $e1 or ref $e2;
  
      if ( defined $e1 ) {
          return 1 if defined $e2 and $e1 eq $e2;
      }
      else {
          return 1 if !defined $e2;
      }
  
      return;
  }
  
  sub _deep_check {
      my( $e1, $e2 ) = @_;
      my $tb = Test::More->builder;
  
      my $ok = 0;
  
      # Effectively turn %Refs_Seen into a stack.  This avoids picking up
      # the same referenced used twice (such as [\$a, \$a]) to be considered
      # circular.
      local %Refs_Seen = %Refs_Seen;
  
      {
          $tb->_unoverload_str( \$e1, \$e2 );
  
          # Either they're both references or both not.
          my $same_ref = !( !ref $e1 xor !ref $e2 );
          my $not_ref = ( !ref $e1 and !ref $e2 );
  
          if( defined $e1 xor defined $e2 ) {
              $ok = 0;
          }
          elsif( !defined $e1 and !defined $e2 ) {
              # Shortcut if they're both undefined.
              $ok = 1;
          }
          elsif( _dne($e1) xor _dne($e2) ) {
              $ok = 0;
          }
          elsif( $same_ref and( $e1 eq $e2 ) ) {
              $ok = 1;
          }
          elsif($not_ref) {
              push @Data_Stack, { type => '', vals => [ $e1, $e2 ] };
              $ok = 0;
          }
          else {
              if( $Refs_Seen{$e1} ) {
                  return $Refs_Seen{$e1} eq $e2;
              }
              else {
                  $Refs_Seen{$e1} = "$e2";
              }
  
              my $type = _type($e1);
              $type = 'DIFFERENT' unless _type($e2) eq $type;
  
              if( $type eq 'DIFFERENT' ) {
                  push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
                  $ok = 0;
              }
              elsif( $type eq 'ARRAY' ) {
                  $ok = _eq_array( $e1, $e2 );
              }
              elsif( $type eq 'HASH' ) {
                  $ok = _eq_hash( $e1, $e2 );
              }
              elsif( $type eq 'REF' ) {
                  push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
                  $ok = _deep_check( $$e1, $$e2 );
                  pop @Data_Stack if $ok;
              }
              elsif( $type eq 'SCALAR' ) {
                  push @Data_Stack, { type => 'REF', vals => [ $e1, $e2 ] };
                  $ok = _deep_check( $$e1, $$e2 );
                  pop @Data_Stack if $ok;
              }
              elsif($type) {
                  push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
                  $ok = 0;
              }
              else {
                  _whoa( 1, "No type in _deep_check" );
              }
          }
      }
  
      return $ok;
  }
  
  sub _whoa {
      my( $check, $desc ) = @_;
      if($check) {
          die <<"WHOA";
  WHOA!  $desc
  This should never happen!  Please contact the author immediately!
  WHOA
      }
  }
  
  =item B<eq_hash>
  
    my $is_eq = eq_hash(\%got, \%expected);
  
  Determines if the two hashes contain the same keys and values.  This
  is a deep check.
  
  =cut
  
  sub eq_hash {
      local @Data_Stack = ();
      return _deep_check(@_);
  }
  
  sub _eq_hash {
      my( $a1, $a2 ) = @_;
  
      if( grep _type($_) ne 'HASH', $a1, $a2 ) {
          warn "eq_hash passed a non-hash ref";
          return 0;
      }
  
      return 1 if $a1 eq $a2;
  
      my $ok = 1;
      my $bigger = keys %$a1 > keys %$a2 ? $a1 : $a2;
      foreach my $k ( keys %$bigger ) {
          my $e1 = exists $a1->{$k} ? $a1->{$k} : $DNE;
          my $e2 = exists $a2->{$k} ? $a2->{$k} : $DNE;
  
          next if _equal_nonrefs($e1, $e2);
  
          push @Data_Stack, { type => 'HASH', idx => $k, vals => [ $e1, $e2 ] };
          $ok = _deep_check( $e1, $e2 );
          pop @Data_Stack if $ok;
  
          last unless $ok;
      }
  
      return $ok;
  }
  
  =item B<eq_set>
  
    my $is_eq = eq_set(\@got, \@expected);
  
  Similar to C<eq_array()>, except the order of the elements is B<not>
  important.  This is a deep check, but the irrelevancy of order only
  applies to the top level.
  
      ok( eq_set(\@got, \@expected) );
  
  Is better written:
  
      is_deeply( [sort @got], [sort @expected] );
  
  B<NOTE> By historical accident, this is not a true set comparison.
  While the order of elements does not matter, duplicate elements do.
  
  B<NOTE> C<eq_set()> does not know how to deal with references at the top
  level.  The following is an example of a comparison which might not work:
  
      eq_set([\1, \2], [\2, \1]);
  
  L<Test::Deep> contains much better set comparison functions.
  
  =cut
  
  sub eq_set {
      my( $a1, $a2 ) = @_;
      return 0 unless @$a1 == @$a2;
  
      no warnings 'uninitialized';
  
      # It really doesn't matter how we sort them, as long as both arrays are
      # sorted with the same algorithm.
      #
      # Ensure that references are not accidentally treated the same as a
      # string containing the reference.
      #
      # Have to inline the sort routine due to a threading/sort bug.
      # See [rt.cpan.org 6782]
      #
      # I don't know how references would be sorted so we just don't sort
      # them.  This means eq_set doesn't really work with refs.
      return eq_array(
          [ grep( ref, @$a1 ), sort( grep( !ref, @$a1 ) ) ],
          [ grep( ref, @$a2 ), sort( grep( !ref, @$a2 ) ) ],
      );
  }
  
  =back
  
  
  =head2 Extending and Embedding Test::More
  
  Sometimes the Test::More interface isn't quite enough.  Fortunately,
  Test::More is built on top of L<Test::Builder> which provides a single,
  unified backend for any test library to use.  This means two test
  libraries which both use <Test::Builder> B<can> be used together in the
  same program>.
  
  If you simply want to do a little tweaking of how the tests behave,
  you can access the underlying L<Test::Builder> object like so:
  
  =over 4
  
  =item B<builder>
  
      my $test_builder = Test::More->builder;
  
  Returns the L<Test::Builder> object underlying Test::More for you to play
  with.
  
  
  =back
  
  
  =head1 EXIT CODES
  
  If all your tests passed, L<Test::Builder> will exit with zero (which is
  normal).  If anything failed it will exit with how many failed.  If
  you run less (or more) tests than you planned, the missing (or extras)
  will be considered failures.  If no tests were ever run L<Test::Builder>
  will throw a warning and exit with 255.  If the test died, even after
  having successfully completed all its tests, it will still be
  considered a failure and will exit with 255.
  
  So the exit codes are...
  
      0                   all tests successful
      255                 test died or all passed but wrong # of tests run
      any other number    how many failed (including missing or extras)
  
  If you fail more than 254 tests, it will be reported as 254.
  
  B<NOTE>  This behavior may go away in future versions.
  
  
  =head1 COMPATIBILITY
  
  Test::More works with Perls as old as 5.8.1.
  
  Thread support is not very reliable before 5.10.1, but that's
  because threads are not very reliable before 5.10.1.
  
  Although Test::More has been a core module in versions of Perl since 5.6.2, Test::More has evolved since then, and not all of the features you're used to will be present in the shipped version of Test::More. If you are writing a module, don't forget to indicate in your package metadata the minimum version of Test::More that you require. For instance, if you want to use C<done_testing()> but want your test script to run on Perl 5.10.0, you will need to explicitly require Test::More > 0.88.
  
  Key feature milestones include:
  
  =over 4
  
  =item subtests
  
  Subtests were released in Test::More 0.94, which came with Perl 5.12.0. Subtests did not implicitly call C<done_testing()> until 0.96; the first Perl with that fix was Perl 5.14.0 with 0.98.
  
  =item C<done_testing()>
  
  This was released in Test::More 0.88 and first shipped with Perl in 5.10.1 as part of Test::More 0.92. 
  
  =item C<cmp_ok()>
  
  Although C<cmp_ok()> was introduced in 0.40, 0.86 fixed an important bug to make it safe for overloaded objects; the fixed first shipped with Perl in 5.10.1 as part of Test::More 0.92.
  
  =item C<new_ok()> C<note()> and C<explain()>
  
  These were was released in Test::More 0.82, and first shipped with Perl in 5.10.1 as part of Test::More 0.92. 
  
  =back
  
  There is a full version history in the Changes file, and the Test::More versions included as core can be found using L<Module::CoreList>:
  
      $ corelist -a Test::More
  
  
  =head1 CAVEATS and NOTES
  
  =over 4
  
  =item utf8 / "Wide character in print"
  
  If you use utf8 or other non-ASCII characters with Test::More you
  might get a "Wide character in print" warning.  Using
  C<< binmode STDOUT, ":utf8" >> will not fix it.
  L<Test::Builder> (which powers
  Test::More) duplicates STDOUT and STDERR.  So any changes to them,
  including changing their output disciplines, will not be seem by
  Test::More.
  
  One work around is to apply encodings to STDOUT and STDERR as early
  as possible and before Test::More (or any other Test module) loads.
  
      use open ':std', ':encoding(utf8)';
      use Test::More;
  
  A more direct work around is to change the filehandles used by
  L<Test::Builder>.
  
      my $builder = Test::More->builder;
      binmode $builder->output,         ":encoding(utf8)";
      binmode $builder->failure_output, ":encoding(utf8)";
      binmode $builder->todo_output,    ":encoding(utf8)";
  
  
  =item Overloaded objects
  
  String overloaded objects are compared B<as strings> (or in C<cmp_ok()>'s
  case, strings or numbers as appropriate to the comparison op).  This
  prevents Test::More from piercing an object's interface allowing
  better blackbox testing.  So if a function starts returning overloaded
  objects instead of bare strings your tests won't notice the
  difference.  This is good.
  
  However, it does mean that functions like C<is_deeply()> cannot be used to
  test the internals of string overloaded objects.  In this case I would
  suggest L<Test::Deep> which contains more flexible testing functions for
  complex data structures.
  
  
  =item Threads
  
  Test::More will only be aware of threads if C<use threads> has been done
  I<before> Test::More is loaded.  This is ok:
  
      use threads;
      use Test::More;
  
  This may cause problems:
  
      use Test::More
      use threads;
  
  5.8.1 and above are supported.  Anything below that has too many bugs.
  
  =back
  
  
  =head1 HISTORY
  
  This is a case of convergent evolution with Joshua Pritikin's L<Test>
  module.  I was largely unaware of its existence when I'd first
  written my own C<ok()> routines.  This module exists because I can't
  figure out how to easily wedge test names into Test's interface (along
  with a few other problems).
  
  The goal here is to have a testing utility that's simple to learn,
  quick to use and difficult to trip yourself up with while still
  providing more flexibility than the existing Test.pm.  As such, the
  names of the most common routines are kept tiny, special cases and
  magic side-effects are kept to a minimum.  WYSIWYG.
  
  
  =head1 SEE ALSO
  
  =head2
  
  =head2 ALTERNATIVES
  
  L<Test::Simple> if all this confuses you and you just want to write
  some tests.  You can upgrade to Test::More later (it's forward
  compatible).
  
  L<Test::Legacy> tests written with Test.pm, the original testing
  module, do not play well with other testing libraries.  Test::Legacy
  emulates the Test.pm interface and does play well with others.
  
  =head2 TESTING FRAMEWORKS
  
  L<Fennec> The Fennec framework is a testers toolbox. It uses L<Test::Builder>
  under the hood. It brings enhancements for forking, defining state, and
  mocking. Fennec enhances several modules to work better together than they
  would if you loaded them individually on your own.
  
  L<Fennec::Declare> Provides enhanced (L<Devel::Declare>) syntax for Fennec.
  
  =head2 ADDITIONAL LIBRARIES
  
  L<Test::Differences> for more ways to test complex data structures.
  And it plays well with Test::More.
  
  L<Test::Class> is like xUnit but more perlish.
  
  L<Test::Deep> gives you more powerful complex data structure testing.
  
  L<Test::Inline> shows the idea of embedded testing.
  
  L<Mock::Quick> The ultimate mocking library. Easily spawn objects defined on
  the fly. Can also override, block, or reimplement packages as needed.
  
  L<Test::FixtureBuilder> Quickly define fixture data for unit tests.
  
  =head2 OTHER COMPONENTS
  
  L<Test::Harness> is the test runner and output interpreter for Perl.
  It's the thing that powers C<make test> and where the C<prove> utility
  comes from.
  
  =head2 BUNDLES
  
  L<Test::Most> Most commonly needed test functions and features.
  
  =head1 AUTHORS
  
  Michael G Schwern E<lt>schwern@pobox.comE<gt> with much inspiration
  from Joshua Pritikin's Test module and lots of help from Barrie
  Slaymaker, Tony Bowden, blackstar.co.uk, chromatic, Fergal Daly and
  the perl-qa gang.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  
  =head1 BUGS
  
  See F<https://github.com/Test-More/test-more/issues> to report and view bugs.
  
  
  =head1 SOURCE
  
  The source code repository for Test::More can be found at
  F<http://github.com/Test-More/test-more/>.
  
  
  =head1 COPYRIGHT
  
  Copyright 2001-2008 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
  
  1;
TEST_MORE

$fatpacked{"Test/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_SIMPLE';
  package Test::Simple;
  
  use 5.006;
  
  use strict;
  
  our $VERSION = '1.302120';
  
  use Test::Builder::Module;
  our @ISA    = qw(Test::Builder::Module);
  our @EXPORT = qw(ok);
  
  my $CLASS = __PACKAGE__;
  
  =head1 NAME
  
  Test::Simple - Basic utilities for writing tests.
  
  =head1 SYNOPSIS
  
    use Test::Simple tests => 1;
  
    ok( $foo eq $bar, 'foo is bar' );
  
  
  =head1 DESCRIPTION
  
  ** If you are unfamiliar with testing B<read L<Test::Tutorial> first!> **
  
  This is an extremely simple, extremely basic module for writing tests
  suitable for CPAN modules and other pursuits.  If you wish to do more
  complicated testing, use the Test::More module (a drop-in replacement
  for this one).
  
  The basic unit of Perl testing is the ok.  For each thing you want to
  test your program will print out an "ok" or "not ok" to indicate pass
  or fail.  You do this with the C<ok()> function (see below).
  
  The only other constraint is you must pre-declare how many tests you
  plan to run.  This is in case something goes horribly wrong during the
  test and your test program aborts, or skips a test or whatever.  You
  do this like so:
  
      use Test::Simple tests => 23;
  
  You must have a plan.
  
  
  =over 4
  
  =item B<ok>
  
    ok( $foo eq $bar, $name );
    ok( $foo eq $bar );
  
  C<ok()> is given an expression (in this case C<$foo eq $bar>).  If it's
  true, the test passed.  If it's false, it didn't.  That's about it.
  
  C<ok()> prints out either "ok" or "not ok" along with a test number (it
  keeps track of that for you).
  
    # This produces "ok 1 - Hell not yet frozen over" (or not ok)
    ok( get_temperature($hell) > 0, 'Hell not yet frozen over' );
  
  If you provide a $name, that will be printed along with the "ok/not
  ok" to make it easier to find your test when if fails (just search for
  the name).  It also makes it easier for the next guy to understand
  what your test is for.  It's highly recommended you use test names.
  
  All tests are run in scalar context.  So this:
  
      ok( @stuff, 'I have some stuff' );
  
  will do what you mean (fail if stuff is empty)
  
  =cut
  
  sub ok ($;$) {    ## no critic (Subroutines::ProhibitSubroutinePrototypes)
      return $CLASS->builder->ok(@_);
  }
  
  =back
  
  Test::Simple will start by printing number of tests run in the form
  "1..M" (so "1..5" means you're going to run 5 tests).  This strange
  format lets L<Test::Harness> know how many tests you plan on running in
  case something goes horribly wrong.
  
  If all your tests passed, Test::Simple will exit with zero (which is
  normal).  If anything failed it will exit with how many failed.  If
  you run less (or more) tests than you planned, the missing (or extras)
  will be considered failures.  If no tests were ever run Test::Simple
  will throw a warning and exit with 255.  If the test died, even after
  having successfully completed all its tests, it will still be
  considered a failure and will exit with 255.
  
  So the exit codes are...
  
      0                   all tests successful
      255                 test died or all passed but wrong # of tests run
      any other number    how many failed (including missing or extras)
  
  If you fail more than 254 tests, it will be reported as 254.
  
  This module is by no means trying to be a complete testing system.
  It's just to get you started.  Once you're off the ground its
  recommended you look at L<Test::More>.
  
  
  =head1 EXAMPLE
  
  Here's an example of a simple .t file for the fictional Film module.
  
      use Test::Simple tests => 5;
  
      use Film;  # What you're testing.
  
      my $btaste = Film->new({ Title    => 'Bad Taste',
                               Director => 'Peter Jackson',
                               Rating   => 'R',
                               NumExplodingSheep => 1
                             });
      ok( defined($btaste) && ref $btaste eq 'Film',     'new() works' );
  
      ok( $btaste->Title      eq 'Bad Taste',     'Title() get'    );
      ok( $btaste->Director   eq 'Peter Jackson', 'Director() get' );
      ok( $btaste->Rating     eq 'R',             'Rating() get'   );
      ok( $btaste->NumExplodingSheep == 1,        'NumExplodingSheep() get' );
  
  It will produce output like this:
  
      1..5
      ok 1 - new() works
      ok 2 - Title() get
      ok 3 - Director() get
      not ok 4 - Rating() get
      #   Failed test 'Rating() get'
      #   in t/film.t at line 14.
      ok 5 - NumExplodingSheep() get
      # Looks like you failed 1 tests of 5
  
  Indicating the Film::Rating() method is broken.
  
  
  =head1 CAVEATS
  
  Test::Simple will only report a maximum of 254 failures in its exit
  code.  If this is a problem, you probably have a huge test script.
  Split it into multiple files.  (Otherwise blame the Unix folks for
  using an unsigned short integer as the exit status).
  
  Because VMS's exit codes are much, much different than the rest of the
  universe, and perl does horrible mangling to them that gets in my way,
  it works like this on VMS.
  
      0     SS$_NORMAL        all tests successful
      4     SS$_ABORT         something went wrong
  
  Unfortunately, I can't differentiate any further.
  
  
  =head1 NOTES
  
  Test::Simple is B<explicitly> tested all the way back to perl 5.6.0.
  
  Test::Simple is thread-safe in perl 5.8.1 and up.
  
  =head1 HISTORY
  
  This module was conceived while talking with Tony Bowden in his
  kitchen one night about the problems I was having writing some really
  complicated feature into the new Testing module.  He observed that the
  main problem is not dealing with these edge cases but that people hate
  to write tests B<at all>.  What was needed was a dead simple module
  that took all the hard work out of testing and was really, really easy
  to learn.  Paul Johnson simultaneously had this idea (unfortunately,
  he wasn't in Tony's kitchen).  This is it.
  
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<Test::More>
  
  More testing functions!  Once you outgrow Test::Simple, look at
  L<Test::More>.  Test::Simple is 100% forward compatible with L<Test::More>
  (i.e. you can just use L<Test::More> instead of Test::Simple in your
  programs and things will still work).
  
  =back
  
  Look in L<Test::More>'s SEE ALSO for more testing modules.
  
  
  =head1 AUTHORS
  
  Idea by Tony Bowden and Paul Johnson, code by Michael G Schwern
  E<lt>schwern@pobox.comE<gt>, wardrobe by Calvin Klein.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2001-2008 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or 
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
  
  1;
TEST_SIMPLE

$fatpacked{"Test/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER';
  use strict;
  
  package Test::Tester;
  
  BEGIN
  {
  	if (*Test::Builder::new{CODE})
  	{
  		warn "You should load Test::Tester before Test::Builder (or anything that loads Test::Builder)"
  	}
  }
  
  use Test::Builder;
  use Test::Tester::CaptureRunner;
  use Test::Tester::Delegate;
  
  require Exporter;
  
  use vars qw( @ISA @EXPORT );
  
  our $VERSION = '1.302120';
  
  @EXPORT = qw( run_tests check_tests check_test cmp_results show_space );
  @ISA = qw( Exporter );
  
  my $Test = Test::Builder->new;
  my $Capture = Test::Tester::Capture->new;
  my $Delegator = Test::Tester::Delegate->new;
  $Delegator->{Object} = $Test;
  
  my $runner = Test::Tester::CaptureRunner->new;
  
  my $want_space = $ENV{TESTTESTERSPACE};
  
  sub show_space
  {
  	$want_space = 1;
  }
  
  my $colour = '';
  my $reset = '';
  
  if (my $want_colour = $ENV{TESTTESTERCOLOUR} || $ENV{TESTTESTERCOLOR})
  {
  	if (eval { require Term::ANSIColor; 1 })
  	{
  		eval { require Win32::Console::ANSI } if 'MSWin32' eq $^O;  # support color on windows platforms
  		my ($f, $b) = split(",", $want_colour);
  		$colour = Term::ANSIColor::color($f).Term::ANSIColor::color("on_$b");
  		$reset = Term::ANSIColor::color("reset");
  	}
  
  }
  
  sub new_new
  {
  	return $Delegator;
  }
  
  sub capture
  {
  	return Test::Tester::Capture->new;
  }
  
  sub fh
  {
  	# experiment with capturing output, I don't like it
  	$runner = Test::Tester::FHRunner->new;
  
  	return $Test;
  }
  
  sub find_run_tests
  {
  	my $d = 1;
  	my $found = 0;
  	while ((not $found) and (my ($sub) = (caller($d))[3]) )
  	{
  #		print "$d: $sub\n";
  		$found = ($sub eq "Test::Tester::run_tests");
  		$d++;
  	}
  
  #	die "Didn't find 'run_tests' in caller stack" unless $found;
  	return $d;
  }
  
  sub run_tests
  {
  	local($Delegator->{Object}) = $Capture;
  
  	$runner->run_tests(@_);
  
  	return ($runner->get_premature, $runner->get_results);
  }
  
  sub check_test
  {
  	my $test = shift;
  	my $expect = shift;
  	my $name = shift;
  	$name = "" unless defined($name);
  
  	@_ = ($test, [$expect], $name);
  	goto &check_tests;
  }
  
  sub check_tests
  {
  	my $test = shift;
  	my $expects = shift;
  	my $name = shift;
  	$name = "" unless defined($name);
  
  	my ($prem, @results) = eval { run_tests($test, $name) };
  
  	$Test->ok(! $@, "Test '$name' completed") || $Test->diag($@);
  	$Test->ok(! length($prem), "Test '$name' no premature diagnostication") ||
  		$Test->diag("Before any testing anything, your tests said\n$prem");
  
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	cmp_results(\@results, $expects, $name);
  	return ($prem, @results);
  }
  
  sub cmp_field
  {
  	my ($result, $expect, $field, $desc) = @_;
  
  	if (defined $expect->{$field})
  	{
  		$Test->is_eq($result->{$field}, $expect->{$field},
  			"$desc compare $field");
  	}
  }
  
  sub cmp_result
  {
  	my ($result, $expect, $name) = @_;
  
  	my $sub_name = $result->{name};
  	$sub_name = "" unless defined($name);
  
  	my $desc = "subtest '$sub_name' of '$name'";
  
  	{
  		local $Test::Builder::Level = $Test::Builder::Level + 1;
  
  		cmp_field($result, $expect, "ok", $desc);
  
  		cmp_field($result, $expect, "actual_ok", $desc);
  
  		cmp_field($result, $expect, "type", $desc);
  
  		cmp_field($result, $expect, "reason", $desc);
  
  		cmp_field($result, $expect, "name", $desc);
  	}
  
  	# if we got no depth then default to 1
  	my $depth = 1;
  	if (exists $expect->{depth})
  	{
  		$depth = $expect->{depth};
  	}
  
  	# if depth was explicitly undef then don't test it
  	if (defined $depth)
  	{
  		$Test->is_eq($result->{depth}, $depth, "checking depth") ||
  			$Test->diag('You need to change $Test::Builder::Level');
  	}
  
  	if (defined(my $exp = $expect->{diag}))
  	{
  
          my $got = '';
          if (ref $exp eq 'Regexp') {
  
              if (not $Test->like($result->{diag}, $exp,
                  "subtest '$sub_name' of '$name' compare diag"))
              {
                  $got = $result->{diag};
              }
  
          } else {
  
              # if there actually is some diag then put a \n on the end if it's not
              # there already
              $exp .= "\n" if (length($exp) and $exp !~ /\n$/);
  
              if (not $Test->ok($result->{diag} eq $exp,
      			"subtest '$sub_name' of '$name' compare diag"))
              {
                  $got = $result->{diag};
              }
          }
  
          if ($got) {
      		my $glen = length($got);
      		my $elen = length($exp);
      		for ($got, $exp)
      		{
      			my @lines = split("\n", $_);
       			$_ = join("\n", map {
      				if ($want_space)
      				{
      					$_ = $colour.escape($_).$reset;
      				}
      				else
      				{
      					"'$colour$_$reset'"
      				}
      			} @lines);
      		}
  
          	$Test->diag(<<EOM);
  Got diag ($glen bytes):
  $got
  Expected diag ($elen bytes):
  $exp
  EOM
          }
  	}
  }
  
  sub escape
  {
  	my $str = shift;
  	my $res = '';
  	for my $char (split("", $str))
  	{
  		my $c = ord($char);
  		if(($c>32 and $c<125) or $c == 10)
  		{
  			$res .= $char;
  		}
  		else
  		{
  			$res .= sprintf('\x{%x}', $c)
  		}
  	}
  	return $res;
  }
  
  sub cmp_results
  {
  	my ($results, $expects, $name) = @_;
  
  	$Test->is_num(scalar @$results, scalar @$expects, "Test '$name' result count");
  
  	for (my $i = 0; $i < @$expects; $i++)
  	{
  		my $expect = $expects->[$i];
  		my $result = $results->[$i];
  
  		local $Test::Builder::Level = $Test::Builder::Level + 1;
  		cmp_result($result, $expect, $name);
  	}
  }
  
  ######## nicked from Test::More
  sub plan {
  	my(@plan) = @_;
  
  	my $caller = caller;
  
  	$Test->exported_to($caller);
  
  	my @imports = ();
  	foreach my $idx (0..$#plan) {
  		if( $plan[$idx] eq 'import' ) {
  			my($tag, $imports) = splice @plan, $idx, 2;
  			@imports = @$imports;
  			last;
  		}
  	}
  
  	$Test->plan(@plan);
  
  	__PACKAGE__->_export_to_level(1, __PACKAGE__, @imports);
  }
  
  sub import {
  	my($class) = shift;
  		{
  			no warnings 'redefine';
  			*Test::Builder::new = \&new_new;
  		}
  	goto &plan;
  }
  
  sub _export_to_level
  {
          my $pkg = shift;
  	my $level = shift;
  	(undef) = shift;	# redundant arg
  	my $callpkg = caller($level);
  	$pkg->export($callpkg, @_);
  }
  
  
  ############
  
  1;
  
  __END__
  
  =head1 NAME
  
  Test::Tester - Ease testing test modules built with Test::Builder
  
  =head1 SYNOPSIS
  
    use Test::Tester tests => 6;
  
    use Test::MyStyle;
  
    check_test(
      sub {
        is_mystyle_eq("this", "that", "not eq");
      },
      {
        ok => 0, # expect this to fail
        name => "not eq",
        diag => "Expected: 'this'\nGot: 'that'",
      }
    );
  
  or
  
    use Test::Tester tests => 6;
  
    use Test::MyStyle;
  
    check_test(
      sub {
        is_mystyle_qr("this", "that", "not matching");
      },
      {
        ok => 0, # expect this to fail
        name => "not matching",
        diag => qr/Expected: 'this'\s+Got: 'that'/,
      }
    );
  
  or
  
    use Test::Tester;
  
    use Test::More tests => 3;
    use Test::MyStyle;
  
    my ($premature, @results) = run_tests(
      sub {
        is_database_alive("dbname");
      }
    );
  
    # now use Test::More::like to check the diagnostic output
  
    like($results[0]->{diag}, "/^Database ping took \\d+ seconds$"/, "diag");
  
  =head1 DESCRIPTION
  
  If you have written a test module based on Test::Builder then Test::Tester
  allows you to test it with the minimum of effort.
  
  =head1 HOW TO USE (THE EASY WAY)
  
  From version 0.08 Test::Tester no longer requires you to included anything
  special in your test modules. All you need to do is
  
    use Test::Tester;
  
  in your test script B<before> any other Test::Builder based modules and away
  you go.
  
  Other modules based on Test::Builder can be used to help with the
  testing.  In fact you can even use functions from your module to test
  other functions from the same module (while this is possible it is
  probably not a good idea, if your module has bugs, then
  using it to test itself may give the wrong answers).
  
  The easiest way to test is to do something like
  
    check_test(
      sub { is_mystyle_eq("this", "that", "not eq") },
      {
        ok => 0, # we expect the test to fail
        name => "not eq",
        diag => "Expected: 'this'\nGot: 'that'",
      }
    );
  
  this will execute the is_mystyle_eq test, capturing it's results and
  checking that they are what was expected.
  
  You may need to examine the test results in a more flexible way, for
  example, the diagnostic output may be quite long or complex or it may involve
  something that you cannot predict in advance like a timestamp. In this case
  you can get direct access to the test results:
  
    my ($premature, @results) = run_tests(
      sub {
        is_database_alive("dbname");
      }
    );
  
    like($result[0]->{diag}, "/^Database ping took \\d+ seconds$"/, "diag");
  
  or
  
    check_test(
      sub { is_mystyle_qr("this", "that", "not matching") },
      {
        ok => 0, # we expect the test to fail
        name => "not matching",
        diag => qr/Expected: 'this'\s+Got: 'that'/,
      }
    );
  
  We cannot predict how long the database ping will take so we use
  Test::More's like() test to check that the diagnostic string is of the right
  form.
  
  =head1 HOW TO USE (THE HARD WAY)
  
  I<This is here for backwards compatibility only>
  
  Make your module use the Test::Tester::Capture object instead of the
  Test::Builder one. How to do this depends on your module but assuming that
  your module holds the Test::Builder object in $Test and that all your test
  routines access it through $Test then providing a function something like this
  
    sub set_builder
    {
      $Test = shift;
    }
  
  should allow your test scripts to do
  
    Test::YourModule::set_builder(Test::Tester->capture);
  
  and after that any tests inside your module will captured.
  
  =head1 TEST RESULTS
  
  The result of each test is captured in a hash. These hashes are the same as
  the hashes returned by Test::Builder->details but with a couple of extra
  fields.
  
  These fields are documented in L<Test::Builder> in the details() function
  
  =over 2
  
  =item ok
  
  Did the test pass?
  
  =item actual_ok
  
  Did the test really pass? That is, did the pass come from
  Test::Builder->ok() or did it pass because it was a TODO test?
  
  =item name
  
  The name supplied for the test.
  
  =item type
  
  What kind of test? Possibilities include, skip, todo etc. See
  L<Test::Builder> for more details.
  
  =item reason
  
  The reason for the skip, todo etc. See L<Test::Builder> for more details.
  
  =back
  
  These fields are exclusive to Test::Tester.
  
  =over 2
  
  =item diag
  
  Any diagnostics that were output for the test. This only includes
  diagnostics output B<after> the test result is declared.
  
  Note that Test::Builder ensures that any diagnostics end in a \n and
  it in earlier versions of Test::Tester it was essential that you have
  the final \n in your expected diagnostics. From version 0.10 onward,
  Test::Tester will add the \n if you forgot it. It will not add a \n if
  you are expecting no diagnostics. See below for help tracking down
  hard to find space and tab related problems.
  
  =item depth
  
  This allows you to check that your test module is setting the correct value
  for $Test::Builder::Level and thus giving the correct file and line number
  when a test fails. It is calculated by looking at caller() and
  $Test::Builder::Level. It should count how many subroutines there are before
  jumping into the function you are testing. So for example in
  
    run_tests( sub { my_test_function("a", "b") } );
  
  the depth should be 1 and in
  
    sub deeper { my_test_function("a", "b") }
  
    run_tests(sub { deeper() });
  
  depth should be 2, that is 1 for the sub {} and one for deeper(). This
  might seem a little complex but if your tests look like the simple
  examples in this doc then you don't need to worry as the depth will
  always be 1 and that's what Test::Tester expects by default.
  
  B<Note>: if you do not specify a value for depth in check_test() then it
  automatically compares it against 1, if you really want to skip the depth
  test then pass in undef.
  
  B<Note>: depth will not be correctly calculated for tests that run from a
  signal handler or an END block or anywhere else that hides the call stack.
  
  =back
  
  Some of Test::Tester's functions return arrays of these hashes, just
  like Test::Builder->details. That is, the hash for the first test will
  be array element 1 (not 0). Element 0 will not be a hash it will be a
  string which contains any diagnostic output that came before the first
  test. This should usually be empty, if it's not, it means something
  output diagnostics before any test results showed up.
  
  =head1 SPACES AND TABS
  
  Appearances can be deceptive, especially when it comes to emptiness. If you
  are scratching your head trying to work out why Test::Tester is saying that
  your diagnostics are wrong when they look perfectly right then the answer is
  probably whitespace. From version 0.10 on, Test::Tester surrounds the
  expected and got diag values with single quotes to make it easier to spot
  trailing whitespace. So in this example
  
    # Got diag (5 bytes):
    # 'abcd '
    # Expected diag (4 bytes):
    # 'abcd'
  
  it is quite clear that there is a space at the end of the first string.
  Another way to solve this problem is to use colour and inverse video on an
  ANSI terminal, see below COLOUR below if you want this.
  
  Unfortunately this is sometimes not enough, neither colour nor quotes will
  help you with problems involving tabs, other non-printing characters and
  certain kinds of problems inherent in Unicode. To deal with this, you can
  switch Test::Tester into a mode whereby all "tricky" characters are shown as
  \{xx}. Tricky characters are those with ASCII code less than 33 or higher
  than 126. This makes the output more difficult to read but much easier to
  find subtle differences between strings. To turn on this mode either call
  C<show_space()> in your test script or set the C<TESTTESTERSPACE> environment
  variable to be a true value. The example above would then look like
  
    # Got diag (5 bytes):
    # abcd\x{20}
    # Expected diag (4 bytes):
    # abcd
  
  =head1 COLOUR
  
  If you prefer to use colour as a means of finding tricky whitespace
  characters then you can set the C<TESTTESTCOLOUR> environment variable to a
  comma separated pair of colours, the first for the foreground, the second
  for the background. For example "white,red" will print white text on a red
  background. This requires the Term::ANSIColor module. You can specify any
  colour that would be acceptable to the Term::ANSIColor::color function.
  
  If you spell colour differently, that's no problem. The C<TESTTESTERCOLOR>
  variable also works (if both are set then the British spelling wins out).
  
  =head1 EXPORTED FUNCTIONS
  
  =head3 ($premature, @results) = run_tests(\&test_sub)
  
  \&test_sub is a reference to a subroutine.
  
  run_tests runs the subroutine in $test_sub and captures the results of any
  tests inside it. You can run more than 1 test inside this subroutine if you
  like.
  
  $premature is a string containing any diagnostic output from before
  the first test.
  
  @results is an array of test result hashes.
  
  =head3 cmp_result(\%result, \%expect, $name)
  
  \%result is a ref to a test result hash.
  
  \%expect is a ref to a hash of expected values for the test result.
  
  cmp_result compares the result with the expected values. If any differences
  are found it outputs diagnostics. You may leave out any field from the
  expected result and cmp_result will not do the comparison of that field.
  
  =head3 cmp_results(\@results, \@expects, $name)
  
  \@results is a ref to an array of test results.
  
  \@expects is a ref to an array of hash refs.
  
  cmp_results checks that the results match the expected results and if any
  differences are found it outputs diagnostics. It first checks that the
  number of elements in \@results and \@expects is the same. Then it goes
  through each result checking it against the expected result as in
  cmp_result() above.
  
  =head3 ($premature, @results) = check_tests(\&test_sub, \@expects, $name)
  
  \&test_sub is a reference to a subroutine.
  
  \@expect is a ref to an array of hash refs which are expected test results.
  
  check_tests combines run_tests and cmp_tests into a single call. It also
  checks if the tests died at any stage.
  
  It returns the same values as run_tests, so you can further examine the test
  results if you need to.
  
  =head3 ($premature, @results) = check_test(\&test_sub, \%expect, $name)
  
  \&test_sub is a reference to a subroutine.
  
  \%expect is a ref to an hash of expected values for the test result.
  
  check_test is a wrapper around check_tests. It combines run_tests and
  cmp_tests into a single call, checking if the test died. It assumes
  that only a single test is run inside \&test_sub and include a test to
  make sure this is true.
  
  It returns the same values as run_tests, so you can further examine the test
  results if you need to.
  
  =head3 show_space()
  
  Turn on the escaping of characters as described in the SPACES AND TABS
  section.
  
  =head1 HOW IT WORKS
  
  Normally, a test module (let's call it Test:MyStyle) calls
  Test::Builder->new to get the Test::Builder object. Test::MyStyle calls
  methods on this object to record information about test results. When
  Test::Tester is loaded, it replaces Test::Builder's new() method with one
  which returns a Test::Tester::Delegate object. Most of the time this object
  behaves as the real Test::Builder object. Any methods that are called are
  delegated to the real Test::Builder object so everything works perfectly.
  However once we go into test mode, the method calls are no longer passed to
  the real Test::Builder object, instead they go to the Test::Tester::Capture
  object. This object seems exactly like the real Test::Builder object,
  except, instead of outputting test results and diagnostics, it just records
  all the information for later analysis.
  
  =head1 CAVEATS
  
  Support for calling Test::Builder->note is minimal. It's implemented
  as an empty stub, so modules that use it will not crash but the calls
  are not recorded for testing purposes like the others. Patches
  welcome.
  
  =head1 SEE ALSO
  
  L<Test::Builder> the source of testing goodness. L<Test::Builder::Tester>
  for an alternative approach to the problem tackled by Test::Tester -
  captures the strings output by Test::Builder. This means you cannot get
  separate access to the individual pieces of information and you must predict
  B<exactly> what your test will output.
  
  =head1 AUTHOR
  
  This module is copyright 2005 Fergal Daly <fergal@esatclear.ie>, some parts
  are based on other people's work.
  
  Plan handling lifted from Test::More. written by Michael G Schwern
  <schwern@pobox.com>.
  
  Test::Tester::Capture is a cut down and hacked up version of Test::Builder.
  Test::Builder was written by chromatic <chromatic@wgz.org> and Michael G
  Schwern <schwern@pobox.com>.
  
  =head1 LICENSE
  
  Under the same license as Perl itself
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
TEST_TESTER

$fatpacked{"Test/Tester/Capture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_CAPTURE';
  use strict;
  
  package Test::Tester::Capture;
  
  our $VERSION = '1.302120';
  
  
  use Test::Builder;
  
  use vars qw( @ISA );
  @ISA = qw( Test::Builder );
  
  # Make Test::Tester::Capture thread-safe for ithreads.
  BEGIN {
  	use Config;
  	if( $] >= 5.008 && $Config{useithreads} ) {
  		require threads::shared;
  		threads::shared->import;
  	}
  	else {
  		*share = sub { 0 };
  		*lock  = sub { 0 };
  	}
  }
  
  my $Curr_Test = 0;      share($Curr_Test);
  my @Test_Results = ();  share(@Test_Results);
  my $Prem_Diag = {diag => ""};	 share($Curr_Test);
  
  sub new
  {
    # Test::Tester::Capgture::new used to just return __PACKAGE__
    # because Test::Builder::new enforced it's singleton nature by
    # return __PACKAGE__. That has since changed, Test::Builder::new now
    # returns a blessed has and around version 0.78, Test::Builder::todo
    # started wanting to modify $self. To cope with this, we now return
    # a blessed hash. This is a short-term hack, the correct thing to do
    # is to detect which style of Test::Builder we're dealing with and
    # act appropriately.
  
    my $class = shift;
    return bless {}, $class;
  }
  
  sub ok {
  	my($self, $test, $name) = @_;
  
  	my $ctx = $self->ctx;
  
  	# $test might contain an object which we don't want to accidentally
  	# store, so we turn it into a boolean.
  	$test = $test ? 1 : 0;
  
  	lock $Curr_Test;
  	$Curr_Test++;
  
  	my($pack, $file, $line) = $self->caller;
  
  	my $todo = $self->todo();
  
  	my $result = {};
  	share($result);
  
  	unless( $test ) {
  		@$result{ 'ok', 'actual_ok' } = ( ( $todo ? 1 : 0 ), 0 );
  	}
  	else {
  		@$result{ 'ok', 'actual_ok' } = ( 1, $test );
  	}
  
  	if( defined $name ) {
  		$name =~ s|#|\\#|g;	 # # in a name can confuse Test::Harness.
  		$result->{name} = $name;
  	}
  	else {
  		$result->{name} = '';
  	}
  
  	if( $todo ) {
  		my $what_todo = $todo;
  		$result->{reason} = $what_todo;
  		$result->{type}   = 'todo';
  	}
  	else {
  		$result->{reason} = '';
  		$result->{type}   = '';
  	}
  
  	$Test_Results[$Curr_Test-1] = $result;
  
  	unless( $test ) {
  		my $msg = $todo ? "Failed (TODO)" : "Failed";
  		$result->{fail_diag} = ("	$msg test ($file at line $line)\n");
  	} 
  
  	$result->{diag} = "";
  	$result->{_level} = $Test::Builder::Level;
  	$result->{_depth} = Test::Tester::find_run_tests();
  
  	$ctx->release;
  
  	return $test ? 1 : 0;
  }
  
  sub skip {
  	my($self, $why) = @_;
  	$why ||= '';
  
  	my $ctx = $self->ctx;
  
  	lock($Curr_Test);
  	$Curr_Test++;
  
  	my %result;
  	share(%result);
  	%result = (
  		'ok'	  => 1,
  		actual_ok => 1,
  		name	  => '',
  		type	  => 'skip',
  		reason	=> $why,
  		diag    => "",
  		_level   => $Test::Builder::Level,
  		_depth => Test::Tester::find_run_tests(),
  	);
  	$Test_Results[$Curr_Test-1] = \%result;
  
  	$ctx->release;
  	return 1;
  }
  
  sub todo_skip {
  	my($self, $why) = @_;
  	$why ||= '';
  
  	my $ctx = $self->ctx;
  
  	lock($Curr_Test);
  	$Curr_Test++;
  
  	my %result;
  	share(%result);
  	%result = (
  		'ok'	  => 1,
  		actual_ok => 0,
  		name	  => '',
  		type	  => 'todo_skip',
  		reason	=> $why,
  		diag    => "",
  		_level   => $Test::Builder::Level,
  		_depth => Test::Tester::find_run_tests(),
  	);
  
  	$Test_Results[$Curr_Test-1] = \%result;
  
  	$ctx->release;
  	return 1;
  }
  
  sub diag {
  	my($self, @msgs) = @_;
  	return unless @msgs;
  
  	# Prevent printing headers when compiling (i.e. -c)
  	return if $^C;
  
  	my $ctx = $self->ctx;
  
  	# Escape each line with a #.
  	foreach (@msgs) {
  		$_ = 'undef' unless defined;
  	}
  
  	push @msgs, "\n" unless $msgs[-1] =~ /\n\Z/;
  
  	my $result = $Curr_Test ? $Test_Results[$Curr_Test - 1] : $Prem_Diag;
  
  	$result->{diag} .= join("", @msgs);
  
  	$ctx->release;
  	return 0;
  }
  
  sub details {
  	return @Test_Results;
  }
  
  
  # Stub. Feel free to send me a patch to implement this.
  sub note {
  }
  
  sub explain {
  	return Test::Builder::explain(@_);
  }
  
  sub premature
  {
  	return $Prem_Diag->{diag};
  }
  
  sub current_test
  {
  	if (@_ > 1)
  	{
  		die "Don't try to change the test number!";
  	}
  	else
  	{
  		return $Curr_Test;
  	}
  }
  
  sub reset
  {
  	$Curr_Test = 0;
  	@Test_Results = ();
  	$Prem_Diag = {diag => ""};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Test::Tester::Capture - Help testing test modules built with Test::Builder
  
  =head1 DESCRIPTION
  
  This is a subclass of Test::Builder that overrides many of the methods so
  that they don't output anything. It also keeps track of it's own set of test
  results so that you can use Test::Builder based modules to perform tests on
  other Test::Builder based modules.
  
  =head1 AUTHOR
  
  Most of the code here was lifted straight from Test::Builder and then had
  chunks removed by Fergal Daly <fergal@esatclear.ie>.
  
  =head1 LICENSE
  
  Under the same license as Perl itself
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
TEST_TESTER_CAPTURE

$fatpacked{"Test/Tester/CaptureRunner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_CAPTURERUNNER';
  # $Header: /home/fergal/my/cvs/Test-Tester/lib/Test/Tester/CaptureRunner.pm,v 1.3 2003/03/05 01:07:55 fergal Exp $
  use strict;
  
  package Test::Tester::CaptureRunner;
  
  our $VERSION = '1.302120';
  
  
  use Test::Tester::Capture;
  require Exporter;
  
  sub new
  {
  	my $pkg = shift;
  	my $self = bless {}, $pkg;
  	return $self;
  }
  
  sub run_tests
  {
  	my $self = shift;
  
  	my $test = shift;
  
  	capture()->reset;
  
  	$self->{StartLevel} = $Test::Builder::Level;
  	&$test();
  }
  
  sub get_results
  {
  	my $self = shift;
  	my @results = capture()->details;
  
  	my $start = $self->{StartLevel};
  	foreach my $res (@results)
  	{
  		next if defined $res->{depth};
  		my $depth = $res->{_depth} - $res->{_level} - $start - 3;
  #		print "my $depth = $res->{_depth} - $res->{_level} - $start - 1\n";
  		$res->{depth} = $depth;
  	}
  
  	return @results;
  }
  
  sub get_premature
  {
  	return capture()->premature;
  }
  
  sub capture
  {
  	return Test::Tester::Capture->new;
  }
  
  __END__
  
  =head1 NAME
  
  Test::Tester::CaptureRunner - Help testing test modules built with Test::Builder
  
  =head1 DESCRIPTION
  
  This stuff if needed to allow me to play with other ways of monitoring the
  test results.
  
  =head1 AUTHOR
  
  Copyright 2003 by Fergal Daly <fergal@esatclear.ie>.
  
  =head1 LICENSE
  
  Under the same license as Perl itself
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
TEST_TESTER_CAPTURERUNNER

$fatpacked{"Test/Tester/Delegate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_DELEGATE';
  use strict;
  use warnings;
  
  package Test::Tester::Delegate;
  
  our $VERSION = '1.302120';
  
  use Scalar::Util();
  
  use vars '$AUTOLOAD';
  
  sub new
  {
  	my $pkg = shift;
  
  	my $obj = shift;
  	my $self = bless {}, $pkg;
  
  	return $self;
  }
  
  sub AUTOLOAD
  {
  	my ($sub) = $AUTOLOAD =~ /.*::(.*?)$/;
  
  	return if $sub eq "DESTROY";
  
  	my $obj = $_[0]->{Object};
  
  	my $ref = $obj->can($sub);
  	shift(@_);
  	unshift(@_, $obj);
  	goto &$ref;
  }
  
  sub can {
  	my $this = shift;
  	my ($sub) = @_;
  
  	return $this->{Object}->can($sub) if Scalar::Util::blessed($this);
  
  	return $this->SUPER::can(@_);
  }
  
  1;
TEST_TESTER_DELEGATE

$fatpacked{"Test/use/ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_USE_OK';
  package Test::use::ok;
  use 5.005;
  
  our $VERSION = '1.302120';
  
  
  __END__
  
  =head1 NAME
  
  Test::use::ok - Alternative to Test::More::use_ok
  
  =head1 SYNOPSIS
  
      use ok 'Some::Module';
  
  =head1 DESCRIPTION
  
  According to the B<Test::More> documentation, it is recommended to run
  C<use_ok()> inside a C<BEGIN> block, so functions are exported at
  compile-time and prototypes are properly honored.
  
  That is, instead of writing this:
  
      use_ok( 'Some::Module' );
      use_ok( 'Other::Module' );
  
  One should write this:
  
      BEGIN { use_ok( 'Some::Module' ); }
      BEGIN { use_ok( 'Other::Module' ); }
  
  However, people often either forget to add C<BEGIN>, or mistakenly group
  C<use_ok> with other tests in a single C<BEGIN> block, which can create subtle
  differences in execution order.
  
  With this module, simply change all C<use_ok> in test scripts to C<use ok>,
  and they will be executed at C<BEGIN> time.  The explicit space after C<use>
  makes it clear that this is a single compile-time action.
  
  =head1 SEE ALSO
  
  L<Test::More>
  
  =head1 MAINTAINER
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =encoding utf8
  
  =head1 CC0 1.0 Universal
  
  To the extent possible under law,  has waived all copyright and related
  or neighboring rights to L<Test-use-ok>.
  
  This work is published from Taiwan.
  
  L<http://creativecommons.org/publicdomain/zero/1.0>
  
  =cut
TEST_USE_OK

$fatpacked{"Test2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2';
  package Test2;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2 - Framework for writing test tools that all work together.
  
  =head1 DESCRIPTION
  
  Test2 is a new testing framework produced by forking L<Test::Builder>,
  completely refactoring it, adding many new features and capabilities.
  
  =head2 WHAT IS NEW?
  
  =over 4
  
  =item Easier to test new testing tools.
  
  From the beginning Test2 was built with introspection capabilities. With
  Test::Builder it was difficult at best to capture test tool output for
  verification. Test2 Makes it easy with C<Test2::API::intercept()>.
  
  =item Better diagnostics capabilities.
  
  Test2 uses an L<Test2::API::Context> object to track filename, line number, and
  tool details. This object greatly simplifies tracking for where errors should
  be reported.
  
  =item Event driven.
  
  Test2 based tools produce events which get passed through a processing system
  before being output by a formatter. This event system allows for rich plugin
  and extension support.
  
  =item More complete API.
  
  Test::Builder only provided a handful of methods for generating lines of TAP.
  Test2 took inventory of everything people were doing with Test::Builder that
  required hacking it up. Test2 made public API functions for nearly all the
  desired functionality people didn't previously have.
  
  =item Support for output other than TAP.
  
  Test::Builder assumed everything would end up as TAP. Test2 makes no such
  assumption. Test2 provides ways for you to specify alternative and custom
  formatters.
  
  =item Subtest implementation is more sane.
  
  The Test::Builder implementation of subtests was certifiably insane. Test2 uses
  a stacked event hub system that greatly improves how subtests are implemented.
  
  =item Support for threading/forking.
  
  Test2 support for forking and threading can be turned on using L<Test2::IPC>.
  Once turned on threading and forking operate sanely and work as one would
  expect.
  
  =back
  
  =head1 GETTING STARTED
  
  If you are interested in writing tests using new tools then you should look at
  L<Test2::Suite>. L<Test2::Suite> is a separate cpan distribution that contains
  many tools implemented on Test2.
  
  If you are interested in writing new tools you should take a look at
  L<Test2::API> first.
  
  =head1 NAMESPACE LAYOUT
  
  This describes the namespace layout for the Test2 ecosystem. Not all the
  namespaces listed here are part of the Test2 distribution, some are implemented
  in L<Test2::Suite>.
  
  =head2 Test2::Tools::
  
  This namespace is for sets of tools. Modules in this namespace should export
  tools like C<ok()> and C<is()>. Most things written for Test2 should go here.
  Modules in this namespace B<MUST NOT> export subs from other tools. See the
  L</Test2::Bundle::> namespace if you want to do that.
  
  =head2 Test2::Plugin::
  
  This namespace is for plugins. Plugins are modules that change or enhance the
  behavior of Test2. An example of a plugin is a module that sets the encoding to
  utf8 globally. Another example is a module that causes a bail-out event after
  the first test failure.
  
  =head2 Test2::Bundle::
  
  This namespace is for bundles of tools and plugins. Loading one of these may
  load multiple tools and plugins. Modules in this namespace should not implement
  tools directly. In general modules in this namespace should load tools and
  plugins, then re-export things into the consumers namespace.
  
  =head2 Test2::Require::
  
  This namespace is for modules that cause a test to be skipped when conditions
  do not allow it to run. Examples would be modules that skip the test on older
  perls, or when non-essential modules have not been installed.
  
  =head2 Test2::Formatter::
  
  Formatters live under this namespace. L<Test2::Formatter::TAP> is the only
  formatter currently. It is acceptable for third party distributions to create
  new formatters under this namespace.
  
  =head2 Test2::Event::
  
  Events live under this namespace. It is considered acceptable for third party
  distributions to add new event types in this namespace.
  
  =head2 Test2::Hub::
  
  Hub subclasses (and some hub utility objects) live under this namespace. It is
  perfectly reasonable for third party distributions to add new hub subclasses in
  this namespace.
  
  =head2 Test2::IPC::
  
  The IPC subsystem lives in this namespace. There are not many good reasons to
  add anything to this namespace, with exception of IPC drivers.
  
  =head3 Test2::IPC::Driver::
  
  IPC drivers live in this namespace. It is fine to create new IPC drivers and to
  put them in this namespace.
  
  =head2 Test2::Util::
  
  This namespace is for general utilities used by testing tools. Please be
  considerate when adding new modules to this namespace.
  
  =head2 Test2::API::
  
  This is for Test2 API and related packages.
  
  =head2 Test2::
  
  The Test2:: namespace is intended for extensions and frameworks. Tools,
  Plugins, etc should not go directly into this namespace. However extensions
  that are used to build tools and plugins may go here.
  
  In short: If the module exports anything that should be run directly by a test
  script it should probably NOT go directly into C<Test2::XXX>.
  
  =head1 SEE ALSO
  
  L<Test2::API> - Primary API functions.
  
  L<Test2::API::Context> - Detailed documentation of the context object.
  
  L<Test2::IPC> - The IPC system used for threading/fork support.
  
  L<Test2::Formatter> - Formatters such as TAP live here.
  
  L<Test2::Event> - Events live in this namespace.
  
  L<Test2::Hub> - All events eventually funnel through a hub. Custom hubs are how
  C<intercept()> and C<run_subtest()> are implemented.
  
  =head1 CONTACTING US
  
  Many Test2 developers and users lurk on L<irc://irc.perl.org/#perl-qa> and
  L<irc://irc.perl.org/#toolchain>. We also have a slack team that can be joined
  by anyone with an C<@cpan.org> email address L<https://perl-test2.slack.com/>
  If you do not have an C<@cpan.org> email you can ask for a slack invite by
  emailing Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2

$fatpacked{"Test2/API.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API';
  package Test2::API;
  use strict;
  use warnings;
  
  use Test2::Util qw/USE_THREADS/;
  
  BEGIN {
      $ENV{TEST_ACTIVE} ||= 1;
      $ENV{TEST2_ACTIVE} = 1;
  }
  
  our $VERSION = '1.302120';
  
  
  my $INST;
  my $ENDING = 0;
  sub test2_set_is_end { ($ENDING) = @_ ? @_ : (1) }
  sub test2_get_is_end { $ENDING }
  
  use Test2::API::Instance(\$INST);
  
  # Set the exit status
  END {
      test2_set_is_end(); # See gh #16
      $INST->set_exit();
  }
  
  sub CLONE {
      my $init = test2_init_done();
      my $load = test2_load_done();
  
      return if $init && $load;
  
      require Carp;
      Carp::croak "Test2 must be fully loaded before you start a new thread!\n";
  }
  
  # See gh #16
  {
      no warnings;
      INIT { eval 'END { test2_set_is_end() }; 1' or die $@ }
  }
  
  BEGIN {
      no warnings 'once';
      if($] ge '5.014' || $ENV{T2_CHECK_DEPTH} || $Test2::API::DO_DEPTH_CHECK) {
          *DO_DEPTH_CHECK = sub() { 1 };
      }
      else {
          *DO_DEPTH_CHECK = sub() { 0 };
      }
  }
  
  use Test2::EventFacet::Trace();
  use Test2::Util::Trace(); # Legacy
  
  use Test2::Hub::Subtest();
  use Test2::Hub::Interceptor();
  use Test2::Hub::Interceptor::Terminator();
  
  use Test2::Event::Ok();
  use Test2::Event::Diag();
  use Test2::Event::Note();
  use Test2::Event::Plan();
  use Test2::Event::Bail();
  use Test2::Event::Exception();
  use Test2::Event::Waiting();
  use Test2::Event::Skip();
  use Test2::Event::Subtest();
  
  use Carp qw/carp croak confess/;
  use Scalar::Util qw/blessed weaken/;
  use Test2::Util qw/get_tid clone_io pkg_to_file/;
  
  our @EXPORT_OK = qw{
      context release
      context_do
      no_context
      intercept intercept_deep
      run_subtest
  
      test2_init_done
      test2_load_done
      test2_load
      test2_start_preload
      test2_stop_preload
      test2_in_preload
  
      test2_set_is_end
      test2_get_is_end
  
      test2_pid
      test2_tid
      test2_stack
      test2_no_wait
      test2_ipc_wait_enable
      test2_ipc_wait_disable
      test2_ipc_wait_enabled
  
      test2_add_callback_context_aquire
      test2_add_callback_context_acquire
      test2_add_callback_context_init
      test2_add_callback_context_release
      test2_add_callback_exit
      test2_add_callback_post_load
      test2_add_callback_pre_subtest
      test2_list_context_aquire_callbacks
      test2_list_context_acquire_callbacks
      test2_list_context_init_callbacks
      test2_list_context_release_callbacks
      test2_list_exit_callbacks
      test2_list_post_load_callbacks
      test2_list_pre_subtest_callbacks
  
      test2_ipc
      test2_has_ipc
      test2_ipc_drivers
      test2_ipc_add_driver
      test2_ipc_polling
      test2_ipc_disable_polling
      test2_ipc_enable_polling
      test2_ipc_get_pending
      test2_ipc_set_pending
      test2_ipc_get_timeout
      test2_ipc_set_timeout
      test2_ipc_enable_shm
  
      test2_formatter
      test2_formatters
      test2_formatter_add
      test2_formatter_set
  
      test2_stdout
      test2_stderr
      test2_reset_io
  };
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  my $STACK       = $INST->stack;
  my $CONTEXTS    = $INST->contexts;
  my $INIT_CBS    = $INST->context_init_callbacks;
  my $ACQUIRE_CBS = $INST->context_acquire_callbacks;
  
  my $STDOUT = clone_io(\*STDOUT);
  my $STDERR = clone_io(\*STDERR);
  sub test2_stdout { $STDOUT ||= clone_io(\*STDOUT) }
  sub test2_stderr { $STDERR ||= clone_io(\*STDERR) }
  
  sub test2_post_preload_reset {
      test2_reset_io();
      $INST->post_preload_reset;
  }
  
  sub test2_reset_io {
      $STDOUT = clone_io(\*STDOUT);
      $STDERR = clone_io(\*STDERR);
  }
  
  sub test2_init_done { $INST->finalized }
  sub test2_load_done { $INST->loaded }
  
  sub test2_load          { $INST->load }
  sub test2_start_preload { $ENV{T2_IN_PRELOAD} = 1; $INST->start_preload }
  sub test2_stop_preload  { $ENV{T2_IN_PRELOAD} = 0; $INST->stop_preload }
  sub test2_in_preload    { $INST->preload }
  
  sub test2_pid              { $INST->pid }
  sub test2_tid              { $INST->tid }
  sub test2_stack            { $INST->stack }
  sub test2_ipc_wait_enable  { $INST->set_no_wait(0) }
  sub test2_ipc_wait_disable { $INST->set_no_wait(1) }
  sub test2_ipc_wait_enabled { !$INST->no_wait }
  
  sub test2_no_wait {
      $INST->set_no_wait(@_) if @_;
      $INST->no_wait;
  }
  
  sub test2_add_callback_context_acquire   { $INST->add_context_acquire_callback(@_) }
  sub test2_add_callback_context_aquire    { $INST->add_context_acquire_callback(@_) }
  sub test2_add_callback_context_init      { $INST->add_context_init_callback(@_) }
  sub test2_add_callback_context_release   { $INST->add_context_release_callback(@_) }
  sub test2_add_callback_exit              { $INST->add_exit_callback(@_) }
  sub test2_add_callback_post_load         { $INST->add_post_load_callback(@_) }
  sub test2_add_callback_pre_subtest       { $INST->add_pre_subtest_callback(@_) }
  sub test2_list_context_aquire_callbacks  { @{$INST->context_acquire_callbacks} }
  sub test2_list_context_acquire_callbacks { @{$INST->context_acquire_callbacks} }
  sub test2_list_context_init_callbacks    { @{$INST->context_init_callbacks} }
  sub test2_list_context_release_callbacks { @{$INST->context_release_callbacks} }
  sub test2_list_exit_callbacks            { @{$INST->exit_callbacks} }
  sub test2_list_post_load_callbacks       { @{$INST->post_load_callbacks} }
  sub test2_list_pre_subtest_callbacks     { @{$INST->pre_subtest_callbacks} }
  
  sub test2_ipc                 { $INST->ipc }
  sub test2_has_ipc             { $INST->has_ipc }
  sub test2_ipc_add_driver      { $INST->add_ipc_driver(@_) }
  sub test2_ipc_drivers         { @{$INST->ipc_drivers} }
  sub test2_ipc_polling         { $INST->ipc_polling }
  sub test2_ipc_enable_polling  { $INST->enable_ipc_polling }
  sub test2_ipc_disable_polling { $INST->disable_ipc_polling }
  sub test2_ipc_get_pending     { $INST->get_ipc_pending }
  sub test2_ipc_set_pending     { $INST->set_ipc_pending(@_) }
  sub test2_ipc_set_timeout     { $INST->set_ipc_timeout(@_) }
  sub test2_ipc_get_timeout     { $INST->ipc_timeout() }
  sub test2_ipc_enable_shm      { $INST->ipc_enable_shm }
  
  sub test2_formatter     {
      if ($ENV{T2_FORMATTER} && $ENV{T2_FORMATTER} =~ m/^(\+)?(.*)$/) {
          my $formatter = $1 ? $2 : "Test2::Formatter::$2";
          my $file = pkg_to_file($formatter);
          require $file;
          return $formatter;
      }
  
      return $INST->formatter;
  }
  
  sub test2_formatters    { @{$INST->formatters} }
  sub test2_formatter_add { $INST->add_formatter(@_) }
  sub test2_formatter_set {
      my ($formatter) = @_;
      croak "No formatter specified" unless $formatter;
      croak "Global Formatter already set" if $INST->formatter_set;
      $INST->set_formatter($formatter);
  }
  
  # Private, for use in Test2::API::Context
  sub _contexts_ref                  { $INST->contexts }
  sub _context_acquire_callbacks_ref { $INST->context_acquire_callbacks }
  sub _context_init_callbacks_ref    { $INST->context_init_callbacks }
  sub _context_release_callbacks_ref { $INST->context_release_callbacks }
  
  # Private, for use in Test2::IPC
  sub _set_ipc { $INST->set_ipc(@_) }
  
  sub context_do(&;@) {
      my $code = shift;
      my @args = @_;
  
      my $ctx = context(level => 1);
  
      my $want = wantarray;
  
      my @out;
      my $ok = eval {
          $want          ? @out    = $code->($ctx, @args) :
          defined($want) ? $out[0] = $code->($ctx, @args) :
                                     $code->($ctx, @args) ;
          1;
      };
      my $err = $@;
  
      $ctx->release;
  
      die $err unless $ok;
  
      return @out    if $want;
      return $out[0] if defined $want;
      return;
  }
  
  sub no_context(&;$) {
      my ($code, $hid) = @_;
      $hid ||= $STACK->top->hid;
  
      my $ctx = $CONTEXTS->{$hid};
      delete $CONTEXTS->{$hid};
      my $ok = eval { $code->(); 1 };
      my $err = $@;
  
      $CONTEXTS->{$hid} = $ctx;
      weaken($CONTEXTS->{$hid});
  
      die $err unless $ok;
  
      return;
  };
  
  my $CID = 1;
  sub context {
      # We need to grab these before anything else to ensure they are not
      # changed.
      my ($errno, $eval_error, $child_error, $extended_error) = (0 + $!, $@, $?, $^E);
  
      my %params = (level => 0, wrapped => 0, @_);
  
      # If something is getting a context then the sync system needs to be
      # considered loaded...
      $INST->load unless $INST->{loaded};
  
      croak "context() called, but return value is ignored"
          unless defined wantarray;
  
      my $stack   = $params{stack} || $STACK;
      my $hub     = $params{hub}   || (@$stack ? $stack->[-1] : $stack->top);
      my $hid     = $hub->{hid};
      my $current = $CONTEXTS->{$hid};
  
      $_->(\%params) for @$ACQUIRE_CBS;
      map $_->(\%params), @{$hub->{_context_acquire}} if $hub->{_context_acquire};
  
      # This is for https://github.com/Test-More/test-more/issues/16
      # and https://rt.perl.org/Public/Bug/Display.html?id=127774
      my $phase = ${^GLOBAL_PHASE} || 'NA';
      my $end_phase = $ENDING || $phase eq 'END' || $phase eq 'DESTRUCT';
  
      my $level = 1 + $params{level};
      my ($pkg, $file, $line, $sub) = $end_phase ? caller(0) : caller($level);
      unless ($pkg || $end_phase) {
          confess "Could not find context at depth $level" unless $params{fudge};
          ($pkg, $file, $line, $sub) = caller(--$level) while ($level >= 0 && !$pkg);
      }
  
      my $depth = $level;
      $depth++ while DO_DEPTH_CHECK && !$end_phase && (!$current || $depth <= $current->{_depth} + $params{wrapped}) && caller($depth + 1);
      $depth -= $params{wrapped};
      my $depth_ok = !DO_DEPTH_CHECK || $end_phase || !$current || $current->{_depth} < $depth;
  
      if ($current && $params{on_release} && $depth_ok) {
          $current->{_on_release} ||= [];
          push @{$current->{_on_release}} => $params{on_release};
      }
  
      # I know this is ugly....
      ($!, $@, $?, $^E) = ($errno, $eval_error, $child_error, $extended_error) and return bless(
          {
              %$current,
              _is_canon   => undef,
              errno       => $errno,
              eval_error  => $eval_error,
              child_error => $child_error,
              _is_spawn   => [$pkg, $file, $line, $sub],
          },
          'Test2::API::Context'
      ) if $current && $depth_ok;
  
      # Handle error condition of bad level
      if ($current) {
          unless (${$current->{_aborted}}) {
              _canon_error($current, [$pkg, $file, $line, $sub, $depth])
                  unless $current->{_is_canon};
  
              _depth_error($current, [$pkg, $file, $line, $sub, $depth])
                  unless $depth_ok;
          }
  
          $current->release if $current->{_is_canon};
  
          delete $CONTEXTS->{$hid};
      }
  
      # Directly bless the object here, calling new is a noticeable performance
      # hit with how often this needs to be called.
      my $trace = bless(
          {
              frame    => [$pkg, $file, $line, $sub],
              pid      => $$,
              tid      => get_tid(),
              cid      => 'C' . $CID++,
              hid      => $hid,
              nested   => $hub->{nested},
              buffered => $hub->{buffered},
          },
          'Test2::EventFacet::Trace'
      );
  
      # Directly bless the object here, calling new is a noticeable performance
      # hit with how often this needs to be called.
      my $aborted = 0;
      $current = bless(
          {
              _aborted     => \$aborted,
              stack        => $stack,
              hub          => $hub,
              trace        => $trace,
              _is_canon    => 1,
              _depth       => $depth,
              errno        => $errno,
              eval_error   => $eval_error,
              child_error  => $child_error,
              $params{on_release} ? (_on_release => [$params{on_release}]) : (),
          },
          'Test2::API::Context'
      );
  
      $CONTEXTS->{$hid} = $current;
      weaken($CONTEXTS->{$hid});
  
      $_->($current) for @$INIT_CBS;
      map $_->($current), @{$hub->{_context_init}} if $hub->{_context_init};
  
      $params{on_init}->($current) if $params{on_init};
  
      ($!, $@, $?, $^E) = ($errno, $eval_error, $child_error, $extended_error);
  
      return $current;
  }
  
  sub _depth_error {
      _existing_error(@_, <<"    EOT");
  context() was called to retrieve an existing context, however the existing
  context was created in a stack frame at the same, or deeper level. This usually
  means that a tool failed to release the context when it was finished.
      EOT
  }
  
  sub _canon_error {
      _existing_error(@_, <<"    EOT");
  context() was called to retrieve an existing context, however the existing
  context has an invalid internal state (!_canon_count). This should not normally
  happen unless something is mucking about with internals...
      EOT
  }
  
  sub _existing_error {
      my ($ctx, $details, $msg) = @_;
      my ($pkg, $file, $line, $sub, $depth) = @$details;
  
      my $oldframe = $ctx->{trace}->frame;
      my $olddepth = $ctx->{_depth};
  
      # Older versions of Carp do not export longmess() function, so it needs to be called with package name
      my $mess = Carp::longmess();
  
      warn <<"    EOT";
  $msg
  Old context details:
     File: $oldframe->[1]
     Line: $oldframe->[2]
     Tool: $oldframe->[3]
    Depth: $olddepth
  
  New context details:
     File: $file
     Line: $line
     Tool: $sub
    Depth: $depth
  
  Trace: $mess
  
  Removing the old context and creating a new one...
      EOT
  }
  
  sub release($;$) {
      $_[0]->release;
      return $_[1];
  }
  
  sub intercept(&) {
      my $code = shift;
      my $ctx = context();
  
      my $events = _intercept($code, deep => 0);
  
      $ctx->release;
  
      return $events;
  }
  
  sub intercept_deep(&) {
      my $code = shift;
      my $ctx = context();
  
      my $events = _intercept($code, deep => 1);
  
      $ctx->release;
  
      return $events;
  }
  
  sub _intercept {
      my $code = shift;
      my %params = @_;
      my $ctx = context();
  
      my $ipc;
      if (my $global_ipc = test2_ipc()) {
          my $driver = blessed($global_ipc);
          $ipc = $driver->new;
      }
  
      my $hub = Test2::Hub::Interceptor->new(
          ipc => $ipc,
          no_ending => 1,
      );
  
      my @events;
      $hub->listen(sub { push @events => $_[1] }, inherit => $params{deep});
  
      $ctx->stack->top; # Make sure there is a top hub before we begin.
      $ctx->stack->push($hub);
  
      my ($ok, $err) = (1, undef);
      T2_SUBTEST_WRAPPER: {
          # Do not use 'try' cause it localizes __DIE__
          $ok = eval { $code->(hub => $hub, context => $ctx->snapshot); 1 };
          $err = $@;
  
          # They might have done 'BEGIN { skip_all => "whatever" }'
          if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/ || (blessed($err) && $err->isa('Test2::Hub::Interceptor::Terminator'))) {
              $ok  = 1;
              $err = undef;
          }
      }
  
      $hub->cull;
      $ctx->stack->pop($hub);
  
      my $trace = $ctx->trace;
      $ctx->release;
  
      die $err unless $ok;
  
      $hub->finalize($trace, 1)
          if $ok
          && !$hub->no_ending
          && !$hub->ended;
  
      return \@events;
  }
  
  sub run_subtest {
      my ($name, $code, $params, @args) = @_;
  
      $_->($name,$code,@args)
          for Test2::API::test2_list_pre_subtest_callbacks();
  
      $params = {buffered => $params} unless ref $params;
      my $inherit_trace = delete $params->{inherit_trace};
  
      my $ctx = context();
  
      my $parent = $ctx->hub;
  
      # If a parent is buffered then the child must be as well.
      my $buffered = $params->{buffered} || $parent->{buffered};
  
      $ctx->note($name) unless $buffered;
  
      my $stack = $ctx->stack || $STACK;
      my $hub = $stack->new_hub(
          class => 'Test2::Hub::Subtest',
          %$params,
          buffered => $buffered,
      );
  
      my @events;
      $hub->listen(sub { push @events => $_[1] });
  
      if ($buffered) {
          if (my $format = $hub->format) {
              my $hide = $format->can('hide_buffered') ? $format->hide_buffered : 1;
              $hub->format(undef) if $hide;
          }
      }
  
      if ($inherit_trace) {
          my $orig = $code;
          $code = sub {
              my $base_trace = $ctx->trace;
              my $trace = $base_trace->snapshot(nested => 1 + $base_trace->nested);
              my $st_ctx = Test2::API::Context->new(
                  trace  => $trace,
                  hub    => $hub,
              );
              $st_ctx->do_in_context($orig, @args);
          };
      }
  
      my ($ok, $err, $finished);
      T2_SUBTEST_WRAPPER: {
          # Do not use 'try' cause it localizes __DIE__
          $ok = eval { $code->(@args); 1 };
          $err = $@;
  
          # They might have done 'BEGIN { skip_all => "whatever" }'
          if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/ || (blessed($err) && blessed($err) eq 'Test::Builder::Exception')) {
              $ok  = undef;
              $err = undef;
          }
          else {
              $finished = 1;
          }
      }
  
      if ($params->{no_fork}) {
          if ($$ != $ctx->trace->pid) {
              warn $ok ? "Forked inside subtest, but subtest never finished!\n" : $err;
              exit 255;
          }
  
          if (get_tid() != $ctx->trace->tid) {
              warn $ok ? "Started new thread inside subtest, but thread never finished!\n" : $err;
              exit 255;
          }
      }
      elsif (!$parent->is_local && !$parent->ipc) {
          warn $ok ? "A new process or thread was started inside subtest, but IPC is not enabled!\n" : $err;
          exit 255;
      }
  
      $stack->pop($hub);
  
      my $trace = $ctx->trace;
  
      my $bailed = $hub->bailed_out;
  
      if (!$finished) {
          if ($bailed && !$buffered) {
              $ctx->bail($bailed->reason);
          }
          elsif ($bailed && $buffered) {
              $ok = 1;
          }
          else {
              my $code = $hub->exit_code;
              $ok = !$code;
              $err = "Subtest ended with exit code $code" if $code;
          }
      }
  
      $hub->finalize($trace->snapshot(hid => $hub->hid, nested => $hub->nested, buffered => $buffered), 1)
          if $ok
          && !$hub->no_ending
          && !$hub->ended;
  
      my $pass = $ok && $hub->is_passing;
      my $e = $ctx->build_event(
          'Subtest',
          pass       => $pass,
          name       => $name,
          subtest_id => $hub->id,
          buffered   => $buffered,
          subevents  => \@events,
      );
  
      my $plan_ok = $hub->check_plan;
  
      $ctx->hub->send($e);
  
      $ctx->failure_diag($e) unless $e->pass;
  
      $ctx->diag("Caught exception in subtest: $err") unless $ok;
  
      $ctx->diag("Bad subtest plan, expected " . $hub->plan . " but ran " . $hub->count)
          if defined($plan_ok) && !$plan_ok;
  
      $ctx->bail($bailed->reason) if $bailed && $buffered;
  
      $ctx->release;
      return $pass;
  }
  
  # There is a use-cycle between API and API/Context. Context needs to use some
  # API functions as the package is compiling. Test2::API::context() needs
  # Test2::API::Context to be loaded, but we cannot 'require' the module there as
  # it causes a very noticeable performance impact with how often context() is
  # called.
  require Test2::API::Context;
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API - Primary interface for writing Test2 based testing tools.
  
  =head1 ***INTERNALS NOTE***
  
  B<The internals of this package are subject to change at any time!> The public
  methods provided will not change in backwards-incompatible ways (once there is
  a stable release), but the underlying implementation details might.
  B<Do not break encapsulation here!>
  
  Currently the implementation is to create a single instance of the
  L<Test2::API::Instance> Object. All class methods defer to the single
  instance. There is no public access to the singleton, and that is intentional.
  The class methods provided by this package provide the only functionality
  publicly exposed.
  
  This is done primarily to avoid the problems Test::Builder had by exposing its
  singleton. We do not want anyone to replace this singleton, rebless it, or
  directly muck with its internals. If you need to do something and cannot
  because of the restrictions placed here, then please report it as an issue. If
  possible, we will create a way for you to implement your functionality without
  exposing things that should not be exposed.
  
  =head1 DESCRIPTION
  
  This package exports all the functions necessary to write and/or verify testing
  tools. Using these building blocks you can begin writing test tools very
  quickly. You are also provided with tools that help you to test the tools you
  write.
  
  =head1 SYNOPSIS
  
  =head2 WRITING A TOOL
  
  The C<context()> method is your primary interface into the Test2 framework.
  
      package My::Ok;
      use Test2::API qw/context/;
  
      our @EXPORT = qw/my_ok/;
      use base 'Exporter';
  
      # Just like ok() from Test::More
      sub my_ok($;$) {
          my ($bool, $name) = @_;
          my $ctx = context(); # Get a context
          $ctx->ok($bool, $name);
          $ctx->release; # Release the context
          return $bool;
      }
  
  See L<Test2::API::Context> for a list of methods available on the context object.
  
  =head2 TESTING YOUR TOOLS
  
  The C<intercept { ... }> tool lets you temporarily intercept all events
  generated by the test system:
  
      use Test2::API qw/intercept/;
  
      use My::Ok qw/my_ok/;
  
      my $events = intercept {
          # These events are not displayed
          my_ok(1, "pass");
          my_ok(0, "fail");
      };
  
      my_ok(@$events == 2, "got 2 events, the pass and the fail");
      my_ok($events->[0]->pass, "first event passed");
      my_ok(!$events->[1]->pass, "second event failed");
  
  =head3 DEEP EVENT INTERCEPTION
  
  Normally C<intercept { ... }> only intercepts events sent to the main hub (as
  added by intercept itself). Nested hubs, such as those created by subtests,
  will not be intercepted. This is normally what you will still see the nested
  events by inspecting the subtest event. However there are times where you want
  to verify each event as it is sent, in that case use C<intercept_deep { ... }>.
  
      my $events = intercept_Deep {
          buffered_subtest foo => sub {
              ok(1, "pass");
          };
      };
  
  C<$events> in this case will contain 3 items:
  
  =over 4
  
  =item The event from C<ok(1, "pass")>
  
  =item The plan event for the subtest
  
  =item The subtest event itself, with the first 2 events nested inside it as children.
  
  =back
  
  This lets you see the order in which the events were sent, unlike
  C<intercept { ... }> which only lets you see events as the main hub sees them.
  
  =head2 OTHER API FUNCTIONS
  
      use Test2::API qw{
          test2_init_done
          test2_stack
          test2_set_is_end
          test2_get_is_end
          test2_ipc
          test2_formatter_set
          test2_formatter
      };
  
      my $init  = test2_init_done();
      my $stack = test2_stack();
      my $ipc   = test2_ipc();
  
      test2_formatter_set($FORMATTER)
      my $formatter = test2_formatter();
  
      ... And others ...
  
  =head1 MAIN API EXPORTS
  
  All exports are optional. You must specify subs to import.
  
      use Test2::API qw/context intercept run_subtest/;
  
  This is the list of exports that are most commonly needed. If you are simply
  writing a tool, then this is probably all you need. If you need something and
  you cannot find it here, then you can also look at L</OTHER API EXPORTS>.
  
  These exports lack the 'test2_' prefix because of how important/common they
  are. Exports in the L</OTHER API EXPORTS> section have the 'test2_' prefix to
  ensure they stand out.
  
  =head2 context(...)
  
  Usage:
  
  =over 4
  
  =item $ctx = context()
  
  =item $ctx = context(%params)
  
  =back
  
  The C<context()> function will always return the current context. If
  there is already a context active, it will be returned. If there is not an
  active context, one will be generated. When a context is generated it will
  default to using the file and line number where the currently running sub was
  called from.
  
  Please see L<Test2::API::Context/"CRITICAL DETAILS"> for important rules about
  what you can and cannot do with a context once it is obtained.
  
  B<Note> This function will throw an exception if you ignore the context object
  it returns.
  
  B<Note> On perls 5.14+ a depth check is used to insure there are no context
  leaks. This cannot be safely done on older perls due to
  L<https://rt.perl.org/Public/Bug/Display.html?id=127774>
  You can forcefully enable it either by setting C<$ENV{T2_CHECK_DEPTH} = 1> or
  C<$Test2::API::DO_DEPTH_CHECK = 1> B<BEFORE> loading L<Test2::API>.
  
  =head3 OPTIONAL PARAMETERS
  
  All parameters to C<context> are optional.
  
  =over 4
  
  =item level => $int
  
  If you must obtain a context in a sub deeper than your entry point you can use
  this to tell it how many EXTRA stack frames to look back. If this option is not
  provided the default of C<0> is used.
  
      sub third_party_tool {
          my $sub = shift;
          ... # Does not obtain a context
          $sub->();
          ...
      }
  
      third_party_tool(sub {
          my $ctx = context(level => 1);
          ...
          $ctx->release;
      });
  
  =item wrapped => $int
  
  Use this if you need to write your own tool that wraps a call to C<context()>
  with the intent that it should return a context object.
  
      sub my_context {
          my %params = ( wrapped => 0, @_ );
          $params{wrapped}++;
          my $ctx = context(%params);
          ...
          return $ctx;
      }
  
      sub my_tool {
          my $ctx = my_context();
          ...
          $ctx->release;
      }
  
  If you do not do this, then tools you call that also check for a context will
  notice that the context they grabbed was created at the same stack depth, which
  will trigger protective measures that warn you and destroy the existing
  context.
  
  =item stack => $stack
  
  Normally C<context()> looks at the global hub stack. If you are maintaining
  your own L<Test2::API::Stack> instance you may pass it in to be used
  instead of the global one.
  
  =item hub => $hub
  
  Use this parameter if you want to obtain the context for a specific hub instead
  of whatever one happens to be at the top of the stack.
  
  =item on_init => sub { ... }
  
  This lets you provide a callback sub that will be called B<ONLY> if your call
  to C<context()> generated a new context. The callback B<WILL NOT> be called if
  C<context()> is returning an existing context. The only argument passed into
  the callback will be the context object itself.
  
      sub foo {
          my $ctx = context(on_init => sub { 'will run' });
  
          my $inner = sub {
              # This callback is not run since we are getting the existing
              # context from our parent sub.
              my $ctx = context(on_init => sub { 'will NOT run' });
              $ctx->release;
          }
          $inner->();
  
          $ctx->release;
      }
  
  =item on_release => sub { ... }
  
  This lets you provide a callback sub that will be called when the context
  instance is released. This callback will be added to the returned context even
  if an existing context is returned. If multiple calls to context add callbacks,
  then all will be called in reverse order when the context is finally released.
  
      sub foo {
          my $ctx = context(on_release => sub { 'will run second' });
  
          my $inner = sub {
              my $ctx = context(on_release => sub { 'will run first' });
  
              # Neither callback runs on this release
              $ctx->release;
          }
          $inner->();
  
          # Both callbacks run here.
          $ctx->release;
      }
  
  =back
  
  =head2 release($;$)
  
  Usage:
  
  =over 4
  
  =item release $ctx;
  
  =item release $ctx, ...;
  
  =back
  
  This is intended as a shortcut that lets you release your context and return a
  value in one statement. This function will get your context, and an optional
  return value. It will release your context, then return your value. Scalar
  context is always assumed.
  
      sub tool {
          my $ctx = context();
          ...
  
          return release $ctx, 1;
      }
  
  This tool is most useful when you want to return the value you get from calling
  a function that needs to see the current context:
  
      my $ctx = context();
      my $out = some_tool(...);
      $ctx->release;
      return $out;
  
  We can combine the last 3 lines of the above like so:
  
      my $ctx = context();
      release $ctx, some_tool(...);
  
  =head2 context_do(&;@)
  
  Usage:
  
      sub my_tool {
          context_do {
              my $ctx = shift;
  
              my (@args) = @_;
  
              $ctx->ok(1, "pass");
  
              ...
  
              # No need to call $ctx->release, done for you on scope exit.
          } @_;
      }
  
  Using this inside your test tool takes care of a lot of boilerplate for you. It
  will ensure a context is acquired. It will capture and rethrow any exception. It
  will insure the context is released when you are done. It preserves the
  subroutine call context (array, scalar, void).
  
  This is the safest way to write a test tool. The only two downsides to this are a
  slight performance decrease, and some extra indentation in your source. If the
  indentation is a problem for you then you can take a peek at the next section.
  
  =head2 no_context(&;$)
  
  Usage:
  
  =over 4
  
  =item no_context { ... };
  
  =item no_context { ... } $hid;
  
      sub my_tool(&) {
          my $code = shift;
          my $ctx = context();
          ...
  
          no_context {
              # Things in here will not see our current context, they get a new
              # one.
  
              $code->();
          };
  
          ...
          $ctx->release;
      };
  
  =back
  
  This tool will hide a context for the provided block of code. This means any
  tools run inside the block will get a completely new context if they acquire
  one. The new context will be inherited by tools nested below the one that
  acquired it.
  
  This will normally hide the current context for the top hub. If you need to
  hide the context for a different hub you can pass in the optional C<$hid>
  parameter.
  
  =head2 intercept(&)
  
  Usage:
  
      my $events = intercept {
          ok(1, "pass");
          ok(0, "fail");
          ...
      };
  
  This function takes a codeblock as its only argument, and it has a prototype.
  It will execute the codeblock, intercepting any generated events in the
  process. It will return an array reference with all the generated event
  objects. All events should be subclasses of L<Test2::Event>.
  
  This is a very low-level subtest tool. This is useful for writing tools which
  produce subtests. This is not intended for people simply writing tests.
  
  =head2 run_subtest(...)
  
  Usage:
  
      run_subtest($NAME, \&CODE, $BUFFERED, @ARGS)
  
      # or
  
      run_subtest($NAME, \&CODE, \%PARAMS, @ARGS)
  
  This will run the provided codeblock with the args in C<@args>. This codeblock
  will be run as a subtest. A subtest is an isolated test state that is condensed
  into a single L<Test2::Event::Subtest> event, which contains all events
  generated inside the subtest.
  
  =head3 ARGUMENTS:
  
  =over 4
  
  =item $NAME
  
  The name of the subtest.
  
  =item \&CODE
  
  The code to run inside the subtest.
  
  =item $BUFFERED or \%PARAMS
  
  If this is a simple scalar then it will be treated as a boolean for the
  'buffered' setting. If this is a hash reference then it will be used as a
  parameters hash. The param hash will be used for hub construction (with the
  specified keys removed).
  
  Keys that are removed and used by run_subtest:
  
  =over 4
  
  =item 'buffered' => $bool
  
  Toggle buffered status.
  
  =item 'inherit_trace' => $bool
  
  Normally the subtest hub is pushed and the sub is allowed to generate its own
  root context for the hub. When this setting is turned on a root context will be
  created for the hub that shares the same trace as the current context.
  
  Set this to true if your tool is producing subtests without user-specified
  subs.
  
  =item 'no_fork' => $bool
  
  Defaults to off. Normally forking inside a subtest will actually fork the
  subtest, resulting in 2 final subtest events. This parameter will turn off that
  behavior, only the original process/thread will return a final subtest event.
  
  =back
  
  =item @ARGS
  
  Any extra arguments you want passed into the subtest code.
  
  =back
  
  =head3 BUFFERED VS UNBUFFERED (OR STREAMED)
  
  Normally all events inside and outside a subtest are sent to the formatter
  immediately by the hub. Sometimes it is desirable to hold off sending events
  within a subtest until the subtest is complete. This usually depends on the
  formatter being used.
  
  =over 4
  
  =item Things not effected by this flag
  
  In both cases events are generated and stored in an array. This array is
  eventually used to populate the C<subevents> attribute on the
  L<Test2::Event::Subtest> event that is generated at the end of the subtest.
  This flag has no effect on this part, it always happens.
  
  At the end of the subtest, the final L<Test2::Event::Subtest> event is sent to
  the formatter.
  
  =item Things that are effected by this flag
  
  The C<buffered> attribute of the L<Test2::Event::Subtest> event will be set to
  the value of this flag. This means any formatter, listener, etc which looks at
  the event will know if it was buffered.
  
  =item Things that are formatter dependant
  
  Events within a buffered subtest may or may not be sent to the formatter as
  they happen. If a formatter fails to specify then the default is to B<NOT SEND>
  the events as they are generated, instead the formatter can pull them from the
  C<subevents> attribute.
  
  A formatter can specify by implementing the C<hide_buffered()> method. If this
  method returns true then events generated inside a buffered subtest will not be
  sent independently of the final subtest event.
  
  =back
  
  An example of how this is used is the L<Test2::Formatter::TAP> formatter. For
  unbuffered subtests the events are rendered as they are generated. At the end
  of the subtest, the final subtest event is rendered, but the C<subevents>
  attribute is ignored. For buffered subtests the opposite occurs, the events are
  NOT rendered as they are generated, instead the C<subevents> attribute is used
  to render them all at once. This is useful when running subtests tests in
  parallel, since without it the output from subtests would be interleaved
  together.
  
  =head1 OTHER API EXPORTS
  
  Exports in this section are not commonly needed. These all have the 'test2_'
  prefix to help ensure they stand out. You should look at the L</MAIN API
  EXPORTS> section before looking here. This section is one where "Great power
  comes with great responsibility". It is possible to break things badly if you
  are not careful with these.
  
  All exports are optional. You need to list which ones you want at import time:
  
      use Test2::API qw/test2_init_done .../;
  
  =head2 STATUS AND INITIALIZATION STATE
  
  These provide access to internal state and object instances.
  
  =over 4
  
  =item $bool = test2_init_done()
  
  This will return true if the stack and IPC instances have already been
  initialized. It will return false if they have not. Init happens as late as
  possible. It happens as soon as a tool requests the IPC instance, the
  formatter, or the stack.
  
  =item $bool = test2_load_done()
  
  This will simply return the boolean value of the loaded flag. If Test2 has
  finished loading this will be true, otherwise false. Loading is considered
  complete the first time a tool requests a context.
  
  =item test2_set_is_end()
  
  =item test2_set_is_end($bool)
  
  This is used to toggle Test2's belief that the END phase has already started.
  With no arguments this will set it to true. With arguments it will set it to
  the first argument's value.
  
  This is used to prevent the use of C<caller()> in END blocks which can cause
  segfaults. This is only necessary in some persistent environments that may have
  multiple END phases.
  
  =item $bool = test2_get_is_end()
  
  Check if Test2 believes it is the END phase.
  
  =item $stack = test2_stack()
  
  This will return the global L<Test2::API::Stack> instance. If this has not
  yet been initialized it will be initialized now.
  
  =item test2_ipc_wait_enable()
  
  =item test2_ipc_wait_disable()
  
  =item $bool = test2_ipc_wait_enabled()
  
  These can be used to turn IPC waiting on and off, or check the current value of
  the flag.
  
  Waiting is turned on by default. Waiting will cause the parent process/thread
  to wait until all child processes and threads are finished before exiting. You
  will almost never want to turn this off.
  
  =item $bool = test2_no_wait()
  
  =item test2_no_wait($bool)
  
  B<DISCOURAGED>: This is a confusing interface, it is better to use
  C<test2_ipc_wait_enable()>, C<test2_ipc_wait_disable()> and
  C<test2_ipc_wait_enabled()>.
  
  This can be used to get/set the no_wait status. Waiting is turned on by
  default. Waiting will cause the parent process/thread to wait until all child
  processes and threads are finished before exiting. You will almost never want
  to turn this off.
  
  =item $fh = test2_stdout()
  
  =item $fh = test2_stderr()
  
  These functions return the filehandles that test output should be written to.
  They are primarily useful when writing a custom formatter and code that turns
  events into actual output (TAP, etc.)  They will return a dupe of the original
  filehandles that formatted output can be sent to regardless of whatever state
  the currently running test may have left STDOUT and STDERR in.
  
  =item test2_reset_io()
  
  Re-dupe the internal filehandles returned by C<test2_stdout()> and
  C<test2_stderr()> from the current STDOUT and STDERR.  You shouldn't need to do
  this except in very peculiar situations (for example, you're testing a new
  formatter and you need control over where the formatter is sending its output.)
  
  =back
  
  =head2 BEHAVIOR HOOKS
  
  These are hooks that allow you to add custom behavior to actions taken by Test2
  and tools built on top of it.
  
  =over 4
  
  =item test2_add_callback_exit(sub { ... })
  
  This can be used to add a callback that is called after all testing is done. This
  is too late to add additional results, the main use of this callback is to set the
  exit code.
  
      test2_add_callback_exit(
          sub {
              my ($context, $exit, \$new_exit) = @_;
              ...
          }
      );
  
  The C<$context> passed in will be an instance of L<Test2::API::Context>. The
  C<$exit> argument will be the original exit code before anything modified it.
  C<$$new_exit> is a reference to the new exit code. You may modify this to
  change the exit code. Please note that C<$$new_exit> may already be different
  from C<$exit>
  
  =item test2_add_callback_post_load(sub { ... })
  
  Add a callback that will be called when Test2 is finished loading. This
  means the callback will be run once, the first time a context is obtained.
  If Test2 has already finished loading then the callback will be run immediately.
  
  =item test2_add_callback_context_acquire(sub { ... })
  
  Add a callback that will be called every time someone tries to acquire a
  context. This will be called on EVERY call to C<context()>. It gets a single
  argument, a reference to the hash of parameters being used the construct the
  context. This is your chance to change the parameters by directly altering the
  hash.
  
      test2_add_callback_context_acquire(sub {
          my $params = shift;
          $params->{level}++;
      });
  
  This is a very scary API function. Please do not use this unless you need to.
  This is here for L<Test::Builder> and backwards compatibility. This has you
  directly manipulate the hash instead of returning a new one for performance
  reasons.
  
  =item test2_add_callback_context_init(sub { ... })
  
  Add a callback that will be called every time a new context is created. The
  callback will receive the newly created context as its only argument.
  
  =item test2_add_callback_context_release(sub { ... })
  
  Add a callback that will be called every time a context is released. The
  callback will receive the released context as its only argument.
  
  =item test2_add_callback_pre_subtest(sub { ... })
  
  Add a callback that will be called every time a subtest is going to be
  run. The callback will receive the subtest name, coderef, and any
  arguments.
  
  =item @list = test2_list_context_acquire_callbacks()
  
  Return all the context acquire callback references.
  
  =item @list = test2_list_context_init_callbacks()
  
  Returns all the context init callback references.
  
  =item @list = test2_list_context_release_callbacks()
  
  Returns all the context release callback references.
  
  =item @list = test2_list_exit_callbacks()
  
  Returns all the exit callback references.
  
  =item @list = test2_list_post_load_callbacks()
  
  Returns all the post load callback references.
  
  =item @list = test2_list_pre_subtest_callbacks()
  
  Returns all the pre-subtest callback references.
  
  =back
  
  =head2 IPC AND CONCURRENCY
  
  These let you access, or specify, the IPC system internals.
  
  =over 4
  
  =item $bool = test2_has_ipc()
  
  Check if IPC is enabled.
  
  =item $ipc = test2_ipc()
  
  This will return the global L<Test2::IPC::Driver> instance. If this has not yet
  been initialized it will be initialized now.
  
  =item test2_ipc_add_driver($DRIVER)
  
  Add an IPC driver to the list. This will add the driver to the start of the
  list.
  
  =item @drivers = test2_ipc_drivers()
  
  Get the list of IPC drivers.
  
  =item $bool = test2_ipc_polling()
  
  Check if polling is enabled.
  
  =item test2_ipc_enable_polling()
  
  Turn on polling. This will cull events from other processes and threads every
  time a context is created.
  
  =item test2_ipc_disable_polling()
  
  Turn off IPC polling.
  
  =item test2_ipc_enable_shm()
  
  Turn on IPC SHM. Only some IPC drivers use this, and most will turn it on
  themselves.
  
  =item test2_ipc_set_pending($uniq_val)
  
  Tell other processes and events that an event is pending. C<$uniq_val> should
  be a unique value no other thread/process will generate.
  
  B<Note:> After calling this C<test2_ipc_get_pending()> will return 1. This is
  intentional, and not avoidable.
  
  =item $pending = test2_ipc_get_pending()
  
  This returns -1 if there is no way to check (assume yes)
  
  This returns 0 if there are (most likely) no pending events.
  
  This returns 1 if there are (likely) pending events. Upon return it will reset,
  nothing else will be able to see that there were pending events.
  
  =item $timeout = test2_ipc_get_timeout()
  
  =item test2_ipc_set_timeout($timeout)
  
  Get/Set the timeout value for the IPC system. This timeout is how long the IPC
  system will wait for child processes and threads to finish before aborting.
  
  The default value is C<30> seconds.
  
  =back
  
  =head2 MANAGING FORMATTERS
  
  These let you access, or specify, the formatters that can/should be used.
  
  =over 4
  
  =item $formatter = test2_formatter
  
  This will return the global formatter class. This is not an instance. By
  default the formatter is set to L<Test2::Formatter::TAP>.
  
  You can override this default using the C<T2_FORMATTER> environment variable.
  
  Normally 'Test2::Formatter::' is prefixed to the value in the
  environment variable:
  
      $ T2_FORMATTER='TAP' perl test.t     # Use the Test2::Formatter::TAP formatter
      $ T2_FORMATTER='Foo' perl test.t     # Use the Test2::Formatter::Foo formatter
  
  If you want to specify a full module name you use the '+' prefix:
  
      $ T2_FORMATTER='+Foo::Bar' perl test.t     # Use the Foo::Bar formatter
  
  =item test2_formatter_set($class_or_instance)
  
  Set the global formatter class. This can only be set once. B<Note:> This will
  override anything specified in the 'T2_FORMATTER' environment variable.
  
  =item @formatters = test2_formatters()
  
  Get a list of all loaded formatters.
  
  =item test2_formatter_add($class_or_instance)
  
  Add a formatter to the list. Last formatter added is used at initialization. If
  this is called after initialization a warning will be issued.
  
  =back
  
  =head1 OTHER EXAMPLES
  
  See the C</Examples/> directory included in this distribution.
  
  =head1 SEE ALSO
  
  L<Test2::API::Context> - Detailed documentation of the context object.
  
  L<Test2::IPC> - The IPC system used for threading/fork support.
  
  L<Test2::Formatter> - Formatters such as TAP live here.
  
  L<Test2::Event> - Events live in this namespace.
  
  L<Test2::Hub> - All events eventually funnel through a hub. Custom hubs are how
  C<intercept()> and C<run_subtest()> are implemented.
  
  =head1 MAGIC
  
  This package has an END block. This END block is responsible for setting the
  exit code based on the test results. This end block also calls the callbacks that
  can be added to this package.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API

$fatpacked{"Test2/API/Breakage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_BREAKAGE';
  package Test2::API::Breakage;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  use Test2::Util qw/pkg_to_file/;
  
  our @EXPORT_OK = qw{
      upgrade_suggested
      upgrade_required
      known_broken
  };
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  sub upgrade_suggested {
      return (
          'Test::Exception'    => '0.42',
          'Test::FITesque'     => '0.04',
          'Test::Module::Used' => '0.2.5',
          'Test::Moose::More'  => '0.025',
      );
  }
  
  sub upgrade_required {
      return (
          'Test::Builder::Clutch'   => '0.07',
          'Test::Dist::VersionSync' => '1.1.4',
          'Test::Modern'            => '0.012',
          'Test::SharedFork'        => '0.34',
          'Test::Alien'             => '0.04',
          'Test::UseAllModules'     => '0.14',
          'Test::More::Prefix'      => '0.005',
  
          'Test2::Tools::EventDumper' => 0.000007,
          'Test2::Harness'            => 0.000013,
  
          'Test::DBIx::Class::Schema'    => '1.0.9',
          'Test::Clustericious::Cluster' => '0.30',
      );
  }
  
  sub known_broken {
      return (
          'Net::BitTorrent'       => '0.052',
          'Test::Able'            => '0.11',
          'Test::Aggregate'       => '0.373',
          'Test::Flatten'         => '0.11',
          'Test::Group'           => '0.20',
          'Test::ParallelSubtest' => '0.05',
          'Test::Pretty'          => '0.32',
          'Test::Wrapper'         => '0.3.0',
  
          'Log::Dispatch::Config::TestLog' => '0.02',
      );
  }
  
  # Not reportable:
  # Device::Chip => 0.07   - Tests will not pass, but not broken if already installed, also no fixed version we can upgrade to.
  
  sub report {
      my $class = shift;
      my ($require) = @_;
  
      my %suggest  = __PACKAGE__->upgrade_suggested();
      my %required = __PACKAGE__->upgrade_required();
      my %broken   = __PACKAGE__->known_broken();
  
      my @warn;
      for my $mod (keys %suggest) {
          my $file = pkg_to_file($mod);
          next unless $INC{$file} || ($require && eval { require $file; 1 });
          my $want = $suggest{$mod};
          next if eval { $mod->VERSION($want); 1 };
          push @warn => " * Module '$mod' is outdated, we recommed updating above $want.";
      }
  
      for my $mod (keys %required) {
          my $file = pkg_to_file($mod);
          next unless $INC{$file} || ($require && eval { require $file; 1 });
          my $want = $required{$mod};
          next if eval { $mod->VERSION($want); 1 };
          push @warn => " * Module '$mod' is outdated and known to be broken, please update to $want or higher.";
      }
  
      for my $mod (keys %broken) {
          my $file = pkg_to_file($mod);
          next unless $INC{$file} || ($require && eval { require $file; 1 });
          my $tested = $broken{$mod};
          push @warn => " * Module '$mod' is known to be broken in version $tested and below, newer versions have not been tested. You have: " . $mod->VERSION;
      }
  
      return @warn;
  }
  
  1;
  
  __END__
  
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API::Breakage - What breaks at what version
  
  =head1 DESCRIPTION
  
  This module provides lists of modules that are broken, or have been broken in
  the past, when upgrading L<Test::Builder> to use L<Test2>.
  
  =head1 FUNCTIONS
  
  These can be imported, or called as methods on the class.
  
  =over 4
  
  =item %mod_ver = upgrade_suggested()
  
  =item %mod_ver = Test2::API::Breakage->upgrade_suggested()
  
  This returns key/value pairs. The key is the module name, the value is the
  version number. If the installed version of the module is at or below the
  specified one then an upgrade would be a good idea, but not strictly necessary.
  
  =item %mod_ver = upgrade_required()
  
  =item %mod_ver = Test2::API::Breakage->upgrade_required()
  
  This returns key/value pairs. The key is the module name, the value is the
  version number. If the installed version of the module is at or below the
  specified one then an upgrade is required for the module to work properly.
  
  =item %mod_ver = known_broken()
  
  =item %mod_ver = Test2::API::Breakage->known_broken()
  
  This returns key/value pairs. The key is the module name, the value is the
  version number. If the installed version of the module is at or below the
  specified one then the module will not work. A newer version may work, but is
  not tested or verified.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API_BREAKAGE

$fatpacked{"Test2/API/Context.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_CONTEXT';
  package Test2::API::Context;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  use Carp qw/confess croak/;
  use Scalar::Util qw/weaken blessed/;
  use Test2::Util qw/get_tid try pkg_to_file get_tid/;
  
  use Test2::EventFacet::Trace();
  use Test2::API();
  
  # Preload some key event types
  my %LOADED = (
      map {
          my $pkg  = "Test2::Event::$_";
          my $file = "Test2/Event/$_.pm";
          require $file unless $INC{$file};
          ( $pkg => $pkg, $_ => $pkg )
      } qw/Ok Diag Note Plan Bail Exception Waiting Skip Subtest Pass Fail/
  );
  
  use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;
  use Test2::Util::HashBase qw{
      stack hub trace _on_release _depth _is_canon _is_spawn _aborted
      errno eval_error child_error thrown
  };
  
  # Private, not package vars
  # It is safe to cache these.
  my $ON_RELEASE = Test2::API::_context_release_callbacks_ref();
  my $CONTEXTS   = Test2::API::_contexts_ref();
  
  sub init {
      my $self = shift;
  
      confess "The 'trace' attribute is required"
          unless $self->{+TRACE};
  
      confess "The 'hub' attribute is required"
          unless $self->{+HUB};
  
      $self->{+_DEPTH} = 0 unless defined $self->{+_DEPTH};
  
      $self->{+ERRNO}       = $! unless exists $self->{+ERRNO};
      $self->{+EVAL_ERROR}  = $@ unless exists $self->{+EVAL_ERROR};
      $self->{+CHILD_ERROR} = $? unless exists $self->{+CHILD_ERROR};
  }
  
  sub snapshot { bless {%{$_[0]}, _is_canon => undef, _is_spawn => undef, _aborted => undef}, __PACKAGE__ }
  
  sub restore_error_vars {
      my $self = shift;
      ($!, $@, $?) = @$self{+ERRNO, +EVAL_ERROR, +CHILD_ERROR};
  }
  
  sub DESTROY {
      return unless $_[0]->{+_IS_CANON} || $_[0]->{+_IS_SPAWN};
      return if $_[0]->{+_ABORTED} && ${$_[0]->{+_ABORTED}};
      my ($self) = @_;
  
      my $hub = $self->{+HUB};
      my $hid = $hub->{hid};
  
      # Do not show the warning if it looks like an exception has been thrown, or
      # if the context is not local to this process or thread.
      {
          # Sometimes $@ is uninitialized, not a problem in this case so do not
          # show the warning about using eq.
          no warnings 'uninitialized';
          if($self->{+EVAL_ERROR} eq $@ && $hub->is_local) {
              my $frame = $self->{+_IS_SPAWN} || $self->{+TRACE}->frame;
              warn <<"            EOT";
  A context appears to have been destroyed without first calling release().
  Based on \$@ it does not look like an exception was thrown (this is not always
  a reliable test)
  
  This is a problem because the global error variables (\$!, \$@, and \$?) will
  not be restored. In addition some release callbacks will not work properly from
  inside a DESTROY method.
  
  Here are the context creation details, just in case a tool forgot to call
  release():
    File: $frame->[1]
    Line: $frame->[2]
    Tool: $frame->[3]
  
  Cleaning up the CONTEXT stack...
              EOT
          }
      }
  
      return if $self->{+_IS_SPAWN};
  
      # Remove the key itself to avoid a slow memory leak
      delete $CONTEXTS->{$hid};
      $self->{+_IS_CANON} = undef;
  
      if (my $cbk = $self->{+_ON_RELEASE}) {
          $_->($self) for reverse @$cbk;
      }
      if (my $hcbk = $hub->{_context_release}) {
          $_->($self) for reverse @$hcbk;
      }
      $_->($self) for reverse @$ON_RELEASE;
  }
  
  # release exists to implement behaviors like die-on-fail. In die-on-fail you
  # want to die after a failure, but only after diagnostics have been reported.
  # The ideal time for the die to happen is when the context is released.
  # Unfortunately die does not work in a DESTROY block.
  sub release {
      my ($self) = @_;
  
      ($!, $@, $?) = @$self{+ERRNO, +EVAL_ERROR, +CHILD_ERROR} and return if $self->{+THROWN};
  
      ($!, $@, $?) = @$self{+ERRNO, +EVAL_ERROR, +CHILD_ERROR} and return $self->{+_IS_SPAWN} = undef
          if $self->{+_IS_SPAWN};
  
      croak "release() should not be called on context that is neither canon nor a child"
          unless $self->{+_IS_CANON};
  
      my $hub = $self->{+HUB};
      my $hid = $hub->{hid};
  
      croak "context thinks it is canon, but it is not"
          unless $CONTEXTS->{$hid} && $CONTEXTS->{$hid} == $self;
  
      # Remove the key itself to avoid a slow memory leak
      $self->{+_IS_CANON} = undef;
      delete $CONTEXTS->{$hid};
  
      if (my $cbk = $self->{+_ON_RELEASE}) {
          $_->($self) for reverse @$cbk;
      }
      if (my $hcbk = $hub->{_context_release}) {
          $_->($self) for reverse @$hcbk;
      }
      $_->($self) for reverse @$ON_RELEASE;
  
      # Do this last so that nothing else changes them.
      # If one of the hooks dies then these do not get restored, this is
      # intentional
      ($!, $@, $?) = @$self{+ERRNO, +EVAL_ERROR, +CHILD_ERROR};
  
      return;
  }
  
  sub do_in_context {
      my $self = shift;
      my ($sub, @args) = @_;
  
      # We need to update the pid/tid and error vars.
      my $clone = $self->snapshot;
      @$clone{+ERRNO, +EVAL_ERROR, +CHILD_ERROR} = ($!, $@, $?);
      $clone->{+TRACE} = $clone->{+TRACE}->snapshot(pid => $$, tid => get_tid());
  
      my $hub = $clone->{+HUB};
      my $hid = $hub->hid;
  
      my $old = $CONTEXTS->{$hid};
  
      $clone->{+_IS_CANON} = 1;
      $CONTEXTS->{$hid} = $clone;
      weaken($CONTEXTS->{$hid});
      my ($ok, $err) = &try($sub, @args);
      my ($rok, $rerr) = try { $clone->release };
      delete $clone->{+_IS_CANON};
  
      if ($old) {
          $CONTEXTS->{$hid} = $old;
          weaken($CONTEXTS->{$hid});
      }
      else {
          delete $CONTEXTS->{$hid};
      }
  
      die $err  unless $ok;
      die $rerr unless $rok;
  }
  
  sub done_testing {
      my $self = shift;
      $self->hub->finalize($self->trace, 1);
      return;
  }
  
  sub throw {
      my ($self, $msg) = @_;
      $self->{+THROWN} = 1;
      ${$self->{+_ABORTED}}++ if $self->{+_ABORTED};
      $self->release if $self->{+_IS_CANON} || $self->{+_IS_SPAWN};
      $self->trace->throw($msg);
  }
  
  sub alert {
      my ($self, $msg) = @_;
      $self->trace->alert($msg);
  }
  
  sub send_event_and_release {
      my $self = shift;
      my $out = $self->send_event(@_);
      $self->release;
      return $out;
  }
  
  sub send_event {
      my $self  = shift;
      my $event = shift;
      my %args  = @_;
  
      my $pkg = $LOADED{$event} || $self->_parse_event($event);
  
      my $e;
      {
          local $Carp::CarpLevel = $Carp::CarpLevel + 1;
          $e = $pkg->new(
              trace => $self->{+TRACE}->snapshot,
              %args,
          );
      }
  
      if ($self->{+_ABORTED}) {
          my $f = $e->facet_data;
          ${$self->{+_ABORTED}}++ if $f->{control}->{halt} || defined($f->{control}->{terminate}) || defined($e->terminate);
      }
      $self->{+HUB}->send($e);
  }
  
  sub build_event {
      my $self  = shift;
      my $event = shift;
      my %args  = @_;
  
      my $pkg = $LOADED{$event} || $self->_parse_event($event);
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      $pkg->new(
          trace => $self->{+TRACE}->snapshot,
          %args,
      );
  }
  
  sub pass {
      my $self = shift;
      my ($name) = @_;
  
      my $e = bless(
          {
              trace => bless({%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
              name  => $name,
          },
          "Test2::Event::Pass"
      );
  
      $self->{+HUB}->send($e);
      return $e;
  }
  
  sub pass_and_release {
      my $self = shift;
      my ($name) = @_;
  
      my $e = bless(
          {
              trace => bless({%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
              name  => $name,
          },
          "Test2::Event::Pass"
      );
  
      $self->{+HUB}->send($e);
      $self->release;
      return 1;
  }
  
  sub fail {
      my $self = shift;
      my ($name, @diag) = @_;
  
      my $e = bless(
          {
              trace => bless({%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
              name  => $name,
          },
          "Test2::Event::Fail"
      );
  
      $e->add_info({tag => 'DIAG', debug => 1, details => $_}) for @diag;
      $self->{+HUB}->send($e);
      return $e;
  }
  
  sub fail_and_release {
      my $self = shift;
      my ($name, @diag) = @_;
  
      my $e = bless(
          {
              trace => bless({%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
              name  => $name,
          },
          "Test2::Event::Fail"
      );
  
      $e->add_info({tag => 'DIAG', debug => 1, details => $_}) for @diag;
      $self->{+HUB}->send($e);
      $self->release;
      return 0;
  }
  
  sub ok {
      my $self = shift;
      my ($pass, $name, $on_fail) = @_;
  
      my $hub = $self->{+HUB};
  
      my $e = bless {
          trace => bless( {%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
          pass  => $pass,
          name  => $name,
      }, 'Test2::Event::Ok';
      $e->init;
  
      $hub->send($e);
      return $e if $pass;
  
      $self->failure_diag($e);
  
      if ($on_fail && @$on_fail) {
          $self->diag($_) for @$on_fail;
      }
  
      return $e;
  }
  
  sub failure_diag {
      my $self = shift;
      my ($e) = @_;
  
      # Figure out the debug info, this is typically the file name and line
      # number, but can also be a custom message. If no trace object is provided
      # then we have nothing useful to display.
      my $name  = $e->name;
      my $trace = $e->trace;
      my $debug = $trace ? $trace->debug : "[No trace info available]";
  
      # Create the initial diagnostics. If the test has a name we put the debug
      # info on a second line, this behavior is inherited from Test::Builder.
      my $msg = defined($name)
          ? qq[Failed test '$name'\n$debug.\n]
          : qq[Failed test $debug.\n];
  
      $self->diag($msg);
  }
  
  sub skip {
      my $self = shift;
      my ($name, $reason, @extra) = @_;
      $self->send_event(
          'Skip',
          name => $name,
          reason => $reason,
          pass => 1,
          @extra,
      );
  }
  
  sub note {
      my $self = shift;
      my ($message) = @_;
      $self->send_event('Note', message => $message);
  }
  
  sub diag {
      my $self = shift;
      my ($message) = @_;
      my $hub = $self->{+HUB};
      $self->send_event(
          'Diag',
          message => $message,
      );
  }
  
  sub plan {
      my ($self, $max, $directive, $reason) = @_;
      $self->send_event('Plan', max => $max, directive => $directive, reason => $reason);
  }
  
  sub bail {
      my ($self, $reason) = @_;
      $self->send_event('Bail', reason => $reason);
  }
  
  sub _parse_event {
      my $self = shift;
      my $event = shift;
  
      my $pkg;
      if ($event =~ m/^\+(.*)/) {
          $pkg = $1;
      }
      else {
          $pkg = "Test2::Event::$event";
      }
  
      unless ($LOADED{$pkg}) {
          my $file = pkg_to_file($pkg);
          my ($ok, $err) = try { require $file };
          $self->throw("Could not load event module '$pkg': $err")
              unless $ok;
  
          $LOADED{$pkg} = $pkg;
      }
  
      confess "'$pkg' is not a subclass of 'Test2::Event'"
          unless $pkg->isa('Test2::Event');
  
      $LOADED{$event} = $pkg;
  
      return $pkg;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API::Context - Object to represent a testing context.
  
  =head1 DESCRIPTION
  
  The context object is the primary interface for authors of testing tools
  written with L<Test2>. The context object represents the context in
  which a test takes place (File and Line Number), and provides a quick way to
  generate events from that context. The context object also takes care of
  sending events to the correct L<Test2::Hub> instance.
  
  =head1 SYNOPSIS
  
  In general you will not be creating contexts directly. To obtain a context you
  should always use C<context()> which is exported by the L<Test2::API> module.
  
      use Test2::API qw/context/;
  
      sub my_ok {
          my ($bool, $name) = @_;
          my $ctx = context();
          $ctx->ok($bool, $name);
          $ctx->release; # You MUST do this!
          return $bool;
      }
  
  Context objects make it easy to wrap other tools that also use context. Once
  you grab a context, any tool you call before releasing your context will
  inherit it:
  
      sub wrapper {
          my ($bool, $name) = @_;
          my $ctx = context();
          $ctx->diag("wrapping my_ok");
  
          my $out = my_ok($bool, $name);
          $ctx->release; # You MUST do this!
          return $out;
      }
  
  =head1 CRITICAL DETAILS
  
  =over 4
  
  =item you MUST always use the context() sub from Test2::API
  
  Creating your own context via C<< Test2::API::Context->new() >> will almost never
  produce a desirable result. Use C<context()> which is exported by L<Test2::API>.
  
  There are a handful of cases where a tool author may want to create a new
  context by hand, which is why the C<new> method exists. Unless you really know
  what you are doing you should avoid this.
  
  =item You MUST always release the context when done with it
  
  Releasing the context tells the system you are done with it. This gives it a
  chance to run any necessary callbacks or cleanup tasks. If you forget to
  release the context it will try to detect the problem and warn you about it.
  
  =item You MUST NOT pass context objects around
  
  When you obtain a context object it is made specifically for your tool and any
  tools nested within. If you pass a context around you run the risk of polluting
  other tools with incorrect context information.
  
  If you are certain that you want a different tool to use the same context you
  may pass it a snapshot. C<< $ctx->snapshot >> will give you a shallow clone of
  the context that is safe to pass around or store.
  
  =item You MUST NOT store or cache a context for later
  
  As long as a context exists for a given hub, all tools that try to get a
  context will get the existing instance. If you try to store the context you
  will pollute other tools with incorrect context information.
  
  If you are certain that you want to save the context for later, you can use a
  snapshot. C<< $ctx->snapshot >> will give you a shallow clone of the context
  that is safe to pass around or store.
  
  C<context()> has some mechanisms to protect you if you do cause a context to
  persist beyond the scope in which it was obtained. In practice you should not
  rely on these protections, and they are fairly noisy with warnings.
  
  =item You SHOULD obtain your context as soon as possible in a given tool
  
  You never know what tools you call from within your own tool will need a
  context. Obtaining the context early ensures that nested tools can find the
  context you want them to find.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item $ctx->done_testing;
  
  Note that testing is finished. If no plan has been set this will generate a
  Plan event.
  
  =item $clone = $ctx->snapshot()
  
  This will return a shallow clone of the context. The shallow clone is safe to
  store for later.
  
  =item $ctx->release()
  
  This will release the context. This runs cleanup tasks, and several important
  hooks. It will also restore C<$!>, C<$?>, and C<$@> to what they were when the
  context was created.
  
  B<Note:> If a context is acquired more than once an internal refcount is kept.
  C<release()> decrements the ref count, none of the other actions of
  C<release()> will occur unless the refcount hits 0. This means only the last
  call to C<release()> will reset C<$?>, C<$!>, C<$@>,and run the cleanup tasks.
  
  =item $ctx->throw($message)
  
  This will throw an exception reporting to the file and line number of the
  context. This will also release the context for you.
  
  =item $ctx->alert($message)
  
  This will issue a warning from the file and line number of the context.
  
  =item $stack = $ctx->stack()
  
  This will return the L<Test2::API::Stack> instance the context used to find
  the current hub.
  
  =item $hub = $ctx->hub()
  
  This will return the L<Test2::Hub> instance the context recognizes as the
  current one to which all events should be sent.
  
  =item $dbg = $ctx->trace()
  
  This will return the L<Test2::EventFacet::Trace> instance used by the context.
  
  =item $ctx->do_in_context(\&code, @args);
  
  Sometimes you have a context that is not current, and you want things to use it
  as the current one. In these cases you can call
  C<< $ctx->do_in_context(sub { ... }) >>. The codeblock will be run, and
  anything inside of it that looks for a context will find the one on which the
  method was called.
  
  This B<DOES NOT> affect context on other hubs, only the hub used by the context
  will be affected.
  
      my $ctx = ...;
      $ctx->do_in_context(sub {
          my $ctx = context(); # returns the $ctx the sub is called on
      });
  
  B<Note:> The context will actually be cloned, the clone will be used instead of
  the original. This allows the thread id, process id, and error variables to be correct without
  modifying the original context.
  
  =item $ctx->restore_error_vars()
  
  This will set C<$!>, C<$?>, and C<$@> to what they were when the context was
  created. There is no localization or anything done here, calling this method
  will actually set these vars.
  
  =item $! = $ctx->errno()
  
  The (numeric) value of C<$!> when the context was created.
  
  =item $? = $ctx->child_error()
  
  The value of C<$?> when the context was created.
  
  =item $@ = $ctx->eval_error()
  
  The value of C<$@> when the context was created.
  
  =back
  
  =head2 EVENT PRODUCTION METHODS
  
  =over 4
  
  =item $event = $ctx->pass()
  
  =item $event = $ctx->pass($name)
  
  This will send and return an L<Test2::Event::Pass> event. You may optionally
  provide a C<$name> for the assertion.
  
  The L<Test2::Event::Pass> is a specially crafted and optimized event, using
  this will help the performance of passing tests.
  
  =item $true = $ctx->pass_and_release()
  
  =item $true = $ctx->pass_and_release($name)
  
  This is a combination of C<pass()> and C<release()>. You can use this if you do
  not plan to do anything with the context after sending the event. This helps
  write more clear and compact code.
  
      sub shorthand {
          my ($bool, $name) = @_;
          my $ctx = context();
          return $ctx->pass_and_release($name) if $bool;
  
          ... Handle a failure ...
      }
  
      sub longform {
          my ($bool, $name) = @_;
          my $ctx = context();
  
          if ($bool) {
              $ctx->pass($name);
              $ctx->release;
              return 1;
          }
  
          ... Handle a failure ...
      }
  
  =item my $event = $ctx->fail()
  
  =item my $event = $ctx->fail($name)
  
  =item my $event = $ctx->fail($name, @diagnostics)
  
  This lets you send an L<Test2::Event::Fail> event. You may optionally provide a
  C<$name> and C<@diagnostics> messages.
  
  =item my $false = $ctx->fail_and_release()
  
  =item my $false = $ctx->fail_and_release($name)
  
  =item my $false = $ctx->fail_and_release($name, @diagnostics)
  
  This is a combination of C<fail()> and C<release()>. This can be used to write
  clearer and shorter code.
  
      sub shorthand {
          my ($bool, $name) = @_;
          my $ctx = context();
          return $ctx->fail_and_release($name) unless $bool;
  
          ... Handle a success ...
      }
  
      sub longform {
          my ($bool, $name) = @_;
          my $ctx = context();
  
          unless ($bool) {
              $ctx->pass($name);
              $ctx->release;
              return 1;
          }
  
          ... Handle a success ...
      }
  
  
  =item $event = $ctx->ok($bool, $name)
  
  =item $event = $ctx->ok($bool, $name, \@on_fail)
  
  B<NOTE:> Use of this method is discouraged in favor of C<pass()> and C<fail()>
  which produce L<Test2::Event::Pass> and L<Test2::Event::Fail> events. These
  newer event types are faster and less crufty.
  
  This will create an L<Test2::Event::Ok> object for you. If C<$bool> is false
  then an L<Test2::Event::Diag> event will be sent as well with details about the
  failure. If you do not want automatic diagnostics you should use the
  C<send_event()> method directly.
  
  The third argument C<\@on_fail>) is an optional set of diagnostics to be sent in
  the event of a test failure.
  
  =item $event = $ctx->note($message)
  
  Send an L<Test2::Event::Note>. This event prints a message to STDOUT.
  
  =item $event = $ctx->diag($message)
  
  Send an L<Test2::Event::Diag>. This event prints a message to STDERR.
  
  =item $event = $ctx->plan($max)
  
  =item $event = $ctx->plan(0, 'SKIP', $reason)
  
  This can be used to send an L<Test2::Event::Plan> event. This event
  usually takes either a number of tests you expect to run. Optionally you can
  set the expected count to 0 and give the 'SKIP' directive with a reason to
  cause all tests to be skipped.
  
  =item $event = $ctx->skip($name, $reason);
  
  Send an L<Test2::Event::Skip> event.
  
  =item $event = $ctx->bail($reason)
  
  This sends an L<Test2::Event::Bail> event. This event will completely
  terminate all testing.
  
  =item $event = $ctx->send_event($Type, %parameters)
  
  This lets you build and send an event of any type. The C<$Type> argument should
  be the event package name with C<Test2::Event::> left off, or a fully
  qualified package name prefixed with a '+'. The event is returned after it is
  sent.
  
      my $event = $ctx->send_event('Ok', ...);
  
  or
  
      my $event = $ctx->send_event('+Test2::Event::Ok', ...);
  
  =item $event = $ctx->build_event($Type, %parameters)
  
  This is the same as C<send_event()>, except it builds and returns the event
  without sending it.
  
  =item $event = $ctx->send_event_and_release($Type, %parameters)
  
  This is a combination of C<send_event()> and C<release()>.
  
      sub shorthand {
          my $ctx = context();
          return $ctx->send_event_and_release(Pass => { name => 'foo' });
      }
  
      sub longform {
          my $ctx = context();
          my $event = $ctx->send_event(Pass => { name => 'foo' });
          $ctx->release;
          return $event;
      }
  
  =back
  
  =head1 HOOKS
  
  There are 2 types of hooks, init hooks, and release hooks. As the names
  suggest, these hooks are triggered when contexts are created or released.
  
  =head2 INIT HOOKS
  
  These are called whenever a context is initialized. That means when a new
  instance is created. These hooks are B<NOT> called every time something
  requests a context, just when a new one is created.
  
  =head3 GLOBAL
  
  This is how you add a global init callback. Global callbacks happen for every
  context for any hub or stack.
  
      Test2::API::test2_add_callback_context_init(sub {
          my $ctx = shift;
          ...
      });
  
  =head3 PER HUB
  
  This is how you add an init callback for all contexts created for a given hub.
  These callbacks will not run for other hubs.
  
      $hub->add_context_init(sub {
          my $ctx = shift;
          ...
      });
  
  =head3 PER CONTEXT
  
  This is how you specify an init hook that will only run if your call to
  C<context()> generates a new context. The callback will be ignored if
  C<context()> is returning an existing context.
  
      my $ctx = context(on_init => sub {
          my $ctx = shift;
          ...
      });
  
  =head2 RELEASE HOOKS
  
  These are called whenever a context is released. That means when the last
  reference to the instance is about to be destroyed. These hooks are B<NOT>
  called every time C<< $ctx->release >> is called.
  
  =head3 GLOBAL
  
  This is how you add a global release callback. Global callbacks happen for every
  context for any hub or stack.
  
      Test2::API::test2_add_callback_context_release(sub {
          my $ctx = shift;
          ...
      });
  
  =head3 PER HUB
  
  This is how you add a release callback for all contexts created for a given
  hub. These callbacks will not run for other hubs.
  
      $hub->add_context_release(sub {
          my $ctx = shift;
          ...
      });
  
  =head3 PER CONTEXT
  
  This is how you add release callbacks directly to a context. The callback will
  B<ALWAYS> be added to the context that gets returned, it does not matter if a
  new one is generated, or if an existing one is returned.
  
      my $ctx = context(on_release => sub {
          my $ctx = shift;
          ...
      });
  
  =head1 THIRD PARTY META-DATA
  
  This object consumes L<Test2::Util::ExternalMeta> which provides a consistent
  way for you to attach meta-data to instances of this class. This is useful for
  tools, plugins, and other extensions.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =item Kent Fredric E<lt>kentnl@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API_CONTEXT

$fatpacked{"Test2/API/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_INSTANCE';
  package Test2::API::Instance;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  our @CARP_NOT = qw/Test2::API Test2::API::Instance Test2::IPC::Driver Test2::Formatter/;
  use Carp qw/confess carp/;
  use Scalar::Util qw/reftype/;
  
  use Test2::Util qw/get_tid USE_THREADS CAN_FORK pkg_to_file try CAN_SIGSYS/;
  
  use Test2::EventFacet::Trace();
  use Test2::API::Stack();
  
  use Test2::Util::HashBase qw{
      _pid _tid
      no_wait
      finalized loaded
      ipc stack formatter
      contexts
  
      -preload
  
      ipc_shm_size
      ipc_shm_last
      ipc_shm_id
      ipc_polling
      ipc_drivers
      ipc_timeout
      formatters
  
      exit_callbacks
      post_load_callbacks
      context_acquire_callbacks
      context_init_callbacks
      context_release_callbacks
      pre_subtest_callbacks
  };
  
  sub DEFAULT_IPC_TIMEOUT() { 30 }
  
  sub pid { $_[0]->{+_PID} }
  sub tid { $_[0]->{+_TID} }
  
  # Wrap around the getters that should call _finalize.
  BEGIN {
      for my $finalizer (IPC, FORMATTER) {
          my $orig = __PACKAGE__->can($finalizer);
          my $new  = sub {
              my $self = shift;
              $self->_finalize unless $self->{+FINALIZED};
              $self->$orig;
          };
  
          no strict 'refs';
          no warnings 'redefine';
          *{$finalizer} = $new;
      }
  }
  
  sub has_ipc { !!$_[0]->{+IPC} }
  
  sub import {
      my $class = shift;
      return unless @_;
      my ($ref) = @_;
      $$ref = $class->new;
  }
  
  sub init { $_[0]->reset }
  
  sub start_preload {
      my $self = shift;
  
      confess "preload cannot be started, Test2::API has already been initialized"
          if $self->{+FINALIZED} || $self->{+LOADED};
  
      return $self->{+PRELOAD} = 1;
  }
  
  sub stop_preload {
      my $self = shift;
  
      return 0 unless $self->{+PRELOAD};
      $self->{+PRELOAD} = 0;
  
      $self->post_preload_reset();
  
      return 1;
  }
  
  sub post_preload_reset {
      my $self = shift;
  
      delete $self->{+_PID};
      delete $self->{+_TID};
  
      $self->{+CONTEXTS} = {};
  
      $self->{+FORMATTERS} = [];
  
      $self->{+FINALIZED} = undef;
      $self->{+IPC}       = undef;
  
      $self->{+IPC_TIMEOUT} = DEFAULT_IPC_TIMEOUT() unless defined $self->{+IPC_TIMEOUT};
  
      $self->{+LOADED} = 0;
  
      $self->{+STACK} ||= Test2::API::Stack->new;
  }
  
  sub reset {
      my $self = shift;
  
      delete $self->{+_PID};
      delete $self->{+_TID};
  
      $self->{+CONTEXTS}    = {};
  
      $self->{+IPC_DRIVERS} = [];
      $self->{+IPC_POLLING} = undef;
  
      $self->{+FORMATTERS} = [];
      $self->{+FORMATTER}  = undef;
  
      $self->{+FINALIZED} = undef;
      $self->{+IPC}       = undef;
  
      $self->{+IPC_TIMEOUT} = DEFAULT_IPC_TIMEOUT() unless defined $self->{+IPC_TIMEOUT};
  
      $self->{+NO_WAIT} = 0;
      $self->{+LOADED}  = 0;
  
      $self->{+EXIT_CALLBACKS}            = [];
      $self->{+POST_LOAD_CALLBACKS}       = [];
      $self->{+CONTEXT_ACQUIRE_CALLBACKS} = [];
      $self->{+CONTEXT_INIT_CALLBACKS}    = [];
      $self->{+CONTEXT_RELEASE_CALLBACKS} = [];
      $self->{+PRE_SUBTEST_CALLBACKS}     = [];
  
      $self->{+STACK} = Test2::API::Stack->new;
  }
  
  sub _finalize {
      my $self = shift;
      my ($caller) = @_;
      $caller ||= [caller(1)];
  
      confess "Attempt to initialize Test2::API during preload"
          if $self->{+PRELOAD};
  
      $self->{+FINALIZED} = $caller;
  
      $self->{+_PID} = $$        unless defined $self->{+_PID};
      $self->{+_TID} = get_tid() unless defined $self->{+_TID};
  
      unless ($self->{+FORMATTER}) {
          my ($formatter, $source);
          if ($ENV{T2_FORMATTER}) {
              $source = "set by the 'T2_FORMATTER' environment variable";
  
              if ($ENV{T2_FORMATTER} =~ m/^(\+)?(.*)$/) {
                  $formatter = $1 ? $2 : "Test2::Formatter::$2"
              }
              else {
                  $formatter = '';
              }
          }
          elsif (@{$self->{+FORMATTERS}}) {
              ($formatter) = @{$self->{+FORMATTERS}};
              $source = "Most recently added";
          }
          else {
              $formatter = 'Test2::Formatter::TAP';
              $source    = 'default formatter';
          }
  
          unless (ref($formatter) || $formatter->can('write')) {
              my $file = pkg_to_file($formatter);
              my ($ok, $err) = try { require $file };
              unless ($ok) {
                  my $line   = "* COULD NOT LOAD FORMATTER '$formatter' ($source) *";
                  my $border = '*' x length($line);
                  die "\n\n  $border\n  $line\n  $border\n\n$err";
              }
          }
  
          $self->{+FORMATTER} = $formatter;
      }
  
      # Turn on IPC if threads are on, drivers are registered, or the Test2::IPC
      # module is loaded.
      return unless USE_THREADS || $INC{'Test2/IPC.pm'} || @{$self->{+IPC_DRIVERS}};
  
      # Turn on polling by default, people expect it.
      $self->enable_ipc_polling;
  
      unless (@{$self->{+IPC_DRIVERS}}) {
          my ($ok, $error) = try { require Test2::IPC::Driver::Files };
          die $error unless $ok;
          push @{$self->{+IPC_DRIVERS}} => 'Test2::IPC::Driver::Files';
      }
  
      for my $driver (@{$self->{+IPC_DRIVERS}}) {
          next unless $driver->can('is_viable') && $driver->is_viable;
          $self->{+IPC} = $driver->new or next;
          $self->ipc_enable_shm if $self->{+IPC}->use_shm;
          return;
      }
  
      die "IPC has been requested, but no viable drivers were found. Aborting...\n";
  }
  
  sub formatter_set { $_[0]->{+FORMATTER} ? 1 : 0 }
  
  sub add_formatter {
      my $self = shift;
      my ($formatter) = @_;
      unshift @{$self->{+FORMATTERS}} => $formatter;
  
      return unless $self->{+FINALIZED};
  
      # Why is the @CARP_NOT entry not enough?
      local %Carp::Internal = %Carp::Internal;
      $Carp::Internal{'Test2::Formatter'} = 1;
  
      carp "Formatter $formatter loaded too late to be used as the global formatter";
  }
  
  sub add_context_acquire_callback {
      my $self =  shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Context-acquire callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+CONTEXT_ACQUIRE_CALLBACKS}} => $code;
  }
  
  sub add_context_init_callback {
      my $self =  shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Context-init callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+CONTEXT_INIT_CALLBACKS}} => $code;
  }
  
  sub add_context_release_callback {
      my $self =  shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Context-release callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+CONTEXT_RELEASE_CALLBACKS}} => $code;
  }
  
  sub add_post_load_callback {
      my $self = shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Post-load callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+POST_LOAD_CALLBACKS}} => $code;
      $code->() if $self->{+LOADED};
  }
  
  sub add_pre_subtest_callback {
      my $self =  shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Pre-subtest callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+PRE_SUBTEST_CALLBACKS}} => $code;
  }
  
  sub load {
      my $self = shift;
      unless ($self->{+LOADED}) {
          confess "Attempt to initialize Test2::API during preload"
              if $self->{+PRELOAD};
  
          $self->{+_PID} = $$        unless defined $self->{+_PID};
          $self->{+_TID} = get_tid() unless defined $self->{+_TID};
  
          # This is for https://github.com/Test-More/test-more/issues/16
          # and https://rt.perl.org/Public/Bug/Display.html?id=127774
          # END blocks run in reverse order. This insures the END block is loaded
          # as late as possible. It will not solve all cases, but it helps.
          eval "END { Test2::API::test2_set_is_end() }; 1" or die $@;
  
          $self->{+LOADED} = 1;
          $_->() for @{$self->{+POST_LOAD_CALLBACKS}};
      }
      return $self->{+LOADED};
  }
  
  sub add_exit_callback {
      my $self = shift;
      my ($code) = @_;
      my $rtype = reftype($code) || "";
  
      confess "End callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+EXIT_CALLBACKS}} => $code;
  }
  
  sub add_ipc_driver {
      my $self = shift;
      my ($driver) = @_;
      unshift @{$self->{+IPC_DRIVERS}} => $driver;
  
      return unless $self->{+FINALIZED};
  
      # Why is the @CARP_NOT entry not enough?
      local %Carp::Internal = %Carp::Internal;
      $Carp::Internal{'Test2::IPC::Driver'} = 1;
  
      carp "IPC driver $driver loaded too late to be used as the global ipc driver";
  }
  
  sub enable_ipc_polling {
      my $self = shift;
  
      $self->{+_PID} = $$        unless defined $self->{+_PID};
      $self->{+_TID} = get_tid() unless defined $self->{+_TID};
  
      $self->add_context_init_callback(
          # This is called every time a context is created, it needs to be fast.
          # $_[0] is a context object
          sub {
              return unless $self->{+IPC_POLLING};
              return $_[0]->{hub}->cull unless $self->{+IPC_SHM_ID};
  
              my $val;
              if(shmread($self->{+IPC_SHM_ID}, $val, 0, $self->{+IPC_SHM_SIZE})) {
                  return if $val eq $self->{+IPC_SHM_LAST};
                  $self->{+IPC_SHM_LAST} = $val;
              }
              else {
                  warn "SHM Read error: $!\n";
              }
  
              $_[0]->{hub}->cull;
          }
      ) unless defined $self->ipc_polling;
  
      $self->set_ipc_polling(1);
  }
  
  sub ipc_enable_shm {
      my $self = shift;
  
      return 1 if defined $self->{+IPC_SHM_ID};
  
      $self->{+_PID} = $$        unless defined $self->{+_PID};
      $self->{+_TID} = get_tid() unless defined $self->{+_TID};
  
      my ($ok, $err) = try {
          # SysV IPC can be available but not enabled.
          #
          # In some systems (*BSD) accessing the SysV IPC APIs without
          # them being enabled can cause a SIGSYS.  We suppress the SIGSYS
          # and then get ENOSYS from the calls.
          local $SIG{SYS} = 'IGNORE' if CAN_SIGSYS;
  
          require IPC::SysV;
  
          my $ipc_key = IPC::SysV::IPC_PRIVATE();
          my $shm_size = $self->{+IPC}->can('shm_size') ? $self->{+IPC}->shm_size : 64;
          my $shm_id = shmget($ipc_key, $shm_size, 0666) or die "Could not get shm: $!";
  
          my $initial = 'a' x $shm_size;
          shmwrite($shm_id, $initial, 0, $shm_size) or die "Could not write to shm: $!";
          my $val;
          shmread($shm_id, $val, 0, $shm_size) or die "Could not read from shm: $!";
          die "Read SHM value does not match the initial value ('$val' vs '$initial')"
              unless $val eq $initial;
  
          $self->{+IPC_SHM_SIZE} = $shm_size;
          $self->{+IPC_SHM_ID}   = $shm_id;
          $self->{+IPC_SHM_LAST} = $initial;
      };
  
      return $ok;
  }
  
  sub ipc_free_shm {
      my $self = shift;
  
      my $id = delete $self->{+IPC_SHM_ID};
      return unless defined $id;
  
      shmctl($id, IPC::SysV::IPC_RMID(), 0);
  }
  
  sub get_ipc_pending {
      my $self = shift;
      return -1 unless defined $self->{+IPC_SHM_ID};
      my $val;
      shmread($self->{+IPC_SHM_ID}, $val, 0, $self->{+IPC_SHM_SIZE}) or return -1;
      return 0 if $val eq $self->{+IPC_SHM_LAST};
      $self->{+IPC_SHM_LAST} = $val;
      return 1;
  }
  
  sub set_ipc_pending {
      my $self = shift;
  
      return undef unless defined $self->{+IPC_SHM_ID};
  
      my ($val) = @_;
  
      confess "value is required for set_ipc_pending"
          unless $val;
  
      shmwrite($self->{+IPC_SHM_ID}, $val, 0, $self->{+IPC_SHM_SIZE});
  }
  
  sub disable_ipc_polling {
      my $self = shift;
      return unless defined $self->{+IPC_POLLING};
      $self->{+IPC_POLLING} = 0;
  }
  
  sub _ipc_wait {
      my ($timeout) = @_;
      my $fail = 0;
  
      $timeout = DEFAULT_IPC_TIMEOUT() unless defined $timeout;
  
      my $ok = eval {
          if (CAN_FORK) {
              local $SIG{ALRM} = sub { die "Timeout waiting on child processes" };
              alarm $timeout;
  
              while (1) {
                  my $pid = CORE::wait();
                  my $err = $?;
                  last if $pid == -1;
                  next unless $err;
                  $fail++;
  
                  my $sig = $err & 127;
                  my $exit = $err >> 8;
                  warn "Process $pid did not exit cleanly (wstat: $err, exit: $exit, sig: $sig)\n";
              }
  
              alarm 0;
          }
  
          if (USE_THREADS) {
              my $start = time;
  
              while (1) {
                  last unless threads->list();
                  die "Timeout waiting on child thread" if time - $start >= $timeout;
                  sleep 1;
                  for my $t (threads->list) {
                      # threads older than 1.34 do not have this :-(
                      next if $t->can('is_joinable') && !$t->is_joinable;
                      $t->join;
                      # In older threads we cannot check if a thread had an error unless
                      # we control it and its return.
                      my $err = $t->can('error') ? $t->error : undef;
                      next unless $err;
                      my $tid = $t->tid();
                      $fail++;
                      chomp($err);
                      warn "Thread $tid did not end cleanly: $err\n";
                  }
              }
          }
  
          1;
      };
      my $error = $@;
  
      return 0 if $ok && !$fail;
      warn $error unless $ok;
      return 255;
  }
  
  sub DESTROY {
      my $self = shift;
  
      return if $self->{+PRELOAD};
  
      return unless defined($self->{+_PID}) && $self->{+_PID} == $$;
      return unless defined($self->{+_TID}) && $self->{+_TID} == get_tid();
  
      shmctl($self->{+IPC_SHM_ID}, IPC::SysV::IPC_RMID(), 0)
          if defined $self->{+IPC_SHM_ID};
  }
  
  sub set_exit {
      my $self = shift;
  
      return if $self->{+PRELOAD};
  
      my $exit     = $?;
      my $new_exit = $exit;
  
      if ($INC{'Test/Builder.pm'} && $Test::Builder::VERSION ne $Test2::API::VERSION) {
          print STDERR <<"        EOT";
  
  ********************************************************************************
  *                                                                              *
  *            Test::Builder -- Test2::API version mismatch detected             *
  *                                                                              *
  ********************************************************************************
     Test2::API Version: $Test2::API::VERSION
  Test::Builder Version: $Test::Builder::VERSION
  
  This is not a supported configuration, you will have problems.
  
          EOT
      }
  
      for my $ctx (values %{$self->{+CONTEXTS}}) {
          next unless $ctx;
  
          next if $ctx->_aborted && ${$ctx->_aborted};
  
          # Only worry about contexts in this PID
          my $trace = $ctx->trace || next;
          next unless $trace->pid && $trace->pid == $$;
  
          # Do not worry about contexts that have no hub
          my $hub = $ctx->hub  || next;
  
          # Do not worry if the state came to a sudden end.
          next if $hub->bailed_out;
          next if defined $hub->skip_reason;
  
          # now we worry
          $trace->alert("context object was never released! This means a testing tool is behaving very badly");
  
          $exit     = 255;
          $new_exit = 255;
      }
  
      if (!defined($self->{+_PID}) or !defined($self->{+_TID}) or $self->{+_PID} != $$ or $self->{+_TID} != get_tid()) {
          $? = $exit;
          return;
      }
  
      my @hubs = $self->{+STACK} ? $self->{+STACK}->all : ();
  
      if (@hubs and $self->{+IPC} and !$self->{+NO_WAIT}) {
          local $?;
          my %seen;
          for my $hub (reverse @hubs) {
              my $ipc = $hub->ipc or next;
              next if $seen{$ipc}++;
              $ipc->waiting();
          }
  
          my $ipc_exit = _ipc_wait($self->{+IPC_TIMEOUT});
          $new_exit ||= $ipc_exit;
      }
  
      # None of this is necessary if we never got a root hub
      if(my $root = shift @hubs) {
          my $trace = Test2::EventFacet::Trace->new(
              frame  => [__PACKAGE__, __FILE__, 0, __PACKAGE__ . '::END'],
              detail => __PACKAGE__ . ' END Block finalization',
          );
          my $ctx = Test2::API::Context->new(
              trace => $trace,
              hub   => $root,
          );
  
          if (@hubs) {
              $ctx->diag("Test ended with extra hubs on the stack!");
              $new_exit  = 255;
          }
  
          unless ($root->no_ending) {
              local $?;
              $root->finalize($trace) unless $root->ended;
              $_->($ctx, $exit, \$new_exit) for @{$self->{+EXIT_CALLBACKS}};
              $new_exit ||= $root->failed;
              $new_exit ||= 255 unless $root->is_passing;
          }
      }
  
      $new_exit = 255 if $new_exit > 255;
  
      if ($new_exit && eval { require Test2::API::Breakage; 1 }) {
          my @warn = Test2::API::Breakage->report();
  
          if (@warn) {
              print STDERR "\nYou have loaded versions of test modules known to have problems with Test2.\nThis could explain some test failures.\n";
              print STDERR "$_\n" for @warn;
              print STDERR "\n";
          }
      }
  
      $? = $new_exit;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API::Instance - Object used by Test2::API under the hood
  
  =head1 DESCRIPTION
  
  This object encapsulates the global shared state tracked by
  L<Test2>. A single global instance of this package is stored (and
  obscured) by the L<Test2::API> package.
  
  There is no reason to directly use this package. This package is documented for
  completeness. This package can change, or go away completely at any time.
  Directly using, or monkeypatching this package is not supported in any way
  shape or form.
  
  =head1 SYNOPSIS
  
      use Test2::API::Instance;
  
      my $obj = Test2::API::Instance->new;
  
  =over 4
  
  =item $pid = $obj->pid
  
  PID of this instance.
  
  =item $obj->tid
  
  Thread ID of this instance.
  
  =item $obj->reset()
  
  Reset the object to defaults.
  
  =item $obj->load()
  
  Set the internal state to loaded, and run and stored post-load callbacks.
  
  =item $bool = $obj->loaded
  
  Check if the state is set to loaded.
  
  =item $arrayref = $obj->post_load_callbacks
  
  Get the post-load callbacks.
  
  =item $obj->add_post_load_callback(sub { ... })
  
  Add a post-load callback. If C<load()> has already been called then the callback will
  be immediately executed. If C<load()> has not been called then the callback will be
  stored and executed later when C<load()> is called.
  
  =item $hashref = $obj->contexts()
  
  Get a hashref of all active contexts keyed by hub id.
  
  =item $arrayref = $obj->context_acquire_callbacks
  
  Get all context acquire callbacks.
  
  =item $arrayref = $obj->context_init_callbacks
  
  Get all context init callbacks.
  
  =item $arrayref = $obj->context_release_callbacks
  
  Get all context release callbacks.
  
  =item $arrayref = $obj->pre_subtest_callbacks
  
  Get all pre-subtest callbacks.
  
  =item $obj->add_context_init_callback(sub { ... })
  
  Add a context init callback. Subs are called every time a context is created. Subs
  get the newly created context as their only argument.
  
  =item $obj->add_context_release_callback(sub { ... })
  
  Add a context release callback. Subs are called every time a context is released. Subs
  get the released context as their only argument. These callbacks should not
  call release on the context.
  
  =item $obj->add_pre_subtest_callback(sub { ... })
  
  Add a pre-subtest callback. Subs are called every time a subtest is
  going to be run. Subs get the subtest name, coderef, and any
  arguments.
  
  =item $obj->set_exit()
  
  This is intended to be called in an C<END { ... }> block. This will look at
  test state and set $?. This will also call any end callbacks, and wait on child
  processes/threads.
  
  =item $obj->ipc_enable_shm()
  
  Turn on SHM for IPC (if possible)
  
  =item $shm_id = $obj->ipc_shm_id()
  
  If SHM is enabled for IPC this will be the shm_id for it.
  
  =item $shm_size = $obj->ipc_shm_size()
  
  If SHM is enabled for IPC this will be the size of it.
  
  =item $shm_last_val = $obj->ipc_shm_last()
  
  If SHM is enabled for IPC this will return the last SHM value seen.
  
  =item $obj->set_ipc_pending($val)
  
  use the IPC SHM to tell other processes and threads there is a pending event.
  C<$val> should be a unique value no other thread/process will generate.
  
  B<Note:> This will also make the current process see a pending event. It does
  not set C<ipc_shm_last()>, this is important because doing so could hide a
  previous change.
  
  =item $pending = $obj->get_ipc_pending()
  
  This returns -1 if SHM is not enabled for IPC.
  
  This returns 0 if the SHM value matches the last known value, which means there
  are no pending events.
  
  This returns 1 if the SHM value has changed, which means there are probably
  pending events.
  
  When 1 is returned this will set C<< $obj->ipc_shm_last() >>.
  
  =item $timeout = $obj->ipc_timeout;
  
  =item $obj->set_ipc_timeout($timeout);
  
  How long to wait for child processes and threads before aborting.
  
  =item $drivers = $obj->ipc_drivers
  
  Get the list of IPC drivers.
  
  =item $obj->add_ipc_driver($DRIVER_CLASS)
  
  Add an IPC driver to the list. The most recently added IPC driver will become
  the global one during initialization. If a driver is added after initialization
  has occurred a warning will be generated:
  
      "IPC driver $driver loaded too late to be used as the global ipc driver"
  
  =item $bool = $obj->ipc_polling
  
  Check if polling is enabled.
  
  =item $obj->enable_ipc_polling
  
  Turn on polling. This will cull events from other processes and threads every
  time a context is created.
  
  =item $obj->disable_ipc_polling
  
  Turn off IPC polling.
  
  =item $bool = $obj->no_wait
  
  =item $bool = $obj->set_no_wait($bool)
  
  Get/Set no_wait. This option is used to turn off process/thread waiting at exit.
  
  =item $arrayref = $obj->exit_callbacks
  
  Get the exit callbacks.
  
  =item $obj->add_exit_callback(sub { ... })
  
  Add an exit callback. This callback will be called by C<set_exit()>.
  
  =item $bool = $obj->finalized
  
  Check if the object is finalized. Finalization happens when either C<ipc()>,
  C<stack()>, or C<format()> are called on the object. Once finalization happens
  these fields are considered unchangeable (not enforced here, enforced by
  L<Test2>).
  
  =item $ipc = $obj->ipc
  
  Get the one true IPC instance.
  
  =item $stack = $obj->stack
  
  Get the one true hub stack.
  
  =item $formatter = $obj->formatter
  
  Get the global formatter. By default this is the C<'Test2::Formatter::TAP'>
  package. This could be any package that implements the C<write()> method. This
  can also be an instantiated object.
  
  =item $bool = $obj->formatter_set()
  
  Check if a formatter has been set.
  
  =item $obj->add_formatter($class)
  
  =item $obj->add_formatter($obj)
  
  Add a formatter. The most recently added formatter will become the global one
  during initialization. If a formatter is added after initialization has occurred
  a warning will be generated:
  
      "Formatter $formatter loaded too late to be used as the global formatter"
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API_INSTANCE

$fatpacked{"Test2/API/Stack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_STACK';
  package Test2::API::Stack;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  use Test2::Hub();
  
  use Carp qw/confess/;
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub new_hub {
      my $self = shift;
      my %params = @_;
  
      my $class = delete $params{class} || 'Test2::Hub';
  
      my $hub = $class->new(%params);
  
      if (@$self) {
          $hub->inherit($self->[-1], %params);
      }
      else {
          require Test2::API;
          $hub->format(Test2::API::test2_formatter()->new_root)
              unless $hub->format || exists($params{formatter});
  
          my $ipc = Test2::API::test2_ipc();
          if ($ipc && !$hub->ipc && !exists($params{ipc})) {
              $hub->set_ipc($ipc);
              $ipc->add_hub($hub->hid);
          }
      }
  
      push @$self => $hub;
  
      $hub;
  }
  
  sub top {
      my $self = shift;
      return $self->new_hub unless @$self;
      return $self->[-1];
  }
  
  sub peek {
      my $self = shift;
      return @$self ? $self->[-1] : undef;
  }
  
  sub cull {
      my $self = shift;
      $_->cull for reverse @$self;
  }
  
  sub all {
      my $self = shift;
      return @$self;
  }
  
  sub clear {
      my $self = shift;
      @$self = ();
  }
  
  # Do these last without keywords in order to prevent them from getting used
  # when we want the real push/pop.
  
  {
      no warnings 'once';
  
      *push = sub {
          my $self = shift;
          my ($hub) = @_;
          $hub->inherit($self->[-1]) if @$self;
          push @$self => $hub;
      };
  
      *pop = sub {
          my $self = shift;
          my ($hub) = @_;
          confess "No hubs on the stack"
              unless @$self;
          confess "You cannot pop the root hub"
              if 1 == @$self;
          confess "Hub stack mismatch, attempted to pop incorrect hub"
              unless $self->[-1] == $hub;
          pop @$self;
      };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API::Stack - Object to manage a stack of L<Test2::Hub>
  instances.
  
  =head1 ***INTERNALS NOTE***
  
  B<The internals of this package are subject to change at any time!> The public
  methods provided will not change in backwards incompatible ways, but the
  underlying implementation details might. B<Do not break encapsulation here!>
  
  =head1 DESCRIPTION
  
  This module is used to represent and manage a stack of L<Test2::Hub>
  objects. Hubs are usually in a stack so that you can push a new hub into place
  that can intercept and handle events differently than the primary hub.
  
  =head1 SYNOPSIS
  
      my $stack = Test2::API::Stack->new;
      my $hub = $stack->top;
  
  =head1 METHODS
  
  =over 4
  
  =item $stack = Test2::API::Stack->new()
  
  This will create a new empty stack instance. All arguments are ignored.
  
  =item $hub = $stack->new_hub()
  
  =item $hub = $stack->new_hub(%params)
  
  =item $hub = $stack->new_hub(%params, class => $class)
  
  This will generate a new hub and push it to the top of the stack. Optionally
  you can provide arguments that will be passed into the constructor for the
  L<Test2::Hub> object.
  
  If you specify the C<< 'class' => $class >> argument, the new hub will be an
  instance of the specified class.
  
  Unless your parameters specify C<'formatter'> or C<'ipc'> arguments, the
  formatter and IPC instance will be inherited from the current top hub. You can
  set the parameters to C<undef> to avoid having a formatter or IPC instance.
  
  If there is no top hub, and you do not ask to leave IPC and formatter undef,
  then a new formatter will be created, and the IPC instance from
  L<Test2::API> will be used.
  
  =item $hub = $stack->top()
  
  This will return the top hub from the stack. If there is no top hub yet this
  will create it.
  
  =item $hub = $stack->peek()
  
  This will return the top hub from the stack. If there is no top hub yet this
  will return undef.
  
  =item $stack->cull
  
  This will call C<< $hub->cull >> on all hubs in the stack.
  
  =item @hubs = $stack->all
  
  This will return all the hubs in the stack as a list.
  
  =item $stack->clear
  
  This will completely remove all hubs from the stack. Normally you do not want
  to do this, but there are a few valid reasons for it.
  
  =item $stack->push($hub)
  
  This will push the new hub onto the stack.
  
  =item $stack->pop($hub)
  
  This will pop a hub from the stack, if the hub at the top of the stack does not
  match the hub you expect (passed in as an argument) it will throw an exception.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API_STACK

$fatpacked{"Test2/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT';
  package Test2::Event;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  use Test2::Util::HashBase qw/trace -amnesty/;
  use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;
  use Test2::Util qw(pkg_to_file);
  
  use Test2::EventFacet::About();
  use Test2::EventFacet::Amnesty();
  use Test2::EventFacet::Assert();
  use Test2::EventFacet::Control();
  use Test2::EventFacet::Error();
  use Test2::EventFacet::Info();
  use Test2::EventFacet::Meta();
  use Test2::EventFacet::Parent();
  use Test2::EventFacet::Plan();
  use Test2::EventFacet::Trace();
  
  my @FACET_TYPES = qw{
      Test2::EventFacet::About
      Test2::EventFacet::Amnesty
      Test2::EventFacet::Assert
      Test2::EventFacet::Control
      Test2::EventFacet::Error
      Test2::EventFacet::Info
      Test2::EventFacet::Meta
      Test2::EventFacet::Parent
      Test2::EventFacet::Plan
      Test2::EventFacet::Trace
  };
  
  sub FACET_TYPES() { @FACET_TYPES }
  
  # Legacy tools will expect this to be loaded now
  require Test2::Util::Trace;
  
  
  sub causes_fail      { 0 }
  sub increments_count { 0 }
  sub diagnostics      { 0 }
  sub no_display       { 0 }
  sub subtest_id       { undef }
  
  sub callback { }
  
  sub terminate { () }
  sub global    { () }
  sub sets_plan { () }
  
  sub summary { ref($_[0]) }
  
  sub related {
      my $self = shift;
      my ($event) = @_;
  
      my $tracea = $self->trace  or return undef;
      my $traceb = $event->trace or return undef;
  
      my $siga = $tracea->signature or return undef;
      my $sigb = $traceb->signature or return undef;
  
      return 1 if $siga eq $sigb;
      return 0;
  }
  
  sub add_amnesty {
      my $self = shift;
  
      for my $am (@_) {
          $am = {%$am} if ref($am) ne 'ARRAY';
          $am = Test2::EventFacet::Amnesty->new($am);
  
          push @{$self->{+AMNESTY}} => $am;
      }
  }
  
  sub common_facet_data {
      my $self = shift;
  
      my %out;
  
      $out{about} = {package => ref($self) || undef};
  
      if (my $trace = $self->trace) {
          $out{trace} = { %$trace };
      }
  
      $out{amnesty} = [map {{ %{$_} }} @{$self->{+AMNESTY}}]
          if $self->{+AMNESTY};
  
      my $key = Test2::Util::ExternalMeta::META_KEY();
      if (my $hash = $self->{$key}) {
          $out{meta} = {%$hash};
      }
  
      return \%out;
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{about}->{details}    = $self->summary    || undef;
      $out->{about}->{no_display} = $self->no_display || undef;
  
      # Might be undef, we want to preserve that
      my $terminate = $self->terminate;
      $out->{control} = {
          global    => $self->global    || 0,
          terminate => $terminate,
          has_callback => $self->can('callback') == \&callback ? 0 : 1,
      };
  
      $out->{assert} = {
          no_debug => 1,                     # Legacy behavior
          pass     => $self->causes_fail ? 0 : 1,
          details  => $self->summary,
      } if $self->increments_count;
  
      $out->{parent} = {hid => $self->subtest_id} if $self->subtest_id;
  
      if (my @plan = $self->sets_plan) {
          $out->{plan} = {};
  
          $out->{plan}->{count}   = $plan[0] if defined $plan[0];
          $out->{plan}->{details} = $plan[2] if defined $plan[2];
  
          if ($plan[1]) {
              $out->{plan}->{skip} = 1 if $plan[1] eq 'SKIP';
              $out->{plan}->{none} = 1 if $plan[1] eq 'NO PLAN';
          }
  
          $out->{control}->{terminate} ||= 0 if $out->{plan}->{skip};
      }
  
      if ($self->causes_fail && !$out->{assert}) {
          $out->{errors} = [
              {
                  tag     => 'FAIL',
                  fail    => 1,
                  details => $self->summary,
              }
          ];
      }
  
      my %IGNORE = (trace => 1, about => 1, control => 1);
      my $do_info = !grep { !$IGNORE{$_} } keys %$out;
  
      if ($do_info && !$self->no_display && $self->diagnostics) {
          $out->{info} = [
              {
                  tag     => 'DIAG',
                  debug   => 1,
                  details => $self->summary,
              }
          ];
      }
  
      return $out;
  }
  
  sub facets {
      my $self = shift;
      my $data = $self->facet_data;
      my %out;
  
      for my $type (FACET_TYPES()) {
          my $key = $type->facet_key;
          next unless $data->{$key};
  
          if ($type->is_list) {
              $out{$key} = [map { $type->new($_) } @{$data->{$key}}];
          }
          else {
              $out{$key} = $type->new($data->{$key});
          }
      }
  
      return \%out;
  }
  
  sub nested {
      Carp::cluck("Use of Test2::Event->nested() is deprecated, use Test2::Event->trace->nested instead")
          if $ENV{AUTHOR_TESTING};
  
      $_[0]->{+TRACE}->{nested};
  }
  
  sub in_subtest {
      Carp::cluck("Use of Test2::Event->in_subtest() is deprecated, use Test2::Event->trace->hid instead")
          if $ENV{AUTHOR_TESTING};
  
      # Return undef if we are not nested, Legacy did not return the hid if nestign was 0.
      return undef unless $_[0]->{+TRACE}->{nested};
  
      $_[0]->{+TRACE}->{hid};
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event - Base class for events
  
  =head1 DESCRIPTION
  
  Base class for all event objects that get passed through
  L<Test2>.
  
  =head1 SYNOPSIS
  
      package Test2::Event::MyEvent;
      use strict;
      use warnings;
  
      # This will make our class an event subclass (required)
      use base 'Test2::Event';
  
      # Add some accessors (optional)
      # You are not obligated to use HashBase, you can use any object tool you
      # want, or roll your own accessors.
      use Test2::Util::HashBase qw/foo bar baz/;
  
      # Use this if you want the legacy API to be written for you, for this to
      # work you will need to implement a facet_data() method.
      use Test2::Util::Facets2Legacy;
  
      # Chance to initialize some defaults
      sub init {
          my $self = shift;
          # no other args in @_
  
          $self->set_foo('xxx') unless defined $self->foo;
  
          ...
      }
  
      # This is the new way for events to convey data to the Test2 system
      sub facet_data {
          my $self = shift;
  
          # Get common facets such as 'about', 'trace' 'amnesty', and 'meta'
          my $facet_data = $self->common_facet_data();
  
          # Are you making an assertion?
          $facet_data->{assert} = {pass => 1, details => 'my assertion'};
          ...
  
          return $facet_data;
      }
  
      1;
  
  =head1 METHODS
  
  =head2 GENERAL
  
  =over 4
  
  =item $trace = $e->trace
  
  Get a snapshot of the L<Test2::EventFacet::Trace> as it was when this event was
  generated
  
  =item $bool_or_undef = $e->related($e2)
  
  Check if 2 events are related. In this case related means their traces share a
  signature meaning they were created with the same context (or at the very least
  by contexts which share an id, which is the same thing unless someone is doing
  something very bad).
  
  This can be used to reliably link multiple events created by the same tool. For
  instance a failing test like C<ok(0, "fail"> will generate 2 events, one being
  a L<Test2::Event::Ok>, the other being a L<Test2::Event::Diag>, both of these
  events are related having been created under the same context and by the same
  initial tool (though multiple tools may have been nested under the initial
  one).
  
  This will return C<undef> if the relationship cannot be checked, which happens
  if either event has an incomplete or missing trace. This will return C<0> if
  the traces are complete, but do not match. C<1> will be returned if there is a
  match.
  
  =item $e->add_amnesty({tag => $TAG, details => $DETAILS});
  
  This can be used to add amnesty to this event. Amnesty only effects failing
  assertions in most cases, but some formatters may display them for passing
  assertions, or even non-assertions as well.
  
  Amnesty will prevent a failed assertion from causing the overall test to fail.
  In other words it marks a failure as expected and allowed.
  
  B<Note:> This is how 'TODO' is implemented under the hood. TODO is essentially
  amnesty with the 'TODO' tag. The details are the reason for the TODO.
  
  =back
  
  =head2 NEW API
  
  =over 4
  
  =item $hashref = $e->common_facet_data();
  
  This can be used by subclasses to generate a starting facet data hashref. This
  will populate the hashref with the trace, meta, amnesty, and about facets.
  These facets are nearly always produced the same way for all events.
  
  =item $hashref = $e->facet_data()
  
  If you do not override this then the default implementation will attempt to
  generate facets from the legacy API. This generation is limited only to what
  the legacy API can provide. It is recommended that you override this method and
  write out explicit facet data.
  
  =item $hashref = $e->facets()
  
  This takes the hashref from C<facet_data()> and blesses each facet into the
  proper C<Test2::EventFacet::*> subclass.
  
  =back
  
  =head3 WHAT ARE FACETS?
  
  Facets are how events convey their purpose to the Test2 internals and
  formatters. An event without facets will have no intentional effect on the
  overall test state, and will not be displayed at all by most formatters, except
  perhaps to say that an event of an unknown type was seen.
  
  Facets are produced by the C<facet_data()> subroutine, which you should
  nearly-always override. C<facet_data()> is expected to return a hashref where
  each key is the facet type, and the value is either a hashref with the data for
  that facet, or an array of hashref's. Some facets must be defined as single
  hashrefs, some must be defined as an array of hashrefs, No facets allow both.
  
  C<facet_data()> B<MUST NOT> bless the data it returns, the main hashref, and
  nested facet hashref's B<MUST> be bare, though items contained within each
  facet may be blessed. The data returned by this method B<should> also be copies
  of the internal data in order to prevent accidental state modification.
  
  C<facets()> takes the data from C<facet_data()> and blesses it into the
  C<Test2::EventFacet::*> packages. This is rarely used however, the EventFacet
  packages are primarily for convenience and documentation. The EventFacet
  classes are not used at all internally, instead the raw data is used.
  
  Here is a list of facet types by package. The packages are not used internally,
  but are where the documentation for each type is kept.
  
  B<Note:> Every single facet type has the C<'details'> field. This field is
  always intended for human consumption, and when provided, should explain the
  'why' for the facet. All other fields are facet specific.
  
  =over 4
  
  =item about => {...}
  
  L<Test2::EventFacet::About>
  
  This contains information about the event itself such as the event package
  name. The C<details> field for this facet is an overall summary of the event.
  
  =item assert => {...}
  
  L<Test2::EventFacet::Assert>
  
  This facet is used if an assertion was made. The C<details> field of this facet
  is the description of the assertion.
  
  =item control => {...}
  
  L<Test2::EventFacet::Control>
  
  This facet is used to tell the L<Test2::Event::Hub> about special actions the
  event causes. Things like halting all testing, terminating the current test,
  etc. In this facet the C<details> field explains why any special action was
  taken.
  
  B<Note:> This is how bail-out is implemented.
  
  =item meta => {...}
  
  L<Test2::EventFacet::Meta>
  
  The meta facet contains all the meta-data attached to the event. In this case
  the C<details> field has no special meaning, but may be present if something
  sets the 'details' meta-key on the event.
  
  =item parent => {...}
  
  L<Test2::EventFacet::Parent>
  
  This facet contains nested events and similar details for subtests. In this
  facet the C<details> field will typically be the name of the subtest.
  
  =item plan => {...}
  
  L<Test2::EventFacet::Plan>
  
  This facet tells the system that a plan has been set. The C<details> field of
  this is usually left empty, but when present explains why the plan is what it
  is, this is most useful if the plan is to skip-all.
  
  =item trace => {...}
  
  L<Test2::EventFacet::Trace>
  
  This facet contains information related to when and where the event was
  generated. This is how the test file and line number of a failure is known.
  This facet can also help you to tell if tests are related.
  
  In this facet the C<details> field overrides the "failed at test_file.t line
  42." message provided on assertion failure.
  
  =item amnesty => [{...}, ...]
  
  L<Test2::EventFacet::Amnesty>
  
  The amnesty facet is a list instead of a single item, this is important as
  amnesty can come from multiple places at once.
  
  For each instance of amnesty the C<details> field explains why amnesty was
  granted.
  
  B<Note:> Outside of formatters amnesty only acts to forgive a failing
  assertion.
  
  =item errors => [{...}, ...]
  
  L<Test2::EventFacet::Error>
  
  The errors facet is a list instead of a single item, any number of errors can
  be listed. In this facet C<details> describes the error, or may contain the raw
  error message itself (such as an exception). In perl exception may be blessed
  objects, as such the raw data for this facet may contain nested items which are
  blessed.
  
  Not all errors are considered fatal, there is a C<fail> field that must be set
  for an error to cause the test to fail.
  
  B<Note:> This facet is unique in that the field name is 'errors' while the
  package is 'Error'. This is because this is the only facet type that is both a
  list, and has a name where the plural is not the same as the singular. This may
  cause some confusion, but I feel it will be less confusing than the
  alternative.
  
  =item info => [{...}, ...]
  
  L<Test2::EventFacet::Info>
  
  The 'info' facet is a list instead of a single item, any quantity of extra
  information can be attached to an event. Some information may be critical
  diagnostics, others may be simply commentary in nature, this is determined by
  the C<debug> flag.
  
  For this facet the C<details> flag is the info itself. This info may be a
  string, or it may be a data structure to display. This is one of the few facet
  types that may contain blessed items.
  
  =back
  
  =head2 LEGACY API
  
  =over 4
  
  =item $bool = $e->causes_fail
  
  Returns true if this event should result in a test failure. In general this
  should be false.
  
  =item $bool = $e->increments_count
  
  Should be true if this event should result in a test count increment.
  
  =item $e->callback($hub)
  
  If your event needs to have extra effects on the L<Test2::Hub> you can override
  this method.
  
  This is called B<BEFORE> your event is passed to the formatter.
  
  =item $num = $e->nested
  
  If this event is nested inside of other events, this should be the depth of
  nesting. (This is mainly for subtests)
  
  =item $bool = $e->global
  
  Set this to true if your event is global, that is ALL threads and processes
  should see it no matter when or where it is generated. This is not a common
  thing to want, it is used by bail-out and skip_all to end testing.
  
  =item $code = $e->terminate
  
  This is called B<AFTER> your event has been passed to the formatter. This
  should normally return undef, only change this if your event should cause the
  test to exit immediately.
  
  If you want this event to cause the test to exit you should return the exit
  code here. Exit code of 0 means exit success, any other integer means exit with
  failure.
  
  This is used by L<Test2::Event::Plan> to exit 0 when the plan is
  'skip_all'. This is also used by L<Test2::Event:Bail> to force the test
  to exit with a failure.
  
  This is called after the event has been sent to the formatter in order to
  ensure the event is seen and understood.
  
  =item $msg = $e->summary
  
  This is intended to be a human readable summary of the event. This should
  ideally only be one line long, but you can use multiple lines if necessary. This
  is intended for human consumption. You do not need to make it easy for machines
  to understand.
  
  The default is to simply return the event package name.
  
  =item ($count, $directive, $reason) = $e->sets_plan()
  
  Check if this event sets the testing plan. It will return an empty list if it
  does not. If it does set the plan it will return a list of 1 to 3 items in
  order: Expected Test Count, Test Directive, Reason for directive.
  
  =item $bool = $e->diagnostics
  
  True if the event contains diagnostics info. This is useful because a
  non-verbose harness may choose to hide events that are not in this category.
  Some formatters may choose to send these to STDERR instead of STDOUT to ensure
  they are seen.
  
  =item $bool = $e->no_display
  
  False by default. This will return true on events that should not be displayed
  by formatters.
  
  =item $id = $e->in_subtest
  
  If the event is inside a subtest this should have the subtest ID.
  
  =item $id = $e->subtest_id
  
  If the event is a final subtest event, this should contain the subtest ID.
  
  =back
  
  =head1 THIRD PARTY META-DATA
  
  This object consumes L<Test2::Util::ExternalMeta> which provides a consistent
  way for you to attach meta-data to instances of this class. This is useful for
  tools, plugins, and other extensions.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT

$fatpacked{"Test2/Event/Bail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_BAIL';
  package Test2::Event::Bail;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw{reason buffered};
  
  # Make sure the tests terminate
  sub terminate { 255 };
  
  sub global { 1 };
  
  sub causes_fail { 1 }
  
  sub summary {
      my $self = shift;
      return "Bail out!  " . $self->{+REASON}
          if $self->{+REASON};
  
      return "Bail out!";
  }
  
  sub diagnostics { 1 }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->common_facet_data;
  
      $out->{control} = {
          global    => 1,
          halt      => 1,
          details   => $self->{+REASON},
          terminate => 255,
      };
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Bail - Bailout!
  
  =head1 DESCRIPTION
  
  The bailout event is generated when things go horribly wrong and you need to
  halt all testing in the current file.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Bail;
  
      my $ctx = context();
      my $event = $ctx->bail('Stuff is broken');
  
  =head1 METHODS
  
  Inherits from L<Test2::Event>. Also defines:
  
  =over 4
  
  =item $reason = $e->reason
  
  The reason for the bailout.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_BAIL

$fatpacked{"Test2/Event/Diag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_DIAG';
  package Test2::Event::Diag;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw/message/;
  
  sub init {
      $_[0]->{+MESSAGE} = 'undef' unless defined $_[0]->{+MESSAGE};
  }
  
  sub summary { $_[0]->{+MESSAGE} }
  
  sub diagnostics { 1 }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{info} = [
          {
              tag     => 'DIAG',
              debug   => 1,
              details => $self->{+MESSAGE},
          }
      ];
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Diag - Diag event type
  
  =head1 DESCRIPTION
  
  Diagnostics messages, typically rendered to STDERR.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Diag;
  
      my $ctx = context();
      my $event = $ctx->diag($message);
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $diag->message
  
  The message for the diag.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_DIAG

$fatpacked{"Test2/Event/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_ENCODING';
  package Test2::Event::Encoding;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  use Carp qw/croak/;
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw/encoding/;
  
  sub init {
      my $self = shift;
      defined $self->{+ENCODING} or croak "'encoding' is a required attribute";
  }
  
  sub summary { 'Encoding set to ' . $_[0]->{+ENCODING} }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->common_facet_data;
      $out->{control}->{encoding} = $self->{+ENCODING};
      $out->{about}->{details} = $self->summary;
      return $out;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Encoding - Set the encoding for the output stream
  
  =head1 DESCRIPTION
  
  The encoding event is generated when a test file wants to specify the encoding
  to be used when formatting its output. This event is intended to be produced
  by formatter classes and used for interpreting test names, message contents,
  etc.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Encoding;
  
      my $ctx = context();
      my $event = $ctx->send_event('Encoding', encoding => 'UTF-8');
  
  =head1 METHODS
  
  Inherits from L<Test2::Event>. Also defines:
  
  =over 4
  
  =item $encoding = $e->encoding
  
  The encoding being specified.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_ENCODING

$fatpacked{"Test2/Event/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_EXCEPTION';
  package Test2::Event::Exception;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw{error};
  
  sub init {
      my $self = shift;
      $self->{+ERROR} = "$self->{+ERROR}";
  }
  
  sub causes_fail { 1 }
  
  sub summary {
      my $self = shift;
      chomp(my $msg = "Exception: " . $self->{+ERROR});
      return $msg;
  }
  
  sub diagnostics { 1 }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->common_facet_data;
  
      $out->{errors} = [
          {
              tag     => 'ERROR',
              fail    => 1,
              details => $self->{+ERROR},
          }
      ];
  
      return $out;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Exception - Exception event
  
  =head1 DESCRIPTION
  
  An exception event will display to STDERR, and will prevent the overall test
  file from passing.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Exception;
  
      my $ctx = context();
      my $event = $ctx->send_event('Exception', error => 'Stuff is broken');
  
  =head1 METHODS
  
  Inherits from L<Test2::Event>. Also defines:
  
  =over 4
  
  =item $reason = $e->error
  
  The reason for the exception.
  
  =back
  
  =head1 CAVEATS
  
  Be aware that all exceptions are stringified during construction.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_EXCEPTION

$fatpacked{"Test2/Event/Fail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_FAIL';
  package Test2::Event::Fail;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  use Test2::EventFacet::Info;
  
  BEGIN {
      require Test2::Event;
      our @ISA = qw(Test2::Event);
      *META_KEY = \&Test2::Util::ExternalMeta::META_KEY;
  }
  
  use Test2::Util::HashBase qw{ -name -info };
  
  #############
  # Old API
  sub summary          { "fail" }
  sub increments_count { 1 }
  sub diagnostics      { 0 }
  sub no_display       { 0 }
  sub subtest_id       { undef }
  sub terminate        { () }
  sub global           { () }
  sub sets_plan        { () }
  
  sub causes_fail {
      my $self = shift;
      return 0 if $self->{+AMNESTY} && @{$self->{+AMNESTY}};
      return 1;
  }
  
  #############
  # New API
  
  sub add_info {
      my $self = shift;
  
      for my $in (@_) {
          $in = {%$in} if ref($in) ne 'ARRAY';
          $in = Test2::EventFacet::Info->new($in);
  
          push @{$self->{+INFO}} => $in;
      }
  }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->common_facet_data;
  
      $out->{about}->{details} = 'fail';
  
      $out->{assert} = {pass => 0, details => $self->{+NAME}};
  
      $out->{info} = [map {{ %{$_} }} @{$self->{+INFO}}] if $self->{+INFO};
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Fail - Event for a simple failed assertion
  
  =head1 DESCRIPTION
  
  This is an optimal representation of a failed assertion.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
  
      sub fail {
          my ($name) = @_;
          my $ctx = context();
          $ctx->fail($name);
          $ctx->release;
      }
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_FAIL

$fatpacked{"Test2/Event/Generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_GENERIC';
  package Test2::Event::Generic;
  use strict;
  use warnings;
  
  use Carp qw/croak/;
  use Scalar::Util qw/reftype/;
  
  our $VERSION = '1.302120';
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase;
  
  my @FIELDS = qw{
      causes_fail increments_count diagnostics no_display callback terminate
      global sets_plan summary facet_data
  };
  my %DEFAULTS = (
      causes_fail      => 0,
      increments_count => 0,
      diagnostics      => 0,
      no_display       => 0,
  );
  
  sub init {
      my $self = shift;
  
      for my $field (@FIELDS) {
          my $val = defined $self->{$field} ? delete $self->{$field} : $DEFAULTS{$field};
          next unless defined $val;
  
          my $set = "set_$field";
          $self->$set($val);
      }
  }
  
  for my $field (@FIELDS) {
      no strict 'refs';
  
      *$field = sub { exists $_[0]->{$field} ? $_[0]->{$field} : () }
          unless exists &{$field};
  
      *{"set_$field"} = sub { $_[0]->{$field} = $_[1] }
          unless exists &{"set_$field"};
  }
  
  sub can {
      my $self = shift;
      my ($name) = @_;
      return $self->SUPER::can($name) unless $name eq 'callback';
      return $self->{callback} || \&Test2::Event::callback;
  }
  
  sub facet_data {
      my $self = shift;
      return $self->{facet_data} || $self->SUPER::facet_data();
  }
  
  sub summary {
      my $self = shift;
      return $self->{summary} if defined $self->{summary};
      $self->SUPER::summary();
  }
  
  sub sets_plan {
      my $self = shift;
      return unless $self->{sets_plan};
      return @{$self->{sets_plan}};
  }
  
  sub callback {
      my $self = shift;
      my $cb = $self->{callback} || return;
      $self->$cb(@_);
  }
  
  sub set_global {
      my $self = shift;
      my ($bool) = @_;
  
      if(!defined $bool) {
          delete $self->{global};
          return undef;
      }
  
      $self->{global} = $bool;
  }
  
  sub set_callback {
      my $self = shift;
      my ($cb) = @_;
  
      if(!defined $cb) {
          delete $self->{callback};
          return undef;
      }
  
      croak "callback must be a code reference"
          unless ref($cb) && reftype($cb) eq 'CODE';
  
      $self->{callback} = $cb;
  }
  
  sub set_terminate {
      my $self = shift;
      my ($exit) = @_;
  
      if(!defined $exit) {
          delete $self->{terminate};
          return undef;
      }
  
      croak "terminate must be a positive integer"
         unless $exit =~ m/^\d+$/;
  
      $self->{terminate} = $exit;
  }
  
  sub set_sets_plan {
      my $self = shift;
      my ($plan) = @_;
  
      if(!defined $plan) {
          delete $self->{sets_plan};
          return undef;
      }
  
      croak "'sets_plan' must be an array reference"
          unless ref($plan) && reftype($plan) eq 'ARRAY';
  
      $self->{sets_plan} = $plan;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Generic - Generic event type.
  
  =head1 DESCRIPTION
  
  This is a generic event that lets you customize all fields in the event API.
  This is useful if you have need for a custom event that does not make sense as
  a published reusable event subclass.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
  
      sub send_custom_fail {
          my $ctx = shift;
  
          $ctx->send_event('Generic', causes_fail => 1, summary => 'The sky is falling');
  
          $ctx->release;
      }
  
      send_custom_fail();
  
  =head1 METHODS
  
  =over 4
  
  =item $e->facet_data($data)
  
  =item $data = $e->facet_data
  
  Get or set the facet data (see L<Test2::Event>). If no facet_data is set then
  C<< Test2::Event->facet_data >> will be called to produce facets from the other
  data.
  
  =item $e->callback($hub)
  
  Call the custom callback if one is set, otherwise this does nothing.
  
  =item $e->set_callback(sub { ... })
  
  Set the custom callback. The custom callback must be a coderef. The first
  argument to your callback will be the event itself, the second will be the
  L<Test2::Event::Hub> that is using the callback.
  
  =item $bool = $e->causes_fail
  
  =item $e->set_causes_fail($bool)
  
  Get/Set the C<causes_fail> attribute. This defaults to C<0>.
  
  =item $bool = $e->diagnostics
  
  =item $e->set_diagnostics($bool)
  
  Get/Set the C<diagnostics> attribute. This defaults to C<0>.
  
  =item $bool_or_undef = $e->global
  
  =item @bool_or_empty = $e->global
  
  =item $e->set_global($bool_or_undef)
  
  Get/Set the C<diagnostics> attribute. This defaults to an empty list which is
  undef in scalar context.
  
  =item $bool = $e->increments_count
  
  =item $e->set_increments_count($bool)
  
  Get/Set the C<increments_count> attribute. This defaults to C<0>.
  
  =item $bool = $e->no_display
  
  =item $e->set_no_display($bool)
  
  Get/Set the C<no_display> attribute. This defaults to C<0>.
  
  =item @plan = $e->sets_plan
  
  Get the plan if this event sets one. The plan is a list of up to 3 items:
  C<($count, $directive, $reason)>. C<$count> must be defined, the others may be
  undef, or may not exist at all.
  
  =item $e->set_sets_plan(\@plan)
  
  Set the plan. You must pass in an arrayref with up to 3 elements.
  
  =item $summary = $e->summary
  
  =item $e->set_summary($summary_or_undef)
  
  Get/Set the summary. This will default to the event package
  C<'Test2::Event::Generic'>. You can set it to any value. Setting this to
  C<undef> will reset it to the default.
  
  =item $int_or_undef = $e->terminate
  
  =item @int_or_empty = $e->terminate
  
  =item $e->set_terminate($int_or_undef)
  
  This will get/set the C<terminate> attribute. This defaults to undef in scalar
  context, or an empty list in list context. Setting this to undef will clear it
  completely. This must be set to a positive integer (0 or larger).
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_GENERIC

$fatpacked{"Test2/Event/Note.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_NOTE';
  package Test2::Event::Note;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw/message/;
  
  sub init {
      $_[0]->{+MESSAGE} = 'undef' unless defined $_[0]->{+MESSAGE};
  }
  
  sub summary { $_[0]->{+MESSAGE} }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{info} = [
          {
              tag     => 'NOTE',
              debug   => 0,
              details => $self->{+MESSAGE},
          }
      ];
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Note - Note event type
  
  =head1 DESCRIPTION
  
  Notes, typically rendered to STDOUT.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Note;
  
      my $ctx = context();
      my $event = $ctx->Note($message);
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $note->message
  
  The message for the note.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_NOTE

$fatpacked{"Test2/Event/Ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_OK';
  package Test2::Event::Ok;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw{
      pass effective_pass name todo
  };
  
  sub init {
      my $self = shift;
  
      # Do not store objects here, only true or false
      $self->{+PASS} = $self->{+PASS} ? 1 : 0;
      $self->{+EFFECTIVE_PASS} = $self->{+PASS} || (defined($self->{+TODO}) ? 1 : 0);
  }
  
  {
      no warnings 'redefine';
      sub set_todo {
          my $self = shift;
          my ($todo) = @_;
          $self->{+TODO} = $todo;
          $self->{+EFFECTIVE_PASS} = defined($todo) ? 1 : $self->{+PASS};
      }
  }
  
  sub increments_count { 1 };
  
  sub causes_fail { !$_[0]->{+EFFECTIVE_PASS} }
  
  sub summary {
      my $self = shift;
  
      my $name = $self->{+NAME} || "Nameless Assertion";
  
      my $todo = $self->{+TODO};
      if ($todo) {
          $name .= " (TODO: $todo)";
      }
      elsif (defined $todo) {
          $name .= " (TODO)"
      }
  
      return $name;
  }
  
  sub extra_amnesty {
      my $self = shift;
      return unless defined($self->{+TODO}) || ($self->{+EFFECTIVE_PASS} && !$self->{+PASS});
      return {
          tag       => 'TODO',
          details   => $self->{+TODO},
      };
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{assert}  = {
          no_debug => 1,                # Legacy behavior
          pass     => $self->{+PASS},
          details  => $self->{+NAME},
      };
  
      if (my @exra_amnesty = $self->extra_amnesty) {
          unshift @{$out->{amnesty}} => @exra_amnesty;
      }
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Ok - Ok event type
  
  =head1 DESCRIPTION
  
  Ok events are generated whenever you run a test that produces a result.
  Examples are C<ok()>, and C<is()>.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Ok;
  
      my $ctx = context();
      my $event = $ctx->ok($bool, $name, \@diag);
  
  or:
  
      my $ctx   = context();
      my $event = $ctx->send_event(
          'Ok',
          pass => $bool,
          name => $name,
      );
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $rb = $e->pass
  
  The original true/false value of whatever was passed into the event (but
  reduced down to 1 or 0).
  
  =item $name = $e->name
  
  Name of the test.
  
  =item $b = $e->effective_pass
  
  This is the true/false value of the test after TODO and similar modifiers are
  taken into account.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_OK

$fatpacked{"Test2/Event/Pass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_PASS';
  package Test2::Event::Pass;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  use Test2::EventFacet::Info;
  
  BEGIN {
      require Test2::Event;
      our @ISA = qw(Test2::Event);
      *META_KEY = \&Test2::Util::ExternalMeta::META_KEY;
  }
  
  use Test2::Util::HashBase qw{ -name -info };
  
  ##############
  # Old API
  sub summary          { "pass" }
  sub increments_count { 1 }
  sub causes_fail      { 0 }
  sub diagnostics      { 0 }
  sub no_display       { 0 }
  sub subtest_id       { undef }
  sub terminate        { () }
  sub global           { () }
  sub sets_plan        { () }
  
  ##############
  # New API
  
  sub add_info {
      my $self = shift;
  
      for my $in (@_) {
          $in = {%$in} if ref($in) ne 'ARRAY';
          $in = Test2::EventFacet::Info->new($in);
  
          push @{$self->{+INFO}} => $in;
      }
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{about}->{details} = 'pass';
  
      $out->{assert} = {pass => 1, details => $self->{+NAME}};
  
      $out->{info} = [map {{ %{$_} }} @{$self->{+INFO}}] if $self->{+INFO};
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Pass - Event for a simple passing assertion
  
  =head1 DESCRIPTION
  
  This is an optimal representation of a passing assertion.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
  
      sub pass {
          my ($name) = @_;
          my $ctx = context();
          $ctx->pass($name);
          $ctx->release;
      }
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_PASS

$fatpacked{"Test2/Event/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_PLAN';
  package Test2::Event::Plan;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw{max directive reason};
  
  use Carp qw/confess/;
  
  my %ALLOWED = (
      'SKIP'    => 1,
      'NO PLAN' => 1,
  );
  
  sub init {
      if ($_[0]->{+DIRECTIVE}) {
          $_[0]->{+DIRECTIVE} = 'SKIP'    if $_[0]->{+DIRECTIVE} eq 'skip_all';
          $_[0]->{+DIRECTIVE} = 'NO PLAN' if $_[0]->{+DIRECTIVE} eq 'no_plan';
  
          confess "'" . $_[0]->{+DIRECTIVE} . "' is not a valid plan directive"
              unless $ALLOWED{$_[0]->{+DIRECTIVE}};
      }
      else {
          confess "Cannot have a reason without a directive!"
              if defined $_[0]->{+REASON};
  
          confess "No number of tests specified"
              unless defined $_[0]->{+MAX};
  
          confess "Plan test count '" . $_[0]->{+MAX}  . "' does not appear to be a valid positive integer"
              unless $_[0]->{+MAX} =~ m/^\d+$/;
  
          $_[0]->{+DIRECTIVE} = '';
      }
  }
  
  sub sets_plan {
      my $self = shift;
      return (
          $self->{+MAX},
          $self->{+DIRECTIVE},
          $self->{+REASON},
      );
  }
  
  sub terminate {
      my $self = shift;
      # On skip_all we want to terminate the hub
      return 0 if $self->{+DIRECTIVE} && $self->{+DIRECTIVE} eq 'SKIP';
      return undef;
  }
  
  sub summary {
      my $self = shift;
      my $max = $self->{+MAX};
      my $directive = $self->{+DIRECTIVE};
      my $reason = $self->{+REASON};
  
      return "Plan is $max assertions"
          if $max || !$directive;
  
      return "Plan is '$directive', $reason"
          if $reason;
  
      return "Plan is '$directive'";
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{control}->{terminate} = $self->{+DIRECTIVE} eq 'SKIP' ? 0 : undef
          unless defined $out->{control}->{terminate};
  
      $out->{plan} = {count => $self->{+MAX}};
      $out->{plan}->{details} = $self->{+REASON} if defined $self->{+REASON};
  
      if (my $dir = $self->{+DIRECTIVE}) {
          $out->{plan}->{skip} = 1 if $dir eq 'SKIP';
          $out->{plan}->{none} = 1 if $dir eq 'NO PLAN';
      }
  
      return $out;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Plan - The event of a plan
  
  =head1 DESCRIPTION
  
  Plan events are fired off whenever a plan is declared, done testing is called,
  or a subtext completes.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Plan;
  
      my $ctx = context();
  
      # Plan for 10 tests to run
      my $event = $ctx->plan(10);
  
      # Plan to skip all tests (will exit 0)
      $ctx->plan(0, skip_all => "These tests need to be skipped");
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $num = $plan->max
  
  Get the number of expected tests
  
  =item $dir = $plan->directive
  
  Get the directive (such as TODO, skip_all, or no_plan).
  
  =item $reason = $plan->reason
  
  Get the reason for the directive.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_PLAN

$fatpacked{"Test2/Event/Skip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_SKIP';
  package Test2::Event::Skip;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  BEGIN { require Test2::Event::Ok; our @ISA = qw(Test2::Event::Ok) }
  use Test2::Util::HashBase qw{reason};
  
  sub init {
      my $self = shift;
      $self->SUPER::init;
      $self->{+EFFECTIVE_PASS} = 1;
  }
  
  sub causes_fail { 0 }
  
  sub summary {
      my $self = shift;
      my $out = $self->SUPER::summary(@_);
  
      if (my $reason = $self->reason) {
          $out .= " (SKIP: $reason)";
      }
      else {
          $out .= " (SKIP)";
      }
  
      return $out;
  }
  
  sub extra_amnesty {
      my $self = shift;
  
      my @out;
  
      push @out => {
          tag       => 'TODO',
          details   => $self->{+TODO},
      } if defined $self->{+TODO};
  
      push @out => {
          tag       => 'skip',
          details   => $self->{+REASON},
          inherited => 0,
      };
  
      return @out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Skip - Skip event type
  
  =head1 DESCRIPTION
  
  Skip events bump test counts just like L<Test2::Event::Ok> events, but
  they can never fail.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Skip;
  
      my $ctx = context();
      my $event = $ctx->skip($name, $reason);
  
  or:
  
      my $ctx   = context();
      my $event = $ctx->send_event(
          'Skip',
          name   => $name,
          reason => $reason,
      );
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $reason = $e->reason
  
  The original true/false value of whatever was passed into the event (but
  reduced down to 1 or 0).
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
TEST2_EVENT_SKIP

$fatpacked{"Test2/Event/Subtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_SUBTEST';
  package Test2::Event::Subtest;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  BEGIN { require Test2::Event::Ok; our @ISA = qw(Test2::Event::Ok) }
  use Test2::Util::HashBase qw{subevents buffered subtest_id};
  
  sub init {
      my $self = shift;
      $self->SUPER::init();
      $self->{+SUBEVENTS} ||= [];
      if ($self->{+EFFECTIVE_PASS}) {
          $_->set_effective_pass(1) for grep { $_->can('effective_pass') } @{$self->{+SUBEVENTS}};
      }
  }
  
  {
      no warnings 'redefine';
  
      sub set_subevents {
          my $self      = shift;
          my @subevents = @_;
  
          if ($self->{+EFFECTIVE_PASS}) {
              $_->set_effective_pass(1) for grep { $_->can('effective_pass') } @subevents;
          }
  
          $self->{+SUBEVENTS} = \@subevents;
      }
  
      sub set_effective_pass {
          my $self = shift;
          my ($pass) = @_;
  
          if ($pass) {
              $_->set_effective_pass(1) for grep { $_->can('effective_pass') } @{$self->{+SUBEVENTS}};
          }
          elsif ($self->{+EFFECTIVE_PASS} && !$pass) {
              for my $s (grep { $_->can('effective_pass') } @{$self->{+SUBEVENTS}}) {
                  $_->set_effective_pass(0) unless $s->can('todo') && defined $s->todo;
              }
          }
  
          $self->{+EFFECTIVE_PASS} = $pass;
      }
  }
  
  sub summary {
      my $self = shift;
  
      my $name = $self->{+NAME} || "Nameless Subtest";
  
      my $todo = $self->{+TODO};
      if ($todo) {
          $name .= " (TODO: $todo)";
      }
      elsif (defined $todo) {
          $name .= " (TODO)";
      }
  
      return $name;
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->SUPER::facet_data();
  
      $out->{parent} = {
          hid      => $self->subtest_id,
          children => [map {$_->facet_data} @{$self->{+SUBEVENTS}}],
          buffered => $self->{+BUFFERED},
      };
  
      return $out;
  }
  
  sub add_amnesty {
      my $self = shift;
  
      for my $am (@_) {
          $am = {%$am} if ref($am) ne 'ARRAY';
          $am = Test2::EventFacet::Amnesty->new($am);
  
          push @{$self->{+AMNESTY}} => $am;
  
          for my $e (@{$self->{+SUBEVENTS}}) {
              $e->add_amnesty($am->clone(inherited => 1));
          }
      }
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Subtest - Event for subtest types
  
  =head1 DESCRIPTION
  
  This class represents a subtest. This class is a subclass of
  L<Test2::Event::Ok>.
  
  =head1 ACCESSORS
  
  This class inherits from L<Test2::Event::Ok>.
  
  =over 4
  
  =item $arrayref = $e->subevents
  
  Returns the arrayref containing all the events from the subtest
  
  =item $bool = $e->buffered
  
  True if the subtest is buffered, that is all subevents render at once. If this
  is false it means all subevents render as they are produced.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_SUBTEST

$fatpacked{"Test2/Event/TAP/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_TAP_VERSION';
  package Test2::Event::TAP::Version;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  use Carp qw/croak/;
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw/version/;
  
  sub init {
      my $self = shift;
      defined $self->{+VERSION} or croak "'version' is a required attribute";
  }
  
  sub summary { 'TAP version ' . $_[0]->{+VERSION} }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{about}->{details} = $self->summary;
  
      push @{$out->{info}} => {
          tag     => 'INFO',
          debug   => 0,
          details => $self->summary,
      };
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::TAP::Version - Event for TAP version.
  
  =head1 DESCRIPTION
  
  This event is used if a TAP formatter wishes to set a version.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Encoding;
  
      my $ctx = context();
      my $event = $ctx->send_event('TAP::Version', version => 42);
  
  =head1 METHODS
  
  Inherits from L<Test2::Event>. Also defines:
  
  =over 4
  
  =item $version = $e->version
  
  The TAP version being parsed.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_TAP_VERSION

$fatpacked{"Test2/Event/Waiting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_WAITING';
  package Test2::Event::Waiting;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase;
  
  sub global { 1 };
  
  sub summary { "IPC is waiting for children to finish..." }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      push @{$out->{info}} => {
          tag     => 'INFO',
          debug   => 0,
          details => $self->summary,
      };
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Waiting - Tell all procs/threads it is time to be done
  
  =head1 DESCRIPTION
  
  This event has no data of its own. This event is sent out by the IPC system
  when the main process/thread is ready to end.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_WAITING

$fatpacked{"Test2/EventFacet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET';
  package Test2::EventFacet;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  use Test2::Util::HashBase qw/-details/;
  use Carp qw/croak/;
  
  my $SUBLEN = length(__PACKAGE__ . '::');
  sub facet_key {
      my $key = ref($_[0]) || $_[0];
      substr($key, 0, $SUBLEN, '');
      return lc($key);
  }
  
  sub is_list { 0 }
  
  sub clone {
      my $self = shift;
      my $type = ref($self);
      return bless {%$self, @_}, $type;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet - Base class for all event facets.
  
  =head1 DESCRIPTION
  
  Base class for all event facets.
  
  =head1 METHODS
  
  =over 4
  
  =item $key = $facet_class->facet_key()
  
  This will return the key for the facet in the facet data hash.
  
  =item $bool = $facet_class->is_list()
  
  This will return true if the facet should be in a list instead of a single
  item.
  
  =item $clone = $facet->clone()
  
  =item $clone = $facet->clone(%replace)
  
  This will make a shallow clone of the facet. You may specify fields to override
  as arguments.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET

$fatpacked{"Test2/EventFacet/About.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_ABOUT';
  package Test2::EventFacet::About;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -package -no_display };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::About - Facet with event details.
  
  =head1 DESCRIPTION
  
  This facet has information about the event, such as event package.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $about->{details}
  
  =item $string = $about->details()
  
  Summary about the event.
  
  =item $package = $about->{package}
  
  =item $package = $about->package()
  
  Event package name.
  
  =item $bool = $about->{no_display}
  
  =item $bool = $about->no_display()
  
  True if the event should be skipped by formatters.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_ABOUT

$fatpacked{"Test2/EventFacet/Amnesty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_AMNESTY';
  package Test2::EventFacet::Amnesty;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  sub is_list { 1 }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -tag -inherited };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Amnesty - Facet for assertion amnesty.
  
  =head1 DESCRIPTION
  
  This package represents what is expected in units of amnesty.
  
  =head1 NOTES
  
  This facet appears in a list instead of being a single item.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $amnesty->{details}
  
  =item $string = $amnesty->details()
  
  Human readable explanation of why amnesty was granted.
  
  Example: I<Not implemented yet, will fix>
  
  =item $short_string = $amnesty->{tag}
  
  =item $short_string = $amnesty->tag()
  
  Short string (usually 10 characters or less, not enforced, but may be truncated
  by renderers) categorizing the amnesty.
  
  =item $bool = $amnesty->{inherited}
  
  =item $bool = $amnesty->inherited()
  
  This will be true if the amnesty was granted to a parent event and inherited by
  this event, which is a child, such as an assertion within a subtest that is
  marked todo.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_AMNESTY

$fatpacked{"Test2/EventFacet/Assert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_ASSERT';
  package Test2::EventFacet::Assert;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -pass -no_debug -number };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Assert - Facet representing an assertion.
  
  =head1 DESCRIPTION
  
  The assertion facet is provided by any event representing an assertion that was
  made.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $assert->{details}
  
  =item $string = $assert->details()
  
  Human readable description of the assertion.
  
  =item $bool = $assert->{pass}
  
  =item $bool = $assert->pass()
  
  True if the assertion passed.
  
  =item $bool = $assert->{no_debug}
  
  =item $bool = $assert->no_debug()
  
  Set this to true if you have provided custom diagnostics and do not want the
  defaults to be displayed.
  
  =item $int = $assert->{number}
  
  =item $int = $assert->number()
  
  (Optional) assertion number. This may be omitted or ignored. This is usually
  only useful when parsing/processing TAP.
  
  B<Note>: This is not set by the Test2 system, assertion number is not known
  until AFTER the assertion has been processed. This attribute is part of the
  spec only for harnesses.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_ASSERT

$fatpacked{"Test2/EventFacet/Control.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_CONTROL';
  package Test2::EventFacet::Control;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -global -terminate -halt -has_callback -encoding };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Control - Facet for hub actions and behaviors.
  
  =head1 DESCRIPTION
  
  This facet is used when the event needs to give instructions to the Test2
  internals.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $control->{details}
  
  =item $string = $control->details()
  
  Human readable explanation for the special behavior.
  
  =item $bool = $control->{global}
  
  =item $bool = $control->global()
  
  True if the event is global in nature and should be seen by all hubs.
  
  =item $exit = $control->{terminate}
  
  =item $exit = $control->terminate()
  
  Defined if the test should immediately exit, the value is the exit code and may
  be C<0>.
  
  =item $bool = $control->{halt}
  
  =item $bool = $control->halt()
  
  True if all testing should be halted immediately.
  
  =item $bool = $control->{has_callback}
  
  =item $bool = $control->has_callback()
  
  True if the C<callback($hub)> method on the event should be called.
  
  =item $encoding = $control->{encoding}
  
  =item $encoding = $control->encoding()
  
  This can be used to change the encoding from this event onward.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_CONTROL

$fatpacked{"Test2/EventFacet/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_ERROR';
  package Test2::EventFacet::Error;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  sub facet_key { 'errors' }
  sub is_list { 1 }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -tag -fail };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Error - Facet for errors that need to be shown.
  
  =head1 DESCRIPTION
  
  This facet is used when an event needs to convey errors.
  
  =head1 NOTES
  
  This facet has the hash key C<'errors'>, and is a list of facets instead of a
  single item.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $error->{details}
  
  =item $string = $error->details()
  
  Explanation of the error, or the error itself (such as an exception). In perl
  exceptions may be blessed objects, so this field may contain a blessed object.
  
  =item $short_string = $error->{tag}
  
  =item $short_string = $error->tag()
  
  Short tag to categorize the error. This is usually 10 characters or less,
  formatters may truncate longer tags.
  
  =item $bool = $error->{fail}
  
  =item $bool = $error->fail()
  
  Not all errors are fatal, some are displayed having already been handled. Set
  this to true if you want the error to cause the test to fail. Without this the
  error is simply a diagnostics message that has no effect on the overall
  pass/fail result.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_ERROR

$fatpacked{"Test2/EventFacet/Info.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_INFO';
  package Test2::EventFacet::Info;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  sub is_list { 1 }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{-tag -debug -important};
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Info - Facet for information a developer might care about.
  
  =head1 DESCRIPTION
  
  This facet represents messages intended for humans that will help them either
  understand a result, or diagnose a failure.
  
  =head1 NOTES
  
  This facet appears in a list instead of being a single item.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string_or_structure = $info->{details}
  
  =item $string_or_structure = $info->details()
  
  Human readable string or data structure, this is the information to display.
  Formatters are free to render the structures however they please. This may
  contain a blessed object.
  
  =item $short_string = $info->{tag}
  
  =item $short_string = $info->tag()
  
  Short tag to categorize the info. This is usually 10 characters or less,
  formatters may truncate longer tags.
  
  =item $bool = $info->{debug}
  
  =item $bool = $info->debug()
  
  Set this to true if the message is critical, or explains a failure. This is
  info that should be displayed by formatters even in less-verbose modes.
  
  When false the information is not considered critical and may not be rendered
  in less-verbose modes.
  
  =item $bool = $info->{important}
  
  =item $bool = $info->important
  
  This should be set for non debug messages that are still important enough to
  show when a formatter is in quiet mode. A formatter should send these to STDOUT
  not STDERR, but should show them even in non-verbose mode.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_INFO

$fatpacked{"Test2/EventFacet/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_META';
  package Test2::EventFacet::Meta;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use vars qw/$AUTOLOAD/;
  
  # replace set_details
  {
      no warnings 'redefine';
      sub set_details { $_[0]->{'set_details'} }
  }
  
  sub can {
      my $self = shift;
      my ($name) = @_;
  
      my $existing = $self->SUPER::can($name);
      return $existing if $existing;
  
      # Only vivify when called on an instance, do not vivify for a class. There
      # are a lot of magic class methods used in things like serialization (or
      # the forks.pm module) which cause problems when vivified.
      return undef unless ref($self);
  
      my $sub = sub { $_[0]->{$name} };
      {
          no strict 'refs';
          *$name = $sub;
      }
  
      return $sub;
  }
  
  sub AUTOLOAD {
      my $name = $AUTOLOAD;
      $name =~ s/^.*:://g;
      my $sub = $_[0]->can($name);
      goto &$sub;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Meta - Facet for meta-data
  
  =head1 DESCRIPTION
  
  This facet can contain any random meta-data that has been attached to the
  event.
  
  =head1 METHODS AND FIELDS
  
  Any/all fields and accessors are autovivified into existence. There is no way
  to know what metadata may be added, so any is allowed.
  
  =over 4
  
  =item $anything = $meta->{anything}
  
  =item $anything = $meta->anything()
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_META

$fatpacked{"Test2/EventFacet/Parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_PARENT';
  package Test2::EventFacet::Parent;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  use Carp qw/confess/;
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -hid -children -buffered };
  
  sub init {
      confess "Attribute 'hid' must be set"
          unless defined $_[0]->{+HID};
  
      $_[0]->{+CHILDREN} ||= [];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Parent - Base class for all event facets.
  
  =head1 DESCRIPTION
  
  This facet is used when an event contains other events, such as a subtest.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $parent->{details}
  
  =item $string = $parent->details()
  
  Human readable description of the event.
  
  =item $hid = $parent->{hid}
  
  =item $hid = $parent->hid()
  
  Hub ID of the hub that is represented in the parent-child relationship.
  
  =item $arrayref = $parent->{children}
  
  =item $arrayref = $parent->children()
  
  Arrayref containing the facet-data hashes of events nested under this one.
  
  I<To get the actual events you need to get them from the parent event directly>
  
  =item $bool = $parent->{buffered}
  
  =item $bool = $parent->buffered()
  
  True if the subtest is buffered (meaning the formatter has probably not seen
  them yet).
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_PARENT

$fatpacked{"Test2/EventFacet/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_PLAN';
  package Test2::EventFacet::Plan;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -count -skip -none };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Plan - Facet for setting the plan
  
  =head1 DESCRIPTION
  
  Events use this facet when they need to set the plan.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $plan->{details}
  
  =item $string = $plan->details()
  
  Human readable explanation for the plan being set. This is normally not
  rendered by most formatters except when the C<skip> field is also set.
  
  =item $positive_int = $plan->{count}
  
  =item $positive_int = $plan->count()
  
  Set the number of expected assertions. This should usually be set to C<0> when
  C<skip> or C<none> are also set.
  
  =item $bool = $plan->{skip}
  
  =item $bool = $plan->skip()
  
  When true the entire test should be skipped. This is usually paired with an
  explanation in the C<details> field, and a C<control> facet that has
  C<terminate> set to C<0>.
  
  =item $bool = $plan->{none}
  
  =item $bool = $plan->none()
  
  This is mainly used by legacy L<Test::Builder> tests which set the plan to C<no
  plan>, a construct that predates the much better C<done_testing()>.
  
  If you are using this in non-legacy code you may need to reconsider the course
  of your life, maybe a hermitage would suite you?
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_PLAN

$fatpacked{"Test2/EventFacet/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_TRACE';
  package Test2::EventFacet::Trace;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  
  use Test2::Util qw/get_tid pkg_to_file/;
  use Carp qw/confess/;
  
  use Test2::Util::HashBase qw{^frame ^pid ^tid ^cid -hid -nested details -buffered};
  
  {
      no warnings 'once';
      *DETAIL = \&DETAILS;
      *detail = \&details;
      *set_detail = \&set_details;
  }
  
  sub init {
      confess "The 'frame' attribute is required"
          unless $_[0]->{+FRAME};
  
      $_[0]->{+DETAILS} = delete $_[0]->{detail} if $_[0]->{detail};
  
      $_[0]->{+PID} = $$        unless defined $_[0]->{+PID};
      $_[0]->{+TID} = get_tid() unless defined $_[0]->{+TID};
  }
  
  sub snapshot {
      my ($orig, @override) = @_;
      bless {%$orig, @override}, __PACKAGE__;
  }
  
  sub signature {
      my $self = shift;
  
      # Signature is only valid if all of these fields are defined, there is no
      # signature if any is missing. '0' is ok, but '' is not.
      return join ':' => map { (defined($_) && length($_)) ? $_ : return undef } (
          $self->{+CID},
          $self->{+PID},
          $self->{+TID},
          $self->{+FRAME}->[1],
          $self->{+FRAME}->[2],
      );
  }
  
  sub debug {
      my $self = shift;
      return $self->{+DETAILS} if $self->{+DETAILS};
      my ($pkg, $file, $line) = $self->call;
      return "at $file line $line";
  }
  
  sub alert {
      my $self = shift;
      my ($msg) = @_;
      warn $msg . ' ' . $self->debug . ".\n";
  }
  
  sub throw {
      my $self = shift;
      my ($msg) = @_;
      die $msg . ' ' . $self->debug . ".\n";
  }
  
  sub call { @{$_[0]->{+FRAME}} }
  
  sub package { $_[0]->{+FRAME}->[0] }
  sub file    { $_[0]->{+FRAME}->[1] }
  sub line    { $_[0]->{+FRAME}->[2] }
  sub subname { $_[0]->{+FRAME}->[3] }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Trace - Debug information for events
  
  =head1 DESCRIPTION
  
  The L<Test2::API::Context> object, as well as all L<Test2::Event> types need to
  have access to information about where they were created.  This object
  represents that information.
  
  =head1 SYNOPSIS
  
      use Test2::EventFacet::Trace;
  
      my $trace = Test2::EventFacet::Trace->new(
          frame => [$package, $file, $line, $subname],
      );
  
  =head1 FACET FIELDS
  
  =over 4
  
  =item $string = $trace->{details}
  
  =item $string = $trace->details()
  
  Used as a custom trace message that will be used INSTEAD of
  C<< at <FILE> line <LINE> >> when calling C<< $trace->debug >>.
  
  =item $frame = $trace->{frame}
  
  =item $frame = $trace->frame()
  
  Get the call frame arrayref.
  
  =item $int = $trace->{pid}
  
  =item $int = $trace->pid()
  
  The process ID in which the event was generated.
  
  =item $int = $trace->{tid}
  
  =item $int = $trace->tid()
  
  The thread ID in which the event was generated.
  
  =item $id = $trace->{cid}
  
  =item $id = $trace->cid()
  
  The ID of the context that was used to create the event.
  
  =item $hid = $trace->{hid}
  
  =item $hid = $trace->hid()
  
  The ID of the hub that was current when the event was created.
  
  =item $int = $trace->{nested}
  
  =item $int = $trace->nested()
  
  How deeply nested the event is.
  
  =item $bool = $trace->{buffered}
  
  =item $bool = $trace->buffered()
  
  True if the event was buffered and not sent to the formatter independent of a
  parent (This should never be set when nested is C<0> or C<undef>).
  
  =back
  
  =head1 METHODS
  
  B<Note:> All facet frames are also methods.
  
  =over 4
  
  =item $trace->set_detail($msg)
  
  =item $msg = $trace->detail
  
  Used to get/set a custom trace message that will be used INSTEAD of
  C<< at <FILE> line <LINE> >> when calling C<< $trace->debug >>.
  
  C<detail()> is an alias to the C<details> facet field for backwards
  compatibility.
  
  =item $str = $trace->debug
  
  Typically returns the string C<< at <FILE> line <LINE> >>. If C<detail> is set
  then its value will be returned instead.
  
  =item $trace->alert($MESSAGE)
  
  This issues a warning at the frame (filename and line number where
  errors should be reported).
  
  =item $trace->throw($MESSAGE)
  
  This throws an exception at the frame (filename and line number where
  errors should be reported).
  
  =item ($package, $file, $line, $subname) = $trace->call()
  
  Get the caller details for the debug-info. This is where errors should be
  reported.
  
  =item $pkg = $trace->package
  
  Get the debug-info package.
  
  =item $file = $trace->file
  
  Get the debug-info filename.
  
  =item $line = $trace->line
  
  Get the debug-info line number.
  
  =item $subname = $trace->subname
  
  Get the debug-info subroutine name.
  
  =item $sig = trace->signature
  
  Get a signature string that identifies this trace. This is used to check if
  multiple events are related. The Trace includes pid, tid, file, line number,
  and the cid which is C<'C\d+'> for traces created by a context, or C<'T\d+'>
  for traces created by C<new()>.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_TRACE

$fatpacked{"Test2/Formatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_FORMATTER';
  package Test2::Formatter;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  my %ADDED;
  sub import {
      my $class = shift;
      return if $class eq __PACKAGE__;
      return if $ADDED{$class}++;
      require Test2::API;
      Test2::API::test2_formatter_add($class);
  }
  
  sub new_root {
      my $class = shift;
      return $class->new(@_);
  }
  
  sub hide_buffered { 1 }
  
  sub terminate { }
  
  sub finalize { }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Formatter - Namespace for formatters.
  
  =head1 DESCRIPTION
  
  This is the namespace for formatters. This is an empty package.
  
  =head1 CREATING FORMATTERS
  
  A formatter is any package or object with a C<write($event, $num)> method.
  
      package Test2::Formatter::Foo;
      use strict;
      use warnings;
  
      sub write {
          my $self_or_class = shift;
          my ($event, $assert_num) = @_;
          ...
      }
  
      sub hide_buffered { 1 }
  
      sub terminate { }
  
      sub finalize { }
  
      sub new_root {
          my $class = shift;
          ...
          $class->new(@_);
      }
  
      1;
  
  The C<write> method is a method, so it either gets a class or instance. The two
  arguments are the C<$event> object it should record, and the C<$assert_num>
  which is the number of the current assertion (ok), or the last assertion if
  this event is not itself an assertion. The assertion number may be any integer 0
  or greater, and may be undefined in some cases.
  
  The C<hide_buffered()> method must return a boolean. This is used to tell
  buffered subtests whether or not to send it events as they are being buffered.
  See L<Test2::API/"run_subtest(...)"> for more information.
  
  The C<terminate> and C<finalize> methods are optional methods called that you
  can implement if the format you're generating needs to handle these cases, for
  example if you are generating XML and need close open tags.
  
  The C<terminate> method is called when an event's C<terminate> method returns
  true, for example when a L<Test2::Event::Plan> has a C<'skip_all'> plan, or
  when a L<Test2::Event::Bail> event is sent. The C<terminate> method is passed
  a single argument, the L<Test2::Event> object which triggered the terminate.
  
  The C<finalize> method is always the last thing called on the formatter, I<<
  except when C<terminate> is called for a Bail event >>. It is passed the
  following arguments:
  
  The C<new_root> method is called when C<Test2::API::Stack> Initializes the root
  hub for the first time. Most formatters will simply have this call C<<
  $class->new >>, which is the default behavior. Some formatters however may want
  to take extra action during construction of the root formatter, this is where
  they can do that.
  
  =over 4
  
  =item * The number of tests that were planned
  
  =item * The number of tests actually seen
  
  =item * The number of tests which failed
  
  =item * A boolean indicating whether or not the test suite passed
  
  =item * A boolean indicating whether or not this call is for a subtest
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_FORMATTER

$fatpacked{"Test2/Formatter/TAP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_FORMATTER_TAP';
  package Test2::Formatter::TAP;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  use Test2::Util qw/clone_io/;
  
  use Test2::Util::HashBase qw{
      no_numbers handles _encoding _last_fh
      -made_assertion
  };
  
  sub OUT_STD() { 0 }
  sub OUT_ERR() { 1 }
  
  BEGIN { require Test2::Formatter; our @ISA = qw(Test2::Formatter) }
  
  sub _autoflush {
      my($fh) = pop;
      my $old_fh = select $fh;
      $| = 1;
      select $old_fh;
  }
  
  _autoflush(\*STDOUT);
  _autoflush(\*STDERR);
  
  sub hide_buffered { 1 }
  
  sub init {
      my $self = shift;
  
      $self->{+HANDLES} ||= $self->_open_handles;
      if(my $enc = delete $self->{encoding}) {
          $self->encoding($enc);
      }
  }
  
  sub _open_handles {
      my $self = shift;
  
      require Test2::API;
      my $out = clone_io(Test2::API::test2_stdout());
      my $err = clone_io(Test2::API::test2_stderr());
  
      _autoflush($out);
      _autoflush($err);
  
      return [$out, $err];
  }
  
  sub encoding {
      my $self = shift;
  
      if ($] ge "5.007003" and @_) {
          my ($enc) = @_;
          my $handles = $self->{+HANDLES};
  
          # https://rt.perl.org/Public/Bug/Display.html?id=31923
          # If utf8 is requested we use ':utf8' instead of ':encoding(utf8)' in
          # order to avoid the thread segfault.
          if ($enc =~ m/^utf-?8$/i) {
              binmode($_, ":utf8") for @$handles;
          }
          else {
              binmode($_, ":encoding($enc)") for @$handles;
          }
          $self->{+_ENCODING} = $enc;
      }
  
      return $self->{+_ENCODING};
  }
  
  if ($^C) {
      no warnings 'redefine';
      *write = sub {};
  }
  sub write {
      my ($self, $e, $num, $f) = @_;
  
      # The most common case, a pass event with no amnesty and a normal name.
      return if $self->print_optimal_pass($e, $num);
  
      $f ||= $e->facet_data;
  
      $self->encoding($f->{control}->{encoding}) if $f->{control}->{encoding};
  
      my @tap = $self->event_tap($f, $num) or return;
  
      $self->{+MADE_ASSERTION} = 1 if $f->{assert};
  
      my $nesting = $f->{trace}->{nested} || 0;
      my $handles = $self->{+HANDLES};
      my $indent = '    ' x $nesting;
  
      # Local is expensive! Only do it if we really need to.
      local($\, $,) = (undef, '') if $\ || $,;
      for my $set (@tap) {
          no warnings 'uninitialized';
          my ($hid, $msg) = @$set;
          next unless $msg;
          my $io = $handles->[$hid] or next;
  
          print $io "\n"
              if $ENV{HARNESS_ACTIVE}
              && !$ENV{HARNESS_IS_VERBOSE}
              && $hid == OUT_ERR
              && $self->{+_LAST_FH} != $io
              && $msg =~ m/^#\s*Failed test /;
  
          $msg =~ s/^/$indent/mg if $nesting;
          print $io $msg;
          $self->{+_LAST_FH} = $io;
      }
  }
  
  sub print_optimal_pass {
      my ($self, $e, $num) = @_;
  
      my $type = ref($e);
  
      # Only optimal if this is a Pass or a passing Ok
      return unless $type eq 'Test2::Event::Pass' || ($type eq 'Test2::Event::Ok' && $e->{pass});
  
      # Amnesty requires further processing (todo is a form of amnesty)
      return if ($e->{amnesty} && @{$e->{amnesty}}) || defined($e->{todo});
  
      # A name with a newline or hash symbol needs extra processing
      return if defined($e->{name}) && (-1 != index($e->{name}, "\n") || -1 != index($e->{name}, '#'));
  
      my $ok = 'ok';
      $ok .= " $num" if $num && !$self->{+NO_NUMBERS};
      $ok .= defined($e->{name}) ? " - $e->{name}\n" : "\n";
  
      if (my $nesting = $e->{trace}->{nested}) {
          my $indent = '    ' x $nesting;
          $ok = "$indent$ok";
      }
  
      my $io = $self->{+HANDLES}->[OUT_STD];
  
      local($\, $,) = (undef, '') if $\ || $,;
      print $io $ok;
      $self->{+_LAST_FH} = $io;
  
      return 1;
  }
  
  sub event_tap {
      my ($self, $f, $num) = @_;
  
      my @tap;
  
      # If this IS the first event the plan should come first
      # (plan must be before or after assertions, not in the middle)
      push @tap => $self->plan_tap($f) if $f->{plan} && !$self->{+MADE_ASSERTION};
  
      # The assertion is most important, if present.
      if ($f->{assert}) {
          push @tap => $self->assert_tap($f, $num);
          push @tap => $self->debug_tap($f, $num) unless $f->{assert}->{no_debug} || $f->{assert}->{pass};
      }
  
      # Almost as important as an assertion
      push @tap => $self->error_tap($f) if $f->{errors};
  
      # Now lets see the diagnostics messages
      push @tap => $self->info_tap($f) if $f->{info};
  
      # If this IS NOT the first event the plan should come last
      # (plan must be before or after assertions, not in the middle)
      push @tap => $self->plan_tap($f) if $self->{+MADE_ASSERTION} && $f->{plan};
  
      # Bail out
      push @tap => $self->halt_tap($f) if $f->{control}->{halt};
  
      return @tap if @tap;
      return @tap if $f->{control}->{halt};
      return @tap if grep { $f->{$_} } qw/assert plan info errors/;
  
      # Use the summary as a fallback if nothing else is usable.
      return $self->summary_tap($f, $num);
  }
  
  sub error_tap {
      my $self = shift;
      my ($f) = @_;
  
      my $IO = ($f->{amnesty} && @{$f->{amnesty}}) ? OUT_STD : OUT_ERR;
  
      return map {
          my $details = $_->{details};
  
          my $msg;
          if (ref($details)) {
              require Data::Dumper;
              my $dumper = Data::Dumper->new([$details])->Indent(2)->Terse(1)->Pad('# ')->Useqq(1)->Sortkeys(1);
              chomp($msg = $dumper->Dump);
          }
          else {
              chomp($msg = $details);
              $msg =~ s/^/# /;
              $msg =~ s/\n/\n# /g;
          }
  
          [$IO, "$msg\n"];
      } @{$f->{errors}};
  }
  
  sub plan_tap {
      my $self = shift;
      my ($f) = @_;
      my $plan = $f->{plan} or return;
  
      return if $plan->{none};
  
      if ($plan->{skip}) {
          my $reason = $plan->{details} or return [OUT_STD, "1..0 # SKIP\n"];
          chomp($reason);
          return [OUT_STD, '1..0 # SKIP ' . $reason . "\n"];
      }
  
      return [OUT_STD, "1.." . $plan->{count} . "\n"];
  }
  
  sub no_subtest_space { 0 }
  sub assert_tap {
      my $self = shift;
      my ($f, $num) = @_;
  
      my $assert = $f->{assert} or return;
      my $pass = $assert->{pass};
      my $name = $assert->{details};
  
      my $ok = $pass ? 'ok' : 'not ok';
      $ok .= " $num" if $num && !$self->{+NO_NUMBERS};
  
      # The regex form is ~250ms, the index form is ~50ms
      my @extra;
      defined($name) && (
          (index($name, "\n") != -1 && (($name, @extra) = split(/\n\r?/, $name, -1))),
          ((index($name, "#" ) != -1  || substr($name, -1) eq '\\') && (($name =~ s|\\|\\\\|g), ($name =~ s|#|\\#|g)))
      );
  
      my $extra_space = @extra ? ' ' x (length($ok) + 2) : '';
      my $extra_indent = '';
  
      my ($directives, $reason, $is_skip);
      if ($f->{amnesty}) {
          my %directives;
  
          for my $am (@{$f->{amnesty}}) {
              next if $am->{inherited};
              my $tag = $am->{tag} or next;
              $is_skip = 1 if $tag eq 'skip';
  
              $directives{$tag} ||= $am->{details};
          }
  
          my %seen;
          my @order = grep { !$seen{$_}++ } sort keys %directives;
  
          $directives = ' # ' . join ' & ' => @order;
  
          for my $tag ('skip', @order) {
              next unless defined($directives{$tag}) && length($directives{$tag});
              $reason = $directives{$tag};
              last;
          }
      }
  
      $ok .= " - $name" if defined $name && !($is_skip && !$name);
  
      my @subtap;
      if ($f->{parent} && $f->{parent}->{buffered}) {
          $ok .= ' {';
  
          # In a verbose harness we indent the extra since they will appear
          # inside the subtest braces. This helps readability. In a non-verbose
          # harness we do not do this because it is less readable.
          if ($ENV{HARNESS_IS_VERBOSE} || !$ENV{HARNESS_ACTIVE}) {
              $extra_indent = "    ";
              $extra_space = ' ';
          }
  
          # Render the sub-events, we use our own counter for these.
          my $count = 0;
          @subtap = map {
              my $f2 = $_;
  
              # Bump the count for any event that should bump it.
              $count++ if $f2->{assert};
  
              # This indents all output lines generated for the sub-events.
              # index 0 is the filehandle, index 1 is the message we want to indent.
              map { $_->[1] =~ s/^(.*\S.*)$/    $1/mg; $_ } $self->event_tap($f2, $count);
          } @{$f->{parent}->{children}};
  
          push @subtap => [OUT_STD, "}\n"];
      }
  
      if ($directives) {
          $directives = ' # TODO & SKIP' if $directives eq ' # TODO & skip';
          $ok .= $directives;
          $ok .= " $reason" if defined($reason);
      }
  
      $extra_space = ' ' if $self->no_subtest_space;
  
      my @out = ([OUT_STD, "$ok\n"]);
      push @out => map {[OUT_STD, "${extra_indent}#${extra_space}$_\n"]} @extra if @extra;
      push @out => @subtap;
  
      return @out;
  }
  
  sub debug_tap {
      my ($self, $f, $num) = @_;
  
      # Figure out the debug info, this is typically the file name and line
      # number, but can also be a custom message. If no trace object is provided
      # then we have nothing useful to display.
      my $name  = $f->{assert}->{details};
      my $trace = $f->{trace};
  
      my $debug = "[No trace info available]";
      if ($trace->{details}) {
          $debug = $trace->{details};
      }
      elsif ($trace->{frame}) {
          my ($pkg, $file, $line) = @{$trace->{frame}};
          $debug = "at $file line $line." if $file && $line;
      }
  
      my $amnesty = $f->{amnesty} && @{$f->{amnesty}}
          ? ' (with amnesty)'
          : '';
  
      # Create the initial diagnostics. If the test has a name we put the debug
      # info on a second line, this behavior is inherited from Test::Builder.
      my $msg = defined($name)
          ? qq[# Failed test${amnesty} '$name'\n# $debug\n]
          : qq[# Failed test${amnesty} $debug\n];
  
      my $IO = $f->{amnesty} && @{$f->{amnesty}} ? OUT_STD : OUT_ERR;
  
      return [$IO, $msg];
  }
  
  sub halt_tap {
      my ($self, $f) = @_;
  
      return if $f->{trace}->{nested} && !$f->{trace}->{buffered};
      my $details = $f->{control}->{details};
  
      return [OUT_STD, "Bail out!\n"] unless defined($details) && length($details);
      return [OUT_STD, "Bail out!  $details\n"];
  }
  
  sub info_tap {
      my ($self, $f) = @_;
  
      return map {
          my $details = $_->{details};
  
          my $IO = $_->{debug} && !($f->{amnesty} && @{$f->{amnesty}}) ? OUT_ERR : OUT_STD;
  
          my $msg;
          if (ref($details)) {
              require Data::Dumper;
              my $dumper = Data::Dumper->new([$details])->Indent(2)->Terse(1)->Pad('# ')->Useqq(1)->Sortkeys(1);
              chomp($msg = $dumper->Dump);
          }
          else {
              chomp($msg = $details);
              $msg =~ s/^/# /;
              $msg =~ s/\n/\n# /g;
          }
  
          [$IO, "$msg\n"];
      } @{$f->{info}};
  }
  
  sub summary_tap {
      my ($self, $f, $num) = @_;
  
      return if $f->{about}->{no_display};
  
      my $summary = $f->{about}->{details} or return;
      chomp($summary);
      $summary =~ s/^/# /smg;
  
      return [OUT_STD, "$summary\n"];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Formatter::TAP - Standard TAP formatter
  
  =head1 DESCRIPTION
  
  This is what takes events and turns them into TAP.
  
  =head1 SYNOPSIS
  
      use Test2::Formatter::TAP;
      my $tap = Test2::Formatter::TAP->new();
  
      # Switch to utf8
      $tap->encoding('utf8');
  
      $tap->write($event, $number); # Output an event
  
  =head1 METHODS
  
  =over 4
  
  =item $bool = $tap->no_numbers
  
  =item $tap->set_no_numbers($bool)
  
  Use to turn numbers on and off.
  
  =item $arrayref = $tap->handles
  
  =item $tap->set_handles(\@handles);
  
  Can be used to get/set the filehandles. Indexes are identified by the
  C<OUT_STD> and C<OUT_ERR> constants.
  
  =item $encoding = $tap->encoding
  
  =item $tap->encoding($encoding)
  
  Get or set the encoding. By default no encoding is set, the original settings
  of STDOUT and STDERR are used.
  
  This directly modifies the stored filehandles, it does not create new ones.
  
  =item $tap->write($e, $num)
  
  Write an event to the console.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =item Kent Fredric E<lt>kentnl@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_FORMATTER_TAP

$fatpacked{"Test2/Hub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB';
  package Test2::Hub;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  use Carp qw/carp croak confess/;
  use Test2::Util qw/get_tid ipc_separator/;
  
  use Scalar::Util qw/weaken/;
  use List::Util qw/first/;
  
  use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;
  use Test2::Util::HashBase qw{
      pid tid hid ipc
      nested buffered
      no_ending
      _filters
      _pre_filters
      _listeners
      _follow_ups
      _formatter
      _context_acquire
      _context_init
      _context_release
  
      active
      count
      failed
      ended
      bailed_out
      _passing
      _plan
      skip_reason
  };
  
  my $ID_POSTFIX = 1;
  sub init {
      my $self = shift;
  
      $self->{+PID} = $$;
      $self->{+TID} = get_tid();
      $self->{+HID} = join ipc_separator, $self->{+PID}, $self->{+TID}, $ID_POSTFIX++;
  
      $self->{+NESTED}   = 0 unless defined $self->{+NESTED};
      $self->{+BUFFERED} = 0 unless defined $self->{+BUFFERED};
  
      $self->{+COUNT}    = 0;
      $self->{+FAILED}   = 0;
      $self->{+_PASSING} = 1;
  
      if (my $formatter = delete $self->{formatter}) {
          $self->format($formatter);
      }
  
      if (my $ipc = $self->{+IPC}) {
          $ipc->add_hub($self->{+HID});
      }
  }
  
  sub is_subtest { 0 }
  
  sub _tb_reset {
      my $self = shift;
  
      # Nothing to do
      return if $self->{+PID} == $$ && $self->{+TID} == get_tid();
  
      $self->{+PID} = $$;
      $self->{+TID} = get_tid();
      $self->{+HID} = join ipc_separator, $self->{+PID}, $self->{+TID}, $ID_POSTFIX++;
  
      if (my $ipc = $self->{+IPC}) {
          $ipc->add_hub($self->{+HID});
      }
  }
  
  sub reset_state {
      my $self = shift;
  
      $self->{+COUNT} = 0;
      $self->{+FAILED} = 0;
      $self->{+_PASSING} = 1;
  
      delete $self->{+_PLAN};
      delete $self->{+ENDED};
      delete $self->{+BAILED_OUT};
      delete $self->{+SKIP_REASON};
  }
  
  sub inherit {
      my $self = shift;
      my ($from, %params) = @_;
  
      $self->{+NESTED} ||= 0;
  
      $self->{+_FORMATTER} = $from->{+_FORMATTER}
          unless $self->{+_FORMATTER} || exists($params{formatter});
  
      if ($from->{+IPC} && !$self->{+IPC} && !exists($params{ipc})) {
          my $ipc = $from->{+IPC};
          $self->{+IPC} = $ipc;
          $ipc->add_hub($self->{+HID});
      }
  
      if (my $ls = $from->{+_LISTENERS}) {
          push @{$self->{+_LISTENERS}} => grep { $_->{inherit} } @$ls;
      }
  
      if (my $pfs = $from->{+_PRE_FILTERS}) {
          push @{$self->{+_PRE_FILTERS}} => grep { $_->{inherit} } @$pfs;
      }
  
      if (my $fs = $from->{+_FILTERS}) {
          push @{$self->{+_FILTERS}} => grep { $_->{inherit} } @$fs;
      }
  }
  
  sub format {
      my $self = shift;
  
      my $old = $self->{+_FORMATTER};
      ($self->{+_FORMATTER}) = @_ if @_;
  
      return $old;
  }
  
  sub is_local {
      my $self = shift;
      return $$ == $self->{+PID}
          && get_tid() == $self->{+TID};
  }
  
  sub listen {
      my $self = shift;
      my ($sub, %params) = @_;
  
      carp "Useless addition of a listener in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      croak "listen only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_LISTENERS}} => { %params, code => $sub };
  
      $sub; # Intentional return.
  }
  
  sub unlisten {
      my $self = shift;
  
      carp "Useless removal of a listener in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      my %subs = map {$_ => $_} @_;
  
      @{$self->{+_LISTENERS}} = grep { !$subs{$_->{code}} } @{$self->{+_LISTENERS}};
  }
  
  sub filter {
      my $self = shift;
      my ($sub, %params) = @_;
  
      carp "Useless addition of a filter in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      croak "filter only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_FILTERS}} => { %params, code => $sub };
  
      $sub; # Intentional Return
  }
  
  sub unfilter {
      my $self = shift;
      carp "Useless removal of a filter in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
      my %subs = map {$_ => $_} @_;
      @{$self->{+_FILTERS}} = grep { !$subs{$_->{code}} } @{$self->{+_FILTERS}};
  }
  
  sub pre_filter {
      my $self = shift;
      my ($sub, %params) = @_;
  
      croak "pre_filter only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_PRE_FILTERS}} => { %params, code => $sub };
  
      $sub; # Intentional Return
  }
  
  sub pre_unfilter {
      my $self = shift;
      my %subs = map {$_ => $_} @_;
      @{$self->{+_PRE_FILTERS}} = grep { !$subs{$_->{code}} } @{$self->{+_PRE_FILTERS}};
  }
  
  sub follow_up {
      my $self = shift;
      my ($sub) = @_;
  
      carp "Useless addition of a follow-up in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      croak "follow_up only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_FOLLOW_UPS}} => $sub;
  }
  
  *add_context_aquire = \&add_context_acquire;
  sub add_context_acquire {
      my $self = shift;
      my ($sub) = @_;
  
      croak "add_context_acquire only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_CONTEXT_ACQUIRE}} => $sub;
  
      $sub; # Intentional return.
  }
  
  *remove_context_aquire = \&remove_context_acquire;
  sub remove_context_acquire {
      my $self = shift;
      my %subs = map {$_ => $_} @_;
      @{$self->{+_CONTEXT_ACQUIRE}} = grep { !$subs{$_} == $_ } @{$self->{+_CONTEXT_ACQUIRE}};
  }
  
  sub add_context_init {
      my $self = shift;
      my ($sub) = @_;
  
      croak "add_context_init only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_CONTEXT_INIT}} => $sub;
  
      $sub; # Intentional return.
  }
  
  sub remove_context_init {
      my $self = shift;
      my %subs = map {$_ => $_} @_;
      @{$self->{+_CONTEXT_INIT}} = grep { !$subs{$_} == $_ } @{$self->{+_CONTEXT_INIT}};
  }
  
  sub add_context_release {
      my $self = shift;
      my ($sub) = @_;
  
      croak "add_context_release only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_CONTEXT_RELEASE}} => $sub;
  
      $sub; # Intentional return.
  }
  
  sub remove_context_release {
      my $self = shift;
      my %subs = map {$_ => $_} @_;
      @{$self->{+_CONTEXT_RELEASE}} = grep { !$subs{$_} == $_ } @{$self->{+_CONTEXT_RELEASE}};
  }
  
  sub send {
      my $self = shift;
      my ($e) = @_;
  
      if ($self->{+_PRE_FILTERS}) {
          for (@{$self->{+_PRE_FILTERS}}) {
              $e = $_->{code}->($self, $e);
              return unless $e;
          }
      }
  
      my $ipc = $self->{+IPC} || return $self->process($e);
  
      if($e->global) {
          $ipc->send($self->{+HID}, $e, 'GLOBAL');
          return $self->process($e);
      }
  
      return $ipc->send($self->{+HID}, $e)
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      $self->process($e);
  }
  
  sub process {
      my $self = shift;
      my ($e) = @_;
  
      if ($self->{+_FILTERS}) {
          for (@{$self->{+_FILTERS}}) {
              $e = $_->{code}->($self, $e);
              return unless $e;
          }
      }
  
      # Optimize the most common case
      my $type = ref($e);
      if ($type eq 'Test2::Event::Pass' || ($type eq 'Test2::Event::Ok' && $e->{pass})) {
          my $count = ++($self->{+COUNT});
          $self->{+_FORMATTER}->write($e, $count) if $self->{+_FORMATTER};
  
          if ($self->{+_LISTENERS}) {
              $_->{code}->($self, $e, $count) for @{$self->{+_LISTENERS}};
          }
  
          return $e;
      }
  
      my $f = $e->facet_data;
  
      my $fail = 0;
      $fail = 1 if $f->{assert} && !$f->{assert}->{pass};
      $fail = 1 if $f->{errors} && grep { $_->{fail} } @{$f->{errors}};
      $fail = 0 if $f->{amnesty};
  
      $self->{+COUNT}++ if $f->{assert};
      $self->{+FAILED}++ if $fail && $f->{assert};
      $self->{+_PASSING} = 0 if $fail;
  
      my $code = $f->{control}->{terminate};
      my $count = $self->{+COUNT};
  
      if (my $plan = $f->{plan}) {
          if ($plan->{skip}) {
              $self->plan('SKIP');
              $self->set_skip_reason($plan->{details} || 1);
              $code ||= 0;
          }
          elsif ($plan->{none}) {
              $self->plan('NO PLAN');
          }
          else {
              $self->plan($plan->{count});
          }
      }
  
      $e->callback($self) if $f->{control}->{has_callback};
  
      $self->{+_FORMATTER}->write($e, $count, $f) if $self->{+_FORMATTER};
  
      if ($self->{+_LISTENERS}) {
          $_->{code}->($self, $e, $count, $f) for @{$self->{+_LISTENERS}};
      }
  
      if ($f->{control}->{halt}) {
          $code ||= 255;
          $self->set_bailed_out($e);
      }
  
      if (defined $code) {
          $self->{+_FORMATTER}->terminate($e, $f) if $self->{+_FORMATTER};
          $self->terminate($code, $e, $f);
      }
  
      return $e;
  }
  
  sub terminate {
      my $self = shift;
      my ($code) = @_;
      exit($code);
  }
  
  sub cull {
      my $self = shift;
  
      my $ipc = $self->{+IPC} || return;
      return if $self->{+PID} != $$ || $self->{+TID} != get_tid();
  
      # No need to do IPC checks on culled events
      $self->process($_) for $ipc->cull($self->{+HID});
  }
  
  sub finalize {
      my $self = shift;
      my ($trace, $do_plan) = @_;
  
      $self->cull();
  
      my $plan   = $self->{+_PLAN};
      my $count  = $self->{+COUNT};
      my $failed = $self->{+FAILED};
      my $active = $self->{+ACTIVE};
  
      # return if NOTHING was done.
      unless ($active || $do_plan || defined($plan) || $count || $failed) {
          $self->{+_FORMATTER}->finalize($plan, $count, $failed, 0, $self->is_subtest) if $self->{+_FORMATTER};
          return;
      }
  
      unless ($self->{+ENDED}) {
          if ($self->{+_FOLLOW_UPS}) {
              $_->($trace, $self) for reverse @{$self->{+_FOLLOW_UPS}};
          }
  
          # These need to be refreshed now
          $plan   = $self->{+_PLAN};
          $count  = $self->{+COUNT};
          $failed = $self->{+FAILED};
  
          if (($plan && $plan eq 'NO PLAN') || ($do_plan && !$plan)) {
              $self->send(
                  Test2::Event::Plan->new(
                      trace => $trace,
                      max => $count,
                  )
              );
          }
          $plan = $self->{+_PLAN};
      }
  
      my $frame = $trace->frame;
      if($self->{+ENDED}) {
          my (undef, $ffile, $fline) = @{$self->{+ENDED}};
          my (undef, $sfile, $sline) = @$frame;
  
          die <<"        EOT"
  Test already ended!
  First End:  $ffile line $fline
  Second End: $sfile line $sline
          EOT
      }
  
      $self->{+ENDED} = $frame;
      my $pass = $self->is_passing(); # Generate the final boolean.
  
      $self->{+_FORMATTER}->finalize($plan, $count, $failed, $pass, $self->is_subtest) if $self->{+_FORMATTER};
  
      return $pass;
  }
  
  sub is_passing {
      my $self = shift;
  
      ($self->{+_PASSING}) = @_ if @_;
  
      # If we already failed just return 0.
      my $pass = $self->{+_PASSING} or return 0;
      return $self->{+_PASSING} = 0 if $self->{+FAILED};
  
      my $count = $self->{+COUNT};
      my $ended = $self->{+ENDED};
      my $plan = $self->{+_PLAN};
  
      return $pass if !$count && $plan && $plan =~ m/^SKIP$/;
  
      return $self->{+_PASSING} = 0
          if $ended && (!$count || !$plan);
  
      return $pass unless $plan && $plan =~ m/^\d+$/;
  
      if ($ended) {
          return $self->{+_PASSING} = 0 if $count != $plan;
      }
      else {
          return $self->{+_PASSING} = 0 if $count > $plan;
      }
  
      return $pass;
  }
  
  sub plan {
      my $self = shift;
  
      return $self->{+_PLAN} unless @_;
  
      my ($plan) = @_;
  
      confess "You cannot unset the plan"
          unless defined $plan;
  
      confess "You cannot change the plan"
          if $self->{+_PLAN} && $self->{+_PLAN} !~ m/^NO PLAN$/;
  
      confess "'$plan' is not a valid plan! Plan must be an integer greater than 0, 'NO PLAN', or 'SKIP'"
          unless $plan =~ m/^(\d+|NO PLAN|SKIP)$/;
  
      $self->{+_PLAN} = $plan;
  }
  
  sub check_plan {
      my $self = shift;
  
      return undef unless $self->{+ENDED};
      my $plan = $self->{+_PLAN} || return undef;
  
      return 1 if $plan !~ m/^\d+$/;
  
      return 1 if $plan == $self->{+COUNT};
      return 0;
  }
  
  sub DESTROY {
      my $self = shift;
      my $ipc = $self->{+IPC} || return;
      return unless $$ == $self->{+PID};
      return unless get_tid() == $self->{+TID};
      $ipc->drop_hub($self->{+HID});
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Hub - The conduit through which all events flow.
  
  =head1 SYNOPSIS
  
      use Test2::Hub;
  
      my $hub = Test2::Hub->new();
      $hub->send(...);
  
  =head1 DESCRIPTION
  
  The hub is the place where all events get processed and handed off to the
  formatter. The hub also tracks test state, and provides several hooks into the
  event pipeline.
  
  =head1 COMMON TASKS
  
  =head2 SENDING EVENTS
  
      $hub->send($event)
  
  The C<send()> method is used to issue an event to the hub. This method will
  handle thread/fork sync, filters, listeners, TAP output, etc.
  
  =head2 ALTERING OR REMOVING EVENTS
  
  You can use either C<filter()> or C<pre_filter()>, depending on your
  needs. Both have identical syntax, so only C<filter()> is shown here.
  
      $hub->filter(sub {
          my ($hub, $event) = @_;
  
          my $action = get_action($event);
  
          # No action should be taken
          return $event if $action eq 'none';
  
          # You want your filter to remove the event
          return undef if $action eq 'delete';
  
          if ($action eq 'do_it') {
              my $new_event = copy_event($event);
              ... Change your copy of the event ...
              return $new_event;
          }
  
          die "Should not happen";
      });
  
  By default, filters are not inherited by child hubs. That means if you start a
  subtest, the subtest will not inherit the filter. You can change this behavior
  with the C<inherit> parameter:
  
      $hub->filter(sub { ... }, inherit => 1);
  
  =head2 LISTENING FOR EVENTS
  
      $hub->listen(sub {
          my ($hub, $event, $number) = @_;
  
          ... do whatever you want with the event ...
  
          # return is ignored
      });
  
  By default listeners are not inherited by child hubs. That means if you start a
  subtest, the subtest will not inherit the listener. You can change this behavior
  with the C<inherit> parameter:
  
      $hub->listen(sub { ... }, inherit => 1);
  
  
  =head2 POST-TEST BEHAVIORS
  
      $hub->follow_up(sub {
          my ($trace, $hub) = @_;
  
          ... do whatever you need to ...
  
          # Return is ignored
      });
  
  follow_up subs are called only once, either when done_testing is called, or in
  an END block.
  
  =head2 SETTING THE FORMATTER
  
  By default an instance of L<Test2::Formatter::TAP> is created and used.
  
      my $old = $hub->format(My::Formatter->new);
  
  Setting the formatter will REPLACE any existing formatter. You may set the
  formatter to undef to prevent output. The old formatter will be returned if one
  was already set. Only one formatter is allowed at a time.
  
  =head1 METHODS
  
  =over 4
  
  =item $hub->send($event)
  
  This is where all events enter the hub for processing.
  
  =item $hub->process($event)
  
  This is called by send after it does any IPC handling. You can use this to
  bypass the IPC process, but in general you should avoid using this.
  
  =item $old = $hub->format($formatter)
  
  Replace the existing formatter instance with a new one. Formatters must be
  objects that implement a C<< $formatter->write($event) >> method.
  
  =item $sub = $hub->listen(sub { ... }, %optional_params)
  
  You can use this to record all events AFTER they have been sent to the
  formatter. No changes made here will be meaningful, except possibly to other
  listeners.
  
      $hub->listen(sub {
          my ($hub, $event, $number) = @_;
  
          ... do whatever you want with the event ...
  
          # return is ignored
      });
  
  Normally listeners are not inherited by child hubs such as subtests. You can
  add the C<< inherit => 1 >> parameter to allow a listener to be inherited.
  
  =item $hub->unlisten($sub)
  
  You can use this to remove a listen callback. You must pass in the coderef
  returned by the C<listen()> method.
  
  =item $sub = $hub->filter(sub { ... }, %optional_params)
  
  =item $sub = $hub->pre_filter(sub { ... }, %optional_params)
  
  These can be used to add filters. Filters can modify, replace, or remove events
  before anything else can see them.
  
      $hub->filter(
          sub {
              my ($hub, $event) = @_;
  
              return $event;    # No Changes
              return;           # Remove the event
  
              # Or you can modify an event before returning it.
              $event->modify;
              return $event;
          }
      );
  
  If you are not using threads, forking, or IPC then the only difference between
  a C<filter> and a C<pre_filter> is that C<pre_filter> subs run first. When you
  are using threads, forking, or IPC, pre_filters happen to events before they
  are sent to their destination proc/thread, ordinary filters happen only in the
  destination hub/thread.
  
  You cannot add a regular filter to a hub if the hub was created in another
  process or thread. You can always add a pre_filter.
  
  =item $hub->unfilter($sub)
  
  =item $hub->pre_unfilter($sub)
  
  These can be used to remove filters and pre_filters. The C<$sub> argument is
  the reference returned by C<filter()> or C<pre_filter()>.
  
  =item $hub->follow_op(sub { ... })
  
  Use this to add behaviors that are called just before the hub is finalized. The
  only argument to your codeblock will be a L<Test2::EventFacet::Trace> instance.
  
      $hub->follow_up(sub {
          my ($trace, $hub) = @_;
  
          ... do whatever you need to ...
  
          # Return is ignored
      });
  
  follow_up subs are called only once, ether when done_testing is called, or in
  an END block.
  
  =item $sub = $hub->add_context_acquire(sub { ... });
  
  Add a callback that will be called every time someone tries to acquire a
  context. It gets a single argument, a reference of the hash of parameters
  being used the construct the context. This is your chance to change the
  parameters by directly altering the hash.
  
      test2_add_callback_context_acquire(sub {
          my $params = shift;
          $params->{level}++;
      });
  
  This is a very scary API function. Please do not use this unless you need to.
  This is here for L<Test::Builder> and backwards compatibility. This has you
  directly manipulate the hash instead of returning a new one for performance
  reasons.
  
  B<Note> Using this hook could have a huge performance impact.
  
  The coderef you provide is returned and can be used to remove the hook later.
  
  =item $hub->remove_context_acquire($sub);
  
  This can be used to remove a context acquire hook.
  
  =item $sub = $hub->add_context_init(sub { ... });
  
  This allows you to add callbacks that will trigger every time a new context is
  created for the hub. The only argument to the sub will be the
  L<Test2::API::Context> instance that was created.
  
  B<Note> Using this hook could have a huge performance impact.
  
  The coderef you provide is returned and can be used to remove the hook later.
  
  =item $hub->remove_context_init($sub);
  
  This can be used to remove a context init hook.
  
  =item $sub = $hub->add_context_release(sub { ... });
  
  This allows you to add callbacks that will trigger every time a context for
  this hub is released. The only argument to the sub will be the
  L<Test2::API::Context> instance that was released. These will run in reverse
  order.
  
  B<Note> Using this hook could have a huge performance impact.
  
  The coderef you provide is returned and can be used to remove the hook later.
  
  =item $hub->remove_context_release($sub);
  
  This can be used to remove a context release hook.
  
  =item $hub->cull()
  
  Cull any IPC events (and process them).
  
  =item $pid = $hub->pid()
  
  Get the process id under which the hub was created.
  
  =item $tid = $hub->tid()
  
  Get the thread id under which the hub was created.
  
  =item $hud = $hub->hid()
  
  Get the identifier string of the hub.
  
  =item $ipc = $hub->ipc()
  
  Get the IPC object used by the hub.
  
  =item $hub->set_no_ending($bool)
  
  =item $bool = $hub->no_ending
  
  This can be used to disable auto-ending behavior for a hub. The auto-ending
  behavior is triggered by an end block and is used to cull IPC events, and
  output the final plan if the plan was 'no_plan'.
  
  =item $bool = $hub->active
  
  =item $hub->set_active($bool)
  
  These are used to get/set the 'active' attribute. When true this attribute will
  force C<< hub->finalize() >> to take action even if there is no plan, and no
  tests have been run. This flag is useful for plugins that add follow-up
  behaviors that need to run even if no events are seen.
  
  =back
  
  =head2 STATE METHODS
  
  =over 4
  
  =item $hub->reset_state()
  
  Reset all state to the start. This sets the test count to 0, clears the plan,
  removes the failures, etc.
  
  =item $num = $hub->count
  
  Get the number of tests that have been run.
  
  =item $num = $hub->failed
  
  Get the number of failures (Not all failures come from a test fail, so this
  number can be larger than the count).
  
  =item $bool = $hub->ended
  
  True if the testing has ended. This MAY return the stack frame of the tool that
  ended the test, but that is not guaranteed.
  
  =item $bool = $hub->is_passing
  
  =item $hub->is_passing($bool)
  
  Check if the overall test run is a failure. Can also be used to set the
  pass/fail status.
  
  =item $hub->plan($plan)
  
  =item $plan = $hub->plan
  
  Get or set the plan. The plan must be an integer larger than 0, the string
  'no_plan', or the string 'skip_all'.
  
  =item $bool = $hub->check_plan
  
  Check if the plan and counts match, but only if the tests have ended. If tests
  have not ended this will return undef, otherwise it will be a true/false.
  
  =back
  
  =head1 THIRD PARTY META-DATA
  
  This object consumes L<Test2::Util::ExternalMeta> which provides a consistent
  way for you to attach meta-data to instances of this class. This is useful for
  tools, plugins, and other extensions.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_HUB

$fatpacked{"Test2/Hub/Interceptor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB_INTERCEPTOR';
  package Test2::Hub::Interceptor;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  use Test2::Hub::Interceptor::Terminator();
  
  BEGIN { require Test2::Hub; our @ISA = qw(Test2::Hub) }
  use Test2::Util::HashBase;
  
  sub init {
      my $self = shift;
      $self->SUPER::init;
      $self->{+NESTED} = 0;
  }
  
  sub inherit {
      my $self = shift;
      my ($from, %params) = @_;
  
      $self->{+NESTED} = 0;
  
      if ($from->{+IPC} && !$self->{+IPC} && !exists($params{ipc})) {
          my $ipc = $from->{+IPC};
          $self->{+IPC} = $ipc;
          $ipc->add_hub($self->{+HID});
      }
  }
  
  sub terminate {
      my $self = shift;
      my ($code) = @_;
  
      eval {
          no warnings 'exiting';
          last T2_SUBTEST_WRAPPER;
      };
      my $err = $@;
  
      # Fallback
      die bless(\$err, 'Test2::Hub::Interceptor::Terminator');
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Hub::Interceptor - Hub used by interceptor to grab results.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_HUB_INTERCEPTOR

$fatpacked{"Test2/Hub/Interceptor/Terminator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB_INTERCEPTOR_TERMINATOR';
  package Test2::Hub::Interceptor::Terminator;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Hub::Interceptor::Terminator - Exception class used by
  Test2::Hub::Interceptor
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_HUB_INTERCEPTOR_TERMINATOR

$fatpacked{"Test2/Hub/Subtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB_SUBTEST';
  package Test2::Hub::Subtest;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  BEGIN { require Test2::Hub; our @ISA = qw(Test2::Hub) }
  use Test2::Util::HashBase qw/nested exit_code manual_skip_all/;
  use Test2::Util qw/get_tid/;
  
  sub is_subtest { 1 }
  
  sub inherit {
      my $self = shift;
      my ($from) = @_;
  
      $self->SUPER::inherit($from);
  
      $self->{+NESTED} = $from->nested + 1;
  }
  
  {
      # Legacy
      no warnings 'once';
      *ID = \&Test2::Hub::HID;
      *id = \&Test2::Hub::hid;
      *set_id = \&Test2::Hub::set_hid;
  }
  
  sub send {
      my $self = shift;
      my ($e) = @_;
  
      my $out = $self->SUPER::send($e);
  
      return $out if $self->{+MANUAL_SKIP_ALL};
  
      my $f = $e->facet_data;
  
      my $plan = $f->{plan} or return $out;
      return $out unless $plan->{skip};
  
      my $trace = $f->{trace} or die "Missing Trace!";
      return $out unless $trace->{pid} != $self->pid
                      || $trace->{tid} != $self->tid;
  
      no warnings 'exiting';
      last T2_SUBTEST_WRAPPER;
  }
  
  sub terminate {
      my $self = shift;
      my ($code, $e, $f) = @_;
      $self->set_exit_code($code);
  
      return if $self->{+MANUAL_SKIP_ALL};
  
      $f ||= $e->facet_data;
  
      if(my $plan = $f->{plan}) {
          my $trace = $f->{trace} or die "Missing Trace!";
          return if $plan->{skip}
                 && ($trace->{pid} != $$ || $trace->{tid} != get_tid);
      }
  
      no warnings 'exiting';
      last T2_SUBTEST_WRAPPER;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Hub::Subtest - Hub used by subtests
  
  =head1 DESCRIPTION
  
  Subtests make use of this hub to route events.
  
  =head1 TOGGLES
  
  =over 4
  
  =item $bool = $hub->manual_skip_all
  
  =item $hub->set_manual_skip_all($bool)
  
  The default is false.
  
  Normally a skip-all plan event will cause a subtest to stop executing. This is
  accomplished via C<last LABEL> to a label inside the subtest code. Most of the
  time this is perfectly fine. There are times however where this flow control
  causes bad things to happen.
  
  This toggle lets you turn off the abort logic for the hub. When this is toggled
  to true B<you> are responsible for ensuring no additional events are generated.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_HUB_SUBTEST

$fatpacked{"Test2/IPC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_IPC';
  package Test2::IPC;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  use Test2::API::Instance;
  use Test2::Util qw/get_tid/;
  use Test2::API qw{
      test2_init_done
      test2_ipc
      test2_has_ipc
      test2_ipc_enable_polling
      test2_pid
      test2_stack
      test2_tid
      context
  };
  
  use Carp qw/confess/;
  
  our @EXPORT_OK = qw/cull/;
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  sub import {
      goto &Exporter::import if test2_has_ipc || !test2_init_done();
  
      confess "Cannot add IPC in a child process (" . test2_pid() . " vs $$)" if test2_pid() != $$;
      confess "Cannot add IPC in a child thread (" . test2_tid() . " vs " . get_tid() . ")"  if test2_tid() != get_tid();
  
      Test2::API::_set_ipc(_make_ipc());
      apply_ipc(test2_stack());
  
      goto &Exporter::import;
  }
  
  sub _make_ipc {
      # Find a driver
      my ($driver) = Test2::API::test2_ipc_drivers();
      unless ($driver) {
          require Test2::IPC::Driver::Files;
          $driver = 'Test2::IPC::Driver::Files';
      }
  
      return $driver->new();
  }
  
  sub apply_ipc {
      my $stack = shift;
  
      my ($root) = @$stack;
  
      return unless $root;
  
      confess "Cannot add IPC in a child process" if $root->pid != $$;
      confess "Cannot add IPC in a child thread"  if $root->tid != get_tid();
  
      my $ipc = $root->ipc || test2_ipc() || _make_ipc();
  
      # Add the IPC to all hubs
      for my $hub (@$stack) {
          my $has = $hub->ipc;
          confess "IPC Mismatch!" if $has && $has != $ipc;
          next if $has;
          $hub->set_ipc($ipc);
          $ipc->add_hub($hub->hid);
      }
  
      test2_ipc_enable_polling();
  
      return $ipc;
  }
  
  sub cull {
      my $ctx = context();
      $ctx->hub->cull;
      $ctx->release;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::IPC - Turn on IPC for threading or forking support.
  
  =head1 SYNOPSIS
  
  You should C<use Test2::IPC;> as early as possible in your test file. If you
  import this module after API initialization it will attempt to retrofit IPC
  onto the existing hubs.
  
  =head1 EXPORTS
  
  All exports are optional.
  
  =over 4
  
  =item cull()
  
  Cull allows you to collect results from other processes or threads on demand.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_IPC

$fatpacked{"Test2/IPC/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_IPC_DRIVER';
  package Test2::IPC::Driver;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  use Carp qw/confess/;
  use Test2::Util::HashBase qw{no_fatal no_bail};
  
  use Test2::API qw/test2_ipc_add_driver/;
  
  my %ADDED;
  sub import {
      my $class = shift;
      return if $class eq __PACKAGE__;
      return if $ADDED{$class}++;
      test2_ipc_add_driver($class);
  }
  
  sub use_shm { 0 }
  
  for my $meth (qw/send cull add_hub drop_hub waiting is_viable/) {
      no strict 'refs';
      *$meth = sub {
          my $thing = shift;
          confess "'$thing' did not define the required method '$meth'."
      };
  }
  
  # Print the error and call exit. We are not using 'die' cause this is a
  # catastrophic error that should never be caught. If we get here it
  # means some serious shit has happened in a child process, the only way
  # to inform the parent may be to exit false.
  
  sub abort {
      my $self = shift;
      chomp(my ($msg) = @_);
  
      $self->driver_abort($msg) if $self->can('driver_abort');
  
      print STDERR "IPC Fatal Error: $msg\n";
      print STDOUT "Bail out! IPC Fatal Error: $msg\n" unless $self->no_bail;
  
      CORE::exit(255) unless $self->no_fatal;
  }
  
  sub abort_trace {
      my $self = shift;
      my ($msg) = @_;
      # Older versions of Carp do not export longmess() function, so it needs to be called with package name
      $self->abort(Carp::longmess($msg));
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::IPC::Driver - Base class for Test2 IPC drivers.
  
  =head1 SYNOPSIS
  
      package Test2::IPC::Driver::MyDriver;
  
      use base 'Test2::IPC::Driver';
  
      ...
  
  =head1 METHODS
  
  =over 4
  
  =item $self->abort($msg)
  
  If an IPC encounters a fatal error it should use this. This will print the
  message to STDERR with C<'IPC Fatal Error: '> prefixed to it, then it will
  forcefully exit 255. IPC errors may occur in threads or processes other than
  the main one, this method provides the best chance of the harness noticing the
  error.
  
  =item $self->abort_trace($msg)
  
  This is the same as C<< $ipc->abort($msg) >> except that it uses
  C<Carp::longmess> to add a stack trace to the message.
  
  =item $false = $self->use_shm
  
  The base class always returns false for this method. You may override it if you
  wish to use the SHM made available in L<Test2::API>/L<Test2::API::Instance>.
  
  =back
  
  =head1 LOADING DRIVERS
  
  Test2::IPC::Driver has an C<import()> method. All drivers inherit this import
  method. This import method registers the driver.
  
  In most cases you just need to load the desired IPC driver to make it work. You
  should load this driver as early as possible. A warning will be issued if you
  load it too late for it to be effective.
  
      use Test2::IPC::Driver::MyDriver;
      ...
  
  =head1 WRITING DRIVERS
  
      package Test2::IPC::Driver::MyDriver;
      use strict;
      use warnings;
  
      use base 'Test2::IPC::Driver';
  
      sub is_viable {
          return 0 if $^O eq 'win32'; # Will not work on windows.
          return 1;
      }
  
      sub add_hub {
          my $self = shift;
          my ($hid) = @_;
  
          ... # Make it possible to contact the hub
      }
  
      sub drop_hub {
          my $self = shift;
          my ($hid) = @_;
  
          ... # Nothing should try to reach the hub anymore.
      }
  
      sub send {
          my $self = shift;
          my ($hid, $e, $global) = @_;
  
          ... # Send the event to the proper hub.
  
          # If you are using the SHM you should notify other procs/threads that
          # there is a pending event.
          Test2::API::test2_ipc_set_pending($uniq_val);
      }
  
      sub cull {
          my $self = shift;
          my ($hid) = @_;
  
          my @events = ...; # Here is where you get the events for the hub
  
          return @events;
      }
  
      sub waiting {
          my $self = shift;
  
          ... # Notify all listening procs and threads that the main
          ... # process/thread is waiting for them to finish.
      }
  
      1;
  
  =head2 METHODS SUBCLASSES MUST IMPLEMENT
  
  =over 4
  
  =item $ipc->is_viable
  
  This should return true if the driver works in the current environment. This
  should return false if it does not. This is a CLASS method.
  
  =item $ipc->add_hub($hid)
  
  This is used to alert the driver that a new hub is expecting events. The driver
  should keep track of the process and thread ids, the hub should only be dropped
  by the proc+thread that started it.
  
      sub add_hub {
          my $self = shift;
          my ($hid) = @_;
  
          ... # Make it possible to contact the hub
      }
  
  =item $ipc->drop_hub($hid)
  
  This is used to alert the driver that a hub is no longer accepting events. The
  driver should keep track of the process and thread ids, the hub should only be
  dropped by the proc+thread that started it (This is the drivers responsibility
  to enforce).
  
      sub drop_hub {
          my $self = shift;
          my ($hid) = @_;
  
          ... # Nothing should try to reach the hub anymore.
      }
  
  =item $ipc->send($hid, $event);
  
  =item $ipc->send($hid, $event, $global);
  
  Used to send events from the current process/thread to the specified hub in its
  process+thread.
  
      sub send {
          my $self = shift;
          my ($hid, $e) = @_;
  
          ... # Send the event to the proper hub.
  
          # If you are using the SHM you should notify other procs/threads that
          # there is a pending event.
          Test2::API::test2_ipc_set_pending($uniq_val);
      }
  
  If C<$global> is true then the driver should send the event to all hubs in all
  processes and threads.
  
  =item @events = $ipc->cull($hid)
  
  Used to collect events that have been sent to the specified hub.
  
      sub cull {
          my $self = shift;
          my ($hid) = @_;
  
          my @events = ...; # Here is where you get the events for the hub
  
          return @events;
      }
  
  =item $ipc->waiting()
  
  This is called in the parent process when it is complete and waiting for all
  child processes and threads to complete.
  
      sub waiting {
          my $self = shift;
  
          ... # Notify all listening procs and threads that the main
          ... # process/thread is waiting for them to finish.
      }
  
  =back
  
  =head2 METHODS SUBCLASSES MAY IMPLEMENT OR OVERRIDE
  
  =over 4
  
  =item $ipc->driver_abort($msg)
  
  This is a hook called by C<< Test2::IPC::Driver->abort() >>. This is your
  chance to cleanup when an abort happens. You cannot prevent the abort, but you
  can gracefully except it.
  
  =item $bool = $ipc->use_shm()
  
  True if you want to make use of the L<Test2::API>/L<Test2::API::Instance> SHM.
  
  =item $bites = $ipc->shm_size()
  
  Use this to customize the size of the SHM space. There are no guarantees about
  what the size will be if you do not implement this.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_IPC_DRIVER

$fatpacked{"Test2/IPC/Driver/Files.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_IPC_DRIVER_FILES';
  package Test2::IPC::Driver::Files;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  BEGIN { require Test2::IPC::Driver; our @ISA = qw(Test2::IPC::Driver) }
  
  use Test2::Util::HashBase qw{tempdir event_ids read_ids timeouts tid pid globals};
  
  use Scalar::Util qw/blessed/;
  use File::Temp();
  use Storable();
  use File::Spec();
  use POSIX();
  
  use Test2::Util qw/try get_tid pkg_to_file IS_WIN32 ipc_separator do_rename do_unlink try_sig_mask/;
  use Test2::API qw/test2_ipc_set_pending/;
  
  sub use_shm { 1 }
  sub shm_size() { 64 }
  
  sub is_viable { 1 }
  
  sub init {
      my $self = shift;
  
      my $tmpdir = File::Temp::tempdir(
          $ENV{T2_TEMPDIR_TEMPLATE} || "test2" . ipc_separator . $$ . ipc_separator . "XXXXXX",
          CLEANUP => 0,
          TMPDIR => 1,
      );
  
      $self->abort_trace("Could not get a temp dir") unless $tmpdir;
  
      $self->{+TEMPDIR} = File::Spec->canonpath($tmpdir);
  
      print STDERR "\nIPC Temp Dir: $tmpdir\n\n"
          if $ENV{T2_KEEP_TEMPDIR};
  
      $self->{+EVENT_IDS} = {};
      $self->{+READ_IDS} = {};
      $self->{+TIMEOUTS} = {};
  
      $self->{+TID} = get_tid();
      $self->{+PID} = $$;
  
      $self->{+GLOBALS} = {};
  
      return $self;
  }
  
  sub hub_file {
      my $self = shift;
      my ($hid) = @_;
      my $tdir = $self->{+TEMPDIR};
      return File::Spec->catfile($tdir, "HUB" . ipc_separator . $hid);
  }
  
  sub event_file {
      my $self = shift;
      my ($hid, $e) = @_;
  
      my $tempdir = $self->{+TEMPDIR};
      my $type = blessed($e) or $self->abort("'$e' is not a blessed object!");
  
      $self->abort("'$e' is not an event object!")
          unless $type->isa('Test2::Event');
  
      my $tid = get_tid();
      my $eid = $self->{+EVENT_IDS}->{$hid}->{$$}->{$tid} += 1;
  
      my @type = split '::', $type;
      my $name = join(ipc_separator, $hid, $$, $tid, $eid, @type);
  
      return File::Spec->catfile($tempdir, $name);
  }
  
  sub add_hub {
      my $self = shift;
      my ($hid) = @_;
  
      my $hfile = $self->hub_file($hid);
  
      $self->abort_trace("File for hub '$hid' already exists")
          if -e $hfile;
  
      open(my $fh, '>', $hfile) or $self->abort_trace("Could not create hub file '$hid': $!");
      print $fh "$$\n" . get_tid() . "\n";
      close($fh);
  }
  
  sub drop_hub {
      my $self = shift;
      my ($hid) = @_;
  
      my $tdir = $self->{+TEMPDIR};
      my $hfile = $self->hub_file($hid);
  
      $self->abort_trace("File for hub '$hid' does not exist")
          unless -e $hfile;
  
      open(my $fh, '<', $hfile) or $self->abort_trace("Could not open hub file '$hid': $!");
      my ($pid, $tid) = <$fh>;
      close($fh);
  
      $self->abort_trace("A hub file can only be closed by the process that started it\nExpected $pid, got $$")
          unless $pid == $$;
  
      $self->abort_trace("A hub file can only be closed by the thread that started it\nExpected $tid, got " . get_tid())
          unless get_tid() == $tid;
  
      if ($ENV{T2_KEEP_TEMPDIR}) {
          my ($ok, $err) = do_rename($hfile, File::Spec->canonpath("$hfile.complete"));
          $self->abort_trace("Could not rename file '$hfile' -> '$hfile.complete': $err") unless $ok
      }
      else {
          my ($ok, $err) = do_unlink($hfile);
          $self->abort_trace("Could not remove file for hub '$hid': $err") unless $ok
      }
  
      opendir(my $dh, $tdir) or $self->abort_trace("Could not open temp dir!");
      for my $file (readdir($dh)) {
          next if $file =~ m{\.complete$};
          next unless $file =~ m{^$hid};
          $self->abort_trace("Not all files from hub '$hid' have been collected!");
      }
      closedir($dh);
  }
  
  sub send {
      my $self = shift;
      my ($hid, $e, $global) = @_;
  
      my $tempdir = $self->{+TEMPDIR};
      my $hfile = $self->hub_file($hid);
      my $dest = $global ? 'GLOBAL' : $hid;
  
      $self->abort(<<"    EOT") unless $global || -f $hfile;
  hub '$hid' is not available, failed to send event!
  
  There was an attempt to send an event to a hub in a parent process or thread,
  but that hub appears to be gone. This can happen if you fork, or start a new
  thread from inside subtest, and the parent finishes the subtest before the
  child returns.
  
  This can also happen if the parent process is done testing before the child
  finishes. Test2 normally waits automatically in the root process, but will not
  do so if Test::Builder is loaded for legacy reasons.
      EOT
  
      my $file = $self->event_file($dest, $e);
      my $ready = File::Spec->canonpath("$file.ready");
  
      if ($global) {
          my $name = $ready;
          $name =~ s{^.*(GLOBAL)}{GLOBAL};
          $self->{+GLOBALS}->{$hid}->{$name}++;
      }
  
      # Write and rename the file.
      my ($ren_ok, $ren_err);
      my ($ok, $err) = try_sig_mask {
          Storable::store($e, $file);
          ($ren_ok, $ren_err) = do_rename("$file", $ready);
      };
  
      if ($ok) {
          $self->abort("Could not rename file '$file' -> '$ready': $ren_err") unless $ren_ok;
          test2_ipc_set_pending(substr($file, -(shm_size)));
      }
      else {
          my $src_file = __FILE__;
          $err =~ s{ at \Q$src_file\E.*$}{};
          chomp($err);
          my $tid = get_tid();
          my $trace = $e->trace->debug;
          my $type = blessed($e);
  
          $self->abort(<<"        EOT");
  
  *******************************************************************************
  There was an error writing an event:
  Destination: $dest
  Origin PID:  $$
  Origin TID:  $tid
  Event Type:  $type
  Event Trace: $trace
  File Name:   $file
  Ready Name:  $ready
  Error: $err
  *******************************************************************************
  
          EOT
      }
  
      return 1;
  }
  
  sub driver_abort {
      my $self = shift;
      my ($msg) = @_;
  
      local ($@, $!, $?, $^E);
      eval {
          my $abort = File::Spec->catfile($self->{+TEMPDIR}, "ABORT");
          open(my $fh, '>>', $abort) or die "Could not open abort file: $!";
          print $fh $msg, "\n";
          close($fh) or die "Could not close abort file: $!";
          1;
      } or warn $@;
  }
  
  sub cull {
      my $self = shift;
      my ($hid) = @_;
  
      my $tempdir = $self->{+TEMPDIR};
  
      opendir(my $dh, $tempdir) or $self->abort("could not open IPC temp dir ($tempdir)!");
  
      my $read = $self->{+READ_IDS};
      my $timeouts = $self->{+TIMEOUTS};
  
      my @out;
      for my $info (sort cmp_events map { $self->should_read_event($hid, $_) } readdir($dh)) {
          unless ($info->{global}) {
              my $next = $self->{+READ_IDS}->{$info->{hid}}->{$info->{pid}}->{$info->{tid}} ||= 1;
  
              $timeouts->{$info->{file}} ||= time;
  
              if ($next != $info->{eid}) {
                  # Wait up to N seconds for missing events
                  next unless 5 < time - $timeouts->{$info->{file}};
                  $self->abort("Missing event HID: $info->{hid}, PID: $info->{pid}, TID: $info->{tid}, EID: $info->{eid}.");
              }
  
              $self->{+READ_IDS}->{$info->{hid}}->{$info->{pid}}->{$info->{tid}} = $info->{eid} + 1;
          }
  
          my $full = $info->{full_path};
          my $obj = $self->read_event_file($full);
          push @out => $obj;
  
          # Do not remove global events
          next if $info->{global};
  
          if ($ENV{T2_KEEP_TEMPDIR}) {
              my $complete = File::Spec->canonpath("$full.complete");
              my ($ok, $err) = do_rename($full, $complete);
              $self->abort("Could not rename IPC file '$full', '$complete': $err") unless $ok;
          }
          else {
              my ($ok, $err) = do_unlink("$full");
              $self->abort("Could not unlink IPC file '$full': $err") unless $ok;
          }
      }
  
      closedir($dh);
      return @out;
  }
  
  sub parse_event_filename {
      my $self = shift;
      my ($file) = @_;
  
      # The || is to force 0 in false
      my $complete = substr($file, -9, 9) eq '.complete' || 0 and substr($file, -9, 9, "");
      my $ready    = substr($file, -6, 6) eq '.ready'    || 0 and substr($file, -6, 6, "");
  
      my @parts = split ipc_separator, $file;
      my ($global, $hid) = $parts[0] eq 'GLOBAL' ? (1, shift @parts) : (0, join ipc_separator, splice(@parts, 0, 3));
      my ($pid, $tid, $eid) = splice(@parts, 0, 3);
      my $type = join '::' => @parts;
  
      return {
          file     => $file,
          ready    => $ready,
          complete => $complete,
          global   => $global,
          type     => $type,
          hid      => $hid,
          pid      => $pid,
          tid      => $tid,
          eid      => $eid,
      };
  }
  
  sub should_read_event {
      my $self = shift;
      my ($hid, $file) = @_;
  
      return if substr($file, 0, 1) eq '.';
      return if substr($file, 0, 3) eq 'HUB';
      CORE::exit(255) if $file eq 'ABORT';
  
      my $parsed = $self->parse_event_filename($file);
  
      return if $parsed->{complete};
      return unless $parsed->{ready};
      return unless $parsed->{global} || $parsed->{hid} eq $hid;
  
      return if $parsed->{global} && $self->{+GLOBALS}->{$hid}->{$file}++;
  
      # Untaint the path.
      my $full = File::Spec->catfile($self->{+TEMPDIR}, $file);
      ($full) = ($full =~ m/^(.*)$/gs) if ${^TAINT};
  
      $parsed->{full_path} = $full;
  
      return $parsed;
  }
  
  sub cmp_events {
      # Globals first
      return -1 if $a->{global} && !$b->{global};
      return  1 if $b->{global} && !$a->{global};
  
      return $a->{pid} <=> $b->{pid}
          || $a->{tid} <=> $b->{tid}
          || $a->{eid} <=> $b->{eid};
  }
  
  sub read_event_file {
      my $self = shift;
      my ($file) = @_;
  
      my $obj = Storable::retrieve($file);
      $self->abort("Got an unblessed object: '$obj'")
          unless blessed($obj);
  
      unless ($obj->isa('Test2::Event')) {
          my $pkg  = blessed($obj);
          my $mod_file = pkg_to_file($pkg);
          my ($ok, $err) = try { require $mod_file };
  
          $self->abort("Event has unknown type ($pkg), tried to load '$mod_file' but failed: $err")
              unless $ok;
  
          $self->abort("'$obj' is not a 'Test2::Event' object")
              unless $obj->isa('Test2::Event');
      }
  
      return $obj;
  }
  
  sub waiting {
      my $self = shift;
      require Test2::Event::Waiting;
      $self->send(
          GLOBAL => Test2::Event::Waiting->new(
              trace => Test2::EventFacet::Trace->new(frame => [caller()]),
          ),
          'GLOBAL'
      );
      return;
  }
  
  sub DESTROY {
      my $self = shift;
  
      return unless defined $self->pid;
      return unless defined $self->tid;
  
      return unless $$        == $self->pid;
      return unless get_tid() == $self->tid;
  
      my $tempdir = $self->{+TEMPDIR};
  
      my $aborted = 0;
      my $abort_file = File::Spec->catfile($self->{+TEMPDIR}, "ABORT");
      if (-e $abort_file) {
          $aborted = 1;
          my ($ok, $err) = do_unlink($abort_file);
          warn $err unless $ok;
      }
  
      opendir(my $dh, $tempdir) or $self->abort("Could not open temp dir! ($tempdir)");
      while(my $file = readdir($dh)) {
          next if $file =~ m/^\.+$/;
          next if $file =~ m/\.complete$/;
          my $full = File::Spec->catfile($tempdir, $file);
  
          my $sep = ipc_separator;
          if ($aborted || $file =~ m/^(GLOBAL|HUB$sep)/) {
              $full =~ m/^(.*)$/;
              $full = $1; # Untaint it
              next if $ENV{T2_KEEP_TEMPDIR};
              my ($ok, $err) = do_unlink($full);
              $self->abort("Could not unlink IPC file '$full': $err") unless $ok;
              next;
          }
  
          $self->abort("Leftover files in the directory ($full)!\n");
      }
      closedir($dh);
  
      if ($ENV{T2_KEEP_TEMPDIR}) {
          print STDERR "# Not removing temp dir: $tempdir\n";
          return;
      }
  
      my $abort = File::Spec->catfile($self->{+TEMPDIR}, "ABORT");
      unlink($abort) if -e $abort;
      rmdir($tempdir) or warn "Could not remove IPC temp dir ($tempdir)";
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::IPC::Driver::Files - Temp dir + Files concurrency model.
  
  =head1 DESCRIPTION
  
  This is the default, and fallback concurrency model for L<Test2>. This
  sends events between processes and threads using serialized files in a
  temporary directory. This is not particularly fast, but it works everywhere.
  
  =head1 SYNOPSIS
  
      use Test2::IPC::Driver::Files;
  
      # IPC is now enabled
  
  =head1 ENVIRONMENT VARIABLES
  
  =over 4
  
  =item T2_KEEP_TEMPDIR=0
  
  When true, the tempdir used by the IPC driver will not be deleted when the test
  is done.
  
  =item T2_TEMPDIR_TEMPLATE='test2-XXXXXX'
  
  This can be used to set the template for the IPC temp dir. The template should
  follow template specifications from L<File::Temp>.
  
  =back
  
  =head1 SEE ALSO
  
  See L<Test2::IPC::Driver> for methods.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_IPC_DRIVER_FILES

$fatpacked{"Test2/Tools/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_TINY';
  package Test2::Tools::Tiny;
  use strict;
  use warnings;
  
  BEGIN {
      if ($] lt "5.008") {
          require Test::Builder::IO::Scalar;
      }
  }
  
  use Scalar::Util qw/blessed/;
  
  use Test2::Util qw/try/;
  use Test2::API qw/context run_subtest test2_stack/;
  
  use Test2::Hub::Interceptor();
  use Test2::Hub::Interceptor::Terminator();
  
  our $VERSION = '1.302120';
  
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  our @EXPORT = qw{
      ok is isnt like unlike is_deeply diag note skip_all todo plan done_testing
      warnings exception tests capture
  };
  
  sub ok($;$@) {
      my ($bool, $name, @diag) = @_;
      my $ctx = context();
  
      return $ctx->pass_and_release($name) if $bool;
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub is($$;$@) {
      my ($got, $want, $name, @diag) = @_;
      my $ctx = context();
  
      my $bool;
      if (defined($got) && defined($want)) {
          $bool = "$got" eq "$want";
      }
      elsif (defined($got) xor defined($want)) {
          $bool = 0;
      }
      else {    # Both are undef
          $bool = 1;
      }
  
      return $ctx->pass_and_release($name) if $bool;
  
      $got  = '*NOT DEFINED*' unless defined $got;
      $want = '*NOT DEFINED*' unless defined $want;
      unshift @diag => (
          "GOT:      $got",
          "EXPECTED: $want",
      );
  
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub isnt($$;$@) {
      my ($got, $want, $name, @diag) = @_;
      my $ctx = context();
  
      my $bool;
      if (defined($got) && defined($want)) {
          $bool = "$got" ne "$want";
      }
      elsif (defined($got) xor defined($want)) {
          $bool = 1;
      }
      else {    # Both are undef
          $bool = 0;
      }
  
      return $ctx->pass_and_release($name) if $bool;
  
      unshift @diag => "Strings are the same (they should not be)"
          unless $bool;
  
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub like($$;$@) {
      my ($thing, $pattern, $name, @diag) = @_;
      my $ctx = context();
  
      my $bool;
      if (defined($thing)) {
          $bool = "$thing" =~ $pattern;
          unshift @diag => (
              "Value: $thing",
              "Does not match: $pattern"
          ) unless $bool;
      }
      else {
          $bool = 0;
          unshift @diag => "Got an undefined value.";
      }
  
      return $ctx->pass_and_release($name) if $bool;
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub unlike($$;$@) {
      my ($thing, $pattern, $name, @diag) = @_;
      my $ctx = context();
  
      my $bool;
      if (defined($thing)) {
          $bool = "$thing" !~ $pattern;
          unshift @diag => (
              "Unexpected pattern match (it should not match)",
              "Value:   $thing",
              "Matches: $pattern"
          ) unless $bool;
      }
      else {
          $bool = 0;
          unshift @diag => "Got an undefined value.";
      }
  
      return $ctx->pass_and_release($name) if $bool;
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub is_deeply($$;$@) {
      my ($got, $want, $name, @diag) = @_;
      my $ctx = context();
  
      no warnings 'once';
      require Data::Dumper;
  
      # Otherwise numbers might be unquoted
      local $Data::Dumper::Useperl  = 1;
  
      local $Data::Dumper::Sortkeys = 1;
      local $Data::Dumper::Deparse  = 1;
      local $Data::Dumper::Freezer  = 'XXX';
      local *UNIVERSAL::XXX         = sub {
          my ($thing) = @_;
          if (ref($thing)) {
              $thing = {%$thing}  if "$thing" =~ m/=HASH/;
              $thing = [@$thing]  if "$thing" =~ m/=ARRAY/;
              $thing = \"$$thing" if "$thing" =~ m/=SCALAR/;
          }
          $_[0] = $thing;
      };
  
      my $g = Data::Dumper::Dumper($got);
      my $w = Data::Dumper::Dumper($want);
  
      my $bool = $g eq $w;
  
      return $ctx->pass_and_release($name) if $bool;
      return $ctx->fail_and_release($name, $g, $w, @diag);
  }
  
  sub diag {
      my $ctx = context();
      $ctx->diag(join '', @_);
      $ctx->release;
  }
  
  sub note {
      my $ctx = context();
      $ctx->note(join '', @_);
      $ctx->release;
  }
  
  sub skip_all {
      my ($reason) = @_;
      my $ctx = context();
      $ctx->plan(0, SKIP => $reason);
      $ctx->release if $ctx;
  }
  
  sub todo {
      my ($reason, $sub) = @_;
      my $ctx = context();
  
      # This code is mostly copied from Test2::Todo in the Test2-Suite
      # distribution.
      my $hub    = test2_stack->top;
      my $filter = $hub->pre_filter(
          sub {
              my ($active_hub, $event) = @_;
              if ($active_hub == $hub) {
                  $event->set_todo($reason) if $event->can('set_todo');
                  $event->add_amnesty({tag => 'TODO', details => $reason});
              }
              else {
                  $event->add_amnesty({tag => 'TODO', details => $reason, inherited => 1});
              }
              return $event;
          },
          inherit => 1,
          todo    => $reason,
      );
      $sub->();
      $hub->pre_unfilter($filter);
  
      $ctx->release if $ctx;
  }
  
  sub plan {
      my ($max) = @_;
      my $ctx = context();
      $ctx->plan($max);
      $ctx->release;
  }
  
  sub done_testing {
      my $ctx = context();
      $ctx->done_testing;
      $ctx->release;
  }
  
  sub warnings(&) {
      my $code = shift;
      my @warnings;
      local $SIG{__WARN__} = sub { push @warnings => @_ };
      $code->();
      return \@warnings;
  }
  
  sub exception(&) {
      my $code = shift;
      local ($@, $!, $SIG{__DIE__});
      my $ok = eval { $code->(); 1 };
      my $error = $@ || 'SQUASHED ERROR';
      return $ok ? undef : $error;
  }
  
  sub tests {
      my ($name, $code) = @_;
      my $ctx = context();
  
      my $be = caller->can('before_each');
  
      $be->($name) if $be;
  
      my $bool = run_subtest($name, $code, 1);
  
      $ctx->release;
  
      return $bool;
  }
  
  sub capture(&) {
      my $code = shift;
  
      my ($err, $out) = ("", "");
  
      my $handles = test2_stack->top->format->handles;
      my ($ok, $e);
      {
          my ($out_fh, $err_fh);
  
          ($ok, $e) = try {
            # Scalar refs as filehandles were added in 5.8.
            if ($] ge "5.008") {
              open($out_fh, '>', \$out) or die "Failed to open a temporary STDOUT: $!";
              open($err_fh, '>', \$err) or die "Failed to open a temporary STDERR: $!";
            }
            # Emulate scalar ref filehandles with a tie.
            else {
              $out_fh = Test::Builder::IO::Scalar->new(\$out) or die "Failed to open a temporary STDOUT";
              $err_fh = Test::Builder::IO::Scalar->new(\$err) or die "Failed to open a temporary STDERR";
            }
  
              test2_stack->top->format->set_handles([$out_fh, $err_fh, $out_fh]);
  
              $code->();
          };
      }
      test2_stack->top->format->set_handles($handles);
  
      die $e unless $ok;
  
      $err =~ s/ $/_/mg;
      $out =~ s/ $/_/mg;
  
      return {
          STDOUT => $out,
          STDERR => $err,
      };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Tools::Tiny - Tiny set of tools for unfortunate souls who cannot use
  L<Test2::Suite>.
  
  =head1 DESCRIPTION
  
  You should really look at L<Test2::Suite>. This package is some very basic
  essential tools implemented using L<Test2>. This exists only so that L<Test2>
  and other tools required by L<Test2::Suite> can be tested. This is the package
  L<Test2> uses to test itself.
  
  =head1 USE Test2::Suite INSTEAD
  
  Use L<Test2::Suite> if at all possible.
  
  =head1 EXPORTS
  
  =over 4
  
  =item ok($bool, $name)
  
  =item ok($bool, $name, @diag)
  
  Run a simple assertion.
  
  =item is($got, $want, $name)
  
  =item is($got, $want, $name, @diag)
  
  Assert that 2 strings are the same.
  
  =item isnt($got, $do_not_want, $name)
  
  =item isnt($got, $do_not_want, $name, @diag)
  
  Assert that 2 strings are not the same.
  
  =item like($got, $regex, $name)
  
  =item like($got, $regex, $name, @diag)
  
  Check that the input string matches the regex.
  
  =item unlike($got, $regex, $name)
  
  =item unlike($got, $regex, $name, @diag)
  
  Check that the input string does not match the regex.
  
  =item is_deeply($got, $want, $name)
  
  =item is_deeply($got, $want, $name, @diag)
  
  Check 2 data structures. Please note that this is a I<DUMB> implementation that
  compares the output of L<Data::Dumper> against both structures.
  
  =item diag($msg)
  
  Issue a diagnostics message to STDERR.
  
  =item note($msg)
  
  Issue a diagnostics message to STDOUT.
  
  =item skip_all($reason)
  
  Skip all tests.
  
  =item todo $reason => sub { ... }
  
  Run a block in TODO mode.
  
  =item plan($count)
  
  Set the plan.
  
  =item done_testing()
  
  Set the plan to the current test count.
  
  =item $warnings = warnings { ... }
  
  Capture an arrayref of warnings from the block.
  
  =item $exception = exception { ... }
  
  Capture an exception.
  
  =item tests $name => sub { ... }
  
  Run a subtest.
  
  =item $output = capture { ... }
  
  Capture STDOUT and STDERR output.
  
  Result looks like this:
  
      {
          STDOUT => "...",
          STDERR => "...",
      }
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_TOOLS_TINY

$fatpacked{"Test2/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL';
  package Test2::Util;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  use POSIX();
  use Config qw/%Config/;
  use Carp qw/croak/;
  
  BEGIN {
      local ($@, $!, $SIG{__DIE__});
      *HAVE_PERLIO = eval { require PerlIO; PerlIO->VERSION(1.02); } ? sub() { 1 } : sub() { 0 };
  }
  
  our @EXPORT_OK = qw{
      try
  
      pkg_to_file
  
      get_tid USE_THREADS
      CAN_THREAD
      CAN_REALLY_FORK
      CAN_FORK
  
      CAN_SIGSYS
  
      IS_WIN32
  
      ipc_separator
  
      do_rename do_unlink
  
      try_sig_mask
  
      clone_io
  };
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  BEGIN {
      *IS_WIN32 = ($^O eq 'MSWin32') ? sub() { 1 } : sub() { 0 };
  }
  
  sub _can_thread {
      return 0 unless $] >= 5.008001;
      return 0 unless $Config{'useithreads'};
  
      # Threads are broken on perl 5.10.0 built with gcc 4.8+
      if ($] == 5.010000 && $Config{'ccname'} eq 'gcc' && $Config{'gccversion'}) {
          my @parts = split /\./, $Config{'gccversion'};
          return 0 if $parts[0] > 4 || ($parts[0] == 4 && $parts[1] >= 8);
      }
  
      # Change to a version check if this ever changes
      return 0 if $INC{'Devel/Cover.pm'};
      return 1;
  }
  
  sub _can_fork {
      return 1 if $Config{d_fork};
      return 0 unless IS_WIN32 || $^O eq 'NetWare';
      return 0 unless $Config{useithreads};
      return 0 unless $Config{ccflags} =~ /-DPERL_IMPLICIT_SYS/;
  
      return _can_thread();
  }
  
  BEGIN {
      no warnings 'once';
      *CAN_THREAD      = _can_thread()   ? sub() { 1 } : sub() { 0 };
  }
  my $can_fork;
  sub CAN_FORK () {
      return $can_fork
          if defined $can_fork;
      $can_fork = !!_can_fork();
      no warnings 'redefine';
      *CAN_FORK = $can_fork ? sub() { 1 } : sub() { 0 };
      $can_fork;
  }
  my $can_really_fork;
  sub CAN_REALLY_FORK () {
      return $can_really_fork
          if defined $can_really_fork;
      $can_really_fork = !!$Config{d_fork};
      no warnings 'redefine';
      *CAN_REALLY_FORK = $can_really_fork ? sub() { 1 } : sub() { 0 };
      $can_really_fork;
  }
  
  sub _manual_try(&;@) {
      my $code = shift;
      my $args = \@_;
      my $err;
  
      my $die = delete $SIG{__DIE__};
  
      eval { $code->(@$args); 1 } or $err = $@ || "Error was squashed!\n";
  
      $die ? $SIG{__DIE__} = $die : delete $SIG{__DIE__};
  
      return (!defined($err), $err);
  }
  
  sub _local_try(&;@) {
      my $code = shift;
      my $args = \@_;
      my $err;
  
      no warnings;
      local $SIG{__DIE__};
      eval { $code->(@$args); 1 } or $err = $@ || "Error was squashed!\n";
  
      return (!defined($err), $err);
  }
  
  # Older versions of perl have a nasty bug on win32 when localizing a variable
  # before forking or starting a new thread. So for those systems we use the
  # non-local form. When possible though we use the faster 'local' form.
  BEGIN {
      if (IS_WIN32 && $] < 5.020002) {
          *try = \&_manual_try;
      }
      else {
          *try = \&_local_try;
      }
  }
  
  BEGIN {
      if (CAN_THREAD) {
          if ($INC{'threads.pm'}) {
              # Threads are already loaded, so we do not need to check if they
              # are loaded each time
              *USE_THREADS = sub() { 1 };
              *get_tid     = sub() { threads->tid() };
          }
          else {
              # :-( Need to check each time to see if they have been loaded.
              *USE_THREADS = sub() { $INC{'threads.pm'} ? 1 : 0 };
              *get_tid     = sub() { $INC{'threads.pm'} ? threads->tid() : 0 };
          }
      }
      else {
          # No threads, not now, not ever!
          *USE_THREADS = sub() { 0 };
          *get_tid     = sub() { 0 };
      }
  }
  
  sub pkg_to_file {
      my $pkg = shift;
      my $file = $pkg;
      $file =~ s{(::|')}{/}g;
      $file .= '.pm';
      return $file;
  }
  
  sub ipc_separator() { "~" }
  
  sub _check_for_sig_sys {
      my $sig_list = shift;
      return $sig_list =~ m/\bSYS\b/;
  }
  
  BEGIN {
      if (_check_for_sig_sys($Config{sig_name})) {
          *CAN_SIGSYS = sub() { 1 };
      }
      else {
          *CAN_SIGSYS = sub() { 0 };
      }
  }
  
  my %PERLIO_SKIP = (
      unix => 1,
      via  => 1,
  );
  
  sub clone_io {
      my ($fh) = @_;
      my $fileno = fileno($fh);
  
      return $fh if !defined($fileno) || !length($fileno) || $fileno < 0;
  
      open(my $out, '>&' . $fileno) or die "Can't dup fileno $fileno: $!";
  
      my %seen;
      my @layers = HAVE_PERLIO ? grep { !$PERLIO_SKIP{$_} and !$seen{$_}++ } PerlIO::get_layers($fh) : ();
      binmode($out, join(":", "", "raw", @layers));
  
      my $old = select $fh;
      my $af  = $|;
      select $out;
      $| = $af;
      select $old;
  
      return $out;
  }
  
  BEGIN {
      if (IS_WIN32) {
          my $max_tries = 5;
  
          *do_rename = sub {
              my ($from, $to) = @_;
  
              my $err;
              for (1 .. $max_tries) {
                  return (1) if rename($from, $to);
                  $err = "$!";
                  last if $_ == $max_tries;
                  sleep 1;
              }
  
              return (0, $err);
          };
          *do_unlink = sub {
              my ($file) = @_;
  
              my $err;
              for (1 .. $max_tries) {
                  return (1) if unlink($file);
                  $err = "$!";
                  last if $_ == $max_tries;
                  sleep 1;
              }
  
              return (0, "$!");
          };
      }
      else {
          *do_rename = sub {
              my ($from, $to) = @_;
              return (1) if rename($from, $to);
              return (0, "$!");
          };
          *do_unlink = sub {
              my ($file) = @_;
              return (1) if unlink($file);
              return (0, "$!");
          };
      }
  }
  
  sub try_sig_mask(&) {
      my $code = shift;
  
      my ($old, $blocked);
      unless(IS_WIN32) {
          my $to_block = POSIX::SigSet->new(
              POSIX::SIGINT(),
              POSIX::SIGALRM(),
              POSIX::SIGHUP(),
              POSIX::SIGTERM(),
              POSIX::SIGUSR1(),
              POSIX::SIGUSR2(),
          );
          $old = POSIX::SigSet->new;
          $blocked = POSIX::sigprocmask(POSIX::SIG_BLOCK(), $to_block, $old);
          # Silently go on if we failed to log signals, not much we can do.
      }
  
      my ($ok, $err) = &try($code);
  
      # If our block was successful we want to restore the old mask.
      POSIX::sigprocmask(POSIX::SIG_SETMASK(), $old, POSIX::SigSet->new()) if defined $blocked;
  
      return ($ok, $err);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util - Tools used by Test2 and friends.
  
  =head1 DESCRIPTION
  
  Collection of tools used by L<Test2> and friends.
  
  =head1 EXPORTS
  
  All exports are optional. You must specify subs to import.
  
  =over 4
  
  =item ($success, $error) = try { ... }
  
  Eval the codeblock, return success or failure, and the error message. This code
  protects $@ and $!, they will be restored by the end of the run. This code also
  temporarily blocks $SIG{DIE} handlers.
  
  =item protect { ... }
  
  Similar to try, except that it does not catch exceptions. The idea here is to
  protect $@ and $! from changes. $@ and $! will be restored to whatever they
  were before the run so long as it is successful. If the run fails $! will still
  be restored, but $@ will contain the exception being thrown.
  
  =item CAN_FORK
  
  True if this system is capable of true or pseudo-fork.
  
  =item CAN_REALLY_FORK
  
  True if the system can really fork. This will be false for systems where fork
  is emulated.
  
  =item CAN_THREAD
  
  True if this system is capable of using threads.
  
  =item USE_THREADS
  
  Returns true if threads are enabled, false if they are not.
  
  =item get_tid
  
  This will return the id of the current thread when threads are enabled,
  otherwise it returns 0.
  
  =item my $file = pkg_to_file($package)
  
  Convert a package name to a filename.
  
  =item ($ok, $err) = do_rename($old_name, $new_name)
  
  Rename a file, this wraps C<rename()> in a way that makes it more reliable
  cross-platform when trying to rename files you recently altered.
  
  =item ($ok, $err) = do_unlink($filename)
  
  Unlink a file, this wraps C<unlink()> in a way that makes it more reliable
  cross-platform when trying to unlink files you recently altered.
  
  =item ($ok, $err) = try_sig_mask { ... }
  
  Complete an action with several signals masked, they will be unmasked at the
  end allowing any signals that were intercepted to get handled.
  
  This is primarily used when you need to make several actions atomic (against
  some signals anyway).
  
  Signals that are intercepted:
  
  =over 4
  
  =item SIGINT
  
  =item SIGALRM
  
  =item SIGHUP
  
  =item SIGTERM
  
  =item SIGUSR1
  
  =item SIGUSR2
  
  =back
  
  =back
  
  =head1 NOTES && CAVEATS
  
  =over 4
  
  =item 5.10.0
  
  Perl 5.10.0 has a bug when compiled with newer gcc versions. This bug causes a
  segfault whenever a new thread is launched. Test2 will attempt to detect
  this, and note that the system is not capable of forking when it is detected.
  
  =item Devel::Cover
  
  Devel::Cover does not support threads. CAN_THREAD will return false if
  Devel::Cover is loaded before the check is first run.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =item Kent Fredric E<lt>kentnl@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL

$fatpacked{"Test2/Util/ExternalMeta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_EXTERNALMETA';
  package Test2::Util::ExternalMeta;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  
  use Carp qw/croak/;
  
  sub META_KEY() { '_meta' }
  
  our @EXPORT = qw/meta set_meta get_meta delete_meta/;
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  sub set_meta {
      my $self = shift;
      my ($key, $value) = @_;
  
      validate_key($key);
  
      $self->{+META_KEY} ||= {};
      $self->{+META_KEY}->{$key} = $value;
  }
  
  sub get_meta {
      my $self = shift;
      my ($key) = @_;
  
      validate_key($key);
  
      my $meta = $self->{+META_KEY} or return undef;
      return $meta->{$key};
  }
  
  sub delete_meta {
      my $self = shift;
      my ($key) = @_;
  
      validate_key($key);
  
      my $meta = $self->{+META_KEY} or return undef;
      delete $meta->{$key};
  }
  
  sub meta {
      my $self = shift;
      my ($key, $default) = @_;
  
      validate_key($key);
  
      my $meta = $self->{+META_KEY};
      return undef unless $meta || defined($default);
  
      unless($meta) {
          $meta = {};
          $self->{+META_KEY} = $meta;
      }
  
      $meta->{$key} = $default
          if defined($default) && !defined($meta->{$key});
  
      return $meta->{$key};
  }
  
  sub validate_key {
      my $key = shift;
  
      return if $key && !ref($key);
  
      my $render_key = defined($key) ? "'$key'" : 'undef';
      croak "Invalid META key: $render_key, keys must be true, and may not be references";
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util::ExternalMeta - Allow third party tools to safely attach meta-data
  to your instances.
  
  =head1 DESCRIPTION
  
  This package lets you define a clear, and consistent way to allow third party
  tools to attach meta-data to your instances. If your object consumes this
  package, and imports its methods, then third party meta-data has a safe place
  to live.
  
  =head1 SYNOPSIS
  
      package My::Object;
      use strict;
      use warnings;
  
      use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;
  
      ...
  
  Now to use it:
  
      my $inst = My::Object->new;
  
      $inst->set_meta(foo => 'bar');
      my $val = $inst->get_meta('foo');
  
  =head1 WHERE IS THE DATA STORED?
  
  This package assumes your instances are blessed hashrefs, it will not work if
  that is not true. It will store all meta-data in the C<_meta> key on your
  objects hash. If your object makes use of the C<_meta> key in its underlying
  hash, then there is a conflict and you cannot use this package.
  
  =head1 EXPORTS
  
  =over 4
  
  =item $val = $obj->meta($key)
  
  =item $val = $obj->meta($key, $default)
  
  This will get the value for a specified meta C<$key>. Normally this will return
  C<undef> when there is no value for the C<$key>, however you can specify a
  C<$default> value to set when no value is already set.
  
  =item $val = $obj->get_meta($key)
  
  This will get the value for a specified meta C<$key>. This does not have the
  C<$default> overhead that C<meta()> does.
  
  =item $val = $obj->delete_meta($key)
  
  This will remove the value of a specified meta C<$key>. The old C<$val> will be
  returned.
  
  =item $obj->set_meta($key, $val)
  
  Set the value of a specified meta C<$key>.
  
  =back
  
  =head1 META-KEY RESTRICTIONS
  
  Meta keys must be defined, and must be true when used as a boolean. Keys may
  not be references. You are free to stringify a reference C<"$ref"> for use as a
  key, but this package will not stringify it for you.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL_EXTERNALMETA

$fatpacked{"Test2/Util/Facets2Legacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_FACETS2LEGACY';
  package Test2::Util::Facets2Legacy;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  use Carp qw/croak confess/;
  use Scalar::Util qw/blessed/;
  
  use base 'Exporter';
  our @EXPORT_OK = qw{
      causes_fail
      diagnostics
      global
      increments_count
      no_display
      sets_plan
      subtest_id
      summary
      terminate
  };
  our %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  our $CYCLE_DETECT = 0;
  sub _get_facet_data {
      my $in = shift;
  
      if (blessed($in) && $in->isa('Test2::Event')) {
          confess "Cycle between Facets2Legacy and $in\->facet_data() (Did you forget to override the facet_data() method?)"
              if $CYCLE_DETECT;
  
          local $CYCLE_DETECT = 1;
          return $in->facet_data;
      }
  
      return $in if ref($in) eq 'HASH';
  
      croak "'$in' Does not appear to be either a Test::Event or an EventFacet hashref";
  }
  
  sub causes_fail {
      my $facet_data = _get_facet_data(shift @_);
  
      return 1 if $facet_data->{errors} && grep { $_->{fail} } @{$facet_data->{errors}};
  
      if (my $control = $facet_data->{control}) {
          return 1 if $control->{halt};
          return 1 if $control->{terminate};
      }
  
      return 0 if $facet_data->{amnesty} && @{$facet_data->{amnesty}};
      return 1 if $facet_data->{assert} && !$facet_data->{assert}->{pass};
      return 0;
  }
  
  sub diagnostics {
      my $facet_data = _get_facet_data(shift @_);
      return 1 if $facet_data->{errors} && @{$facet_data->{errors}};
      return 0 unless $facet_data->{info} && @{$facet_data->{info}};
      return (grep { $_->{debug} } @{$facet_data->{info}}) ? 1 : 0;
  }
  
  sub global {
      my $facet_data = _get_facet_data(shift @_);
      return 0 unless $facet_data->{control};
      return $facet_data->{control}->{global};
  }
  
  sub increments_count {
      my $facet_data = _get_facet_data(shift @_);
      return $facet_data->{assert} ? 1 : 0;
  }
  
  sub no_display {
      my $facet_data = _get_facet_data(shift @_);
      return 0 unless $facet_data->{about};
      return $facet_data->{about}->{no_display};
  }
  
  sub sets_plan {
      my $facet_data = _get_facet_data(shift @_);
      my $plan = $facet_data->{plan} or return;
      my @out = ($plan->{count} || 0);
  
      if ($plan->{skip}) {
          push @out => 'SKIP';
          push @out => $plan->{details} if defined $plan->{details};
      }
      elsif ($plan->{none}) {
          push @out => 'NO PLAN'
      }
  
      return @out;
  }
  
  sub subtest_id {
      my $facet_data = _get_facet_data(shift @_);
      return undef unless $facet_data->{parent};
      return $facet_data->{parent}->{hid};
  }
  
  sub summary {
      my $facet_data = _get_facet_data(shift @_);
      return '' unless $facet_data->{about} && $facet_data->{about}->{details};
      return $facet_data->{about}->{details};
  }
  
  sub terminate {
      my $facet_data = _get_facet_data(shift @_);
      return undef unless $facet_data->{control};
      return $facet_data->{control}->{terminate};
  }
  
  1;
TEST2_UTIL_FACETS2LEGACY

$fatpacked{"Test2/Util/HashBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_HASHBASE';
  package Test2::Util::HashBase;
  use strict;
  use warnings;
  
  our $VERSION = '1.302120';
  
  #################################################################
  #                                                               #
  #  This is a generated file! Do not modify this file directly!  #
  #  Use hashbase_inc.pl script to regenerate this file.          #
  #  The script is part of the Object::HashBase distribution.     #
  #  Note: You can modify the version number above this comment   #
  #  if needed, that is fine.                                     #
  #                                                               #
  #################################################################
  
  {
      no warnings 'once';
      $Test2::Util::HashBase::HB_VERSION = '0.006';
      *Test2::Util::HashBase::ATTR_SUBS = \%Object::HashBase::ATTR_SUBS;
      *Test2::Util::HashBase::ATTR_LIST = \%Object::HashBase::ATTR_LIST;
      *Test2::Util::HashBase::VERSION   = \%Object::HashBase::VERSION;
      *Test2::Util::HashBase::CAN_CACHE = \%Object::HashBase::CAN_CACHE;
  }
  
  
  require Carp;
  {
      no warnings 'once';
      $Carp::Internal{+__PACKAGE__} = 1;
  }
  
  BEGIN {
      # these are not strictly equivalent, but for out use we don't care
      # about order
      *_isa = ($] >= 5.010 && require mro) ? \&mro::get_linear_isa : sub {
          no strict 'refs';
          my @packages = ($_[0]);
          my %seen;
          for my $package (@packages) {
              push @packages, grep !$seen{$_}++, @{"$package\::ISA"};
          }
          return \@packages;
      }
  }
  
  my %STRIP = (
      '^' => 1,
      '-' => 1,
  );
  
  sub import {
      my $class = shift;
      my $into  = caller;
  
      # Make sure we list the OLDEST version used to create this class.
      my $ver = $Test2::Util::HashBase::HB_VERSION || $Test2::Util::HashBase::VERSION;
      $Test2::Util::HashBase::VERSION{$into} = $ver if !$Test2::Util::HashBase::VERSION{$into} || $Test2::Util::HashBase::VERSION{$into} > $ver;
  
      my $isa = _isa($into);
      my $attr_list = $Test2::Util::HashBase::ATTR_LIST{$into} ||= [];
      my $attr_subs = $Test2::Util::HashBase::ATTR_SUBS{$into} ||= {};
  
      my %subs = (
          ($into->can('new') ? () : (new => \&_new)),
          (map %{$Test2::Util::HashBase::ATTR_SUBS{$_} || {}}, @{$isa}[1 .. $#$isa]),
          (
              map {
                  my $p = substr($_, 0, 1);
                  my $x = $_;
                  substr($x, 0, 1) = '' if $STRIP{$p};
                  push @$attr_list => $x;
                  my ($sub, $attr) = (uc $x, $x);
                  $sub => ($attr_subs->{$sub} = sub() { $attr }),
                      $attr => sub { $_[0]->{$attr} },
                        $p eq '-' ? ("set_$attr" => sub { Carp::croak("'$attr' is read-only") })
                      : $p eq '^' ? ("set_$attr" => sub { Carp::carp("set_$attr() is deprecated"); $_[0]->{$attr} = $_[1] })
                      : ("set_$attr" => sub { $_[0]->{$attr} = $_[1] }),
              } @_
          ),
      );
  
      no strict 'refs';
      *{"$into\::$_"} = $subs{$_} for keys %subs;
  }
  
  sub attr_list {
      my $class = shift;
  
      my $isa = _isa($class);
  
      my %seen;
      my @list = grep { !$seen{$_}++ } map {
          my @out;
  
          if (0.004 > ($Test2::Util::HashBase::VERSION{$_} || 0)) {
              Carp::carp("$_ uses an inlined version of Test2::Util::HashBase too old to support attr_list()");
          }
          else {
              my $list = $Test2::Util::HashBase::ATTR_LIST{$_};
              @out = $list ? @$list : ()
          }
  
          @out;
      } reverse @$isa;
  
      return @list;
  }
  
  sub _new {
      my $class = shift;
  
      my $self;
  
      if (@_ == 1) {
          my $arg = shift;
          my $type = ref($arg);
  
          if ($type eq 'HASH') {
              $self = bless({%$arg}, $class)
          }
          else {
              Carp::croak("Not sure what to do with '$type' in $class constructor")
                  unless $type eq 'ARRAY';
  
              my %proto;
              my @attributes = attr_list($class);
              while (@$arg) {
                  my $val = shift @$arg;
                  my $key = shift @attributes or Carp::croak("Too many arguments for $class constructor");
                  $proto{$key} = $val;
              }
  
              $self = bless(\%proto, $class);
          }
      }
      else {
          $self = bless({@_}, $class);
      }
  
      $Test2::Util::HashBase::CAN_CACHE{$class} = $self->can('init')
          unless exists $Test2::Util::HashBase::CAN_CACHE{$class};
  
      $self->init if $Test2::Util::HashBase::CAN_CACHE{$class};
  
      $self;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util::HashBase - Build hash based classes.
  
  =head1 SYNOPSIS
  
  A class:
  
      package My::Class;
      use strict;
      use warnings;
  
      # Generate 3 accessors
      use Test2::Util::HashBase qw/foo -bar ^baz/;
  
      # Chance to initialize defaults
      sub init {
          my $self = shift;    # No other args
          $self->{+FOO} ||= "foo";
          $self->{+BAR} ||= "bar";
          $self->{+BAZ} ||= "baz";
      }
  
      sub print {
          print join ", " => map { $self->{$_} } FOO, BAR, BAZ;
      }
  
  Subclass it
  
      package My::Subclass;
      use strict;
      use warnings;
  
      # Note, you should subclass before loading HashBase.
      use base 'My::Class';
      use Test2::Util::HashBase qw/bat/;
  
      sub init {
          my $self = shift;
  
          # We get the constants from the base class for free.
          $self->{+FOO} ||= 'SubFoo';
          $self->{+BAT} ||= 'bat';
  
          $self->SUPER::init();
      }
  
  use it:
  
      package main;
      use strict;
      use warnings;
      use My::Class;
  
      # These are all functionally identical
      my $one   = My::Class->new(foo => 'MyFoo', bar => 'MyBar');
      my $two   = My::Class->new({foo => 'MyFoo', bar => 'MyBar'});
      my $three = My::Class->new(['MyFoo', 'MyBar']);
  
      # Accessors!
      my $foo = $one->foo;    # 'MyFoo'
      my $bar = $one->bar;    # 'MyBar'
      my $baz = $one->baz;    # Defaulted to: 'baz'
  
      # Setters!
      $one->set_foo('A Foo');
  
      #'-bar' means read-only, so the setter will throw an exception (but is defined).
      $one->set_bar('A bar');
  
      # '^baz' means deprecated setter, this will warn about the setter being
      # deprecated.
      $one->set_baz('A Baz');
  
      $one->{+FOO} = 'xxx';
  
  =head1 DESCRIPTION
  
  This package is used to generate classes based on hashrefs. Using this class
  will give you a C<new()> method, as well as generating accessors you request.
  Generated accessors will be getters, C<set_ACCESSOR> setters will also be
  generated for you. You also get constants for each accessor (all caps) which
  return the key into the hash for that accessor. Single inheritance is also
  supported.
  
  =head1 THIS IS A BUNDLED COPY OF HASHBASE
  
  This is a bundled copy of L<Object::HashBase>. This file was generated using
  the
  C</home/exodist/perl5/perlbrew/perls/main/bin/hashbase_inc.pl>
  script.
  
  =head1 METHODS
  
  =head2 PROVIDED BY HASH BASE
  
  =over 4
  
  =item $it = $class->new(%PAIRS)
  
  =item $it = $class->new(\%PAIRS)
  
  =item $it = $class->new(\@ORDERED_VALUES)
  
  Create a new instance.
  
  HashBase will not export C<new()> if there is already a C<new()> method in your
  packages inheritance chain.
  
  B<If you do not want this method you can define your own> you just have to
  declare it before loading L<Test2::Util::HashBase>.
  
      package My::Package;
  
      # predeclare new() so that HashBase does not give us one.
      sub new;
  
      use Test2::Util::HashBase qw/foo bar baz/;
  
      # Now we define our own new method.
      sub new { ... }
  
  This makes it so that HashBase sees that you have your own C<new()> method.
  Alternatively you can define the method before loading HashBase instead of just
  declaring it, but that scatters your use statements.
  
  The most common way to create an object is to pass in key/value pairs where
  each key is an attribute and each value is what you want assigned to that
  attribute. No checking is done to verify the attributes or values are valid,
  you may do that in C<init()> if desired.
  
  If you would like, you can pass in a hashref instead of pairs. When you do so
  the hashref will be copied, and the copy will be returned blessed as an object.
  There is no way to ask HashBase to bless a specific hashref.
  
  In some cases an object may only have 1 or 2 attributes, in which case a
  hashref may be too verbose for your liking. In these cases you can pass in an
  arrayref with only values. The values will be assigned to attributes in the
  order the attributes were listed. When there is inheritance involved the
  attributes from parent classes will come before subclasses.
  
  =back
  
  =head2 HOOKS
  
  =over 4
  
  =item $self->init()
  
  This gives you the chance to set some default values to your fields. The only
  argument is C<$self> with its indexes already set from the constructor.
  
  B<Note:> Test2::Util::HashBase checks for an init using C<< $class->can('init') >>
  during construction. It DOES NOT call C<can()> on the created object. Also note
  that the result of the check is cached, it is only ever checked once, the first
  time an instance of your class is created. This means that adding an C<init()>
  method AFTER the first construction will result in it being ignored.
  
  =back
  
  =head1 ACCESSORS
  
  =head2 READ/WRITE
  
  To generate accessors you list them when using the module:
  
      use Test2::Util::HashBase qw/foo/;
  
  This will generate the following subs in your namespace:
  
  =over 4
  
  =item foo()
  
  Getter, used to get the value of the C<foo> field.
  
  =item set_foo()
  
  Setter, used to set the value of the C<foo> field.
  
  =item FOO()
  
  Constant, returns the field C<foo>'s key into the class hashref. Subclasses will
  also get this function as a constant, not simply a method, that means it is
  copied into the subclass namespace.
  
  The main reason for using these constants is to help avoid spelling mistakes
  and similar typos. It will not help you if you forget to prefix the '+' though.
  
  =back
  
  =head2 READ ONLY
  
      use Test2::Util::HashBase qw/-foo/;
  
  =over 4
  
  =item set_foo()
  
  Throws an exception telling you the attribute is read-only. This is exported to
  override any active setters for the attribute in a parent class.
  
  =back
  
  =head2 DEPRECATED SETTER
  
      use Test2::Util::HashBase qw/^foo/;
  
  =over 4
  
  =item set_foo()
  
  This will set the value, but it will also warn you that the method is
  deprecated.
  
  =back
  
  =head1 SUBCLASSING
  
  You can subclass an existing HashBase class.
  
      use base 'Another::HashBase::Class';
      use Test2::Util::HashBase qw/foo bar baz/;
  
  The base class is added to C<@ISA> for you, and all constants from base classes
  are added to subclasses automatically.
  
  =head1 GETTING A LIST OF ATTRIBUTES FOR A CLASS
  
  Test2::Util::HashBase provides a function for retrieving a list of attributes for an
  Test2::Util::HashBase class.
  
  =over 4
  
  =item @list = Test2::Util::HashBase::attr_list($class)
  
  =item @list = $class->Test2::Util::HashBase::attr_list()
  
  Either form above will work. This will return a list of attributes defined on
  the object. This list is returned in the attribute definition order, parent
  class attributes are listed before subclass attributes. Duplicate attributes
  will be removed before the list is returned.
  
  B<Note:> This list is used in the C<< $class->new(\@ARRAY) >> constructor to
  determine the attribute to which each value will be paired.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for HashBase can be found at
  F<http://github.com/Test-More/HashBase/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2017 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL_HASHBASE

$fatpacked{"Test2/Util/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TRACE';
  package Test2::Util::Trace;
  require Test2::EventFacet::Trace;
  @ISA = ('Test2::EventFacet::Trace');
  
  our $VERSION = '1.302120';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util::Trace - Legacy wrapper fro L<Test2::EventFacet::Trace>.
  
  =head1 DESCRIPTION
  
  All the functionality for this class has been moved to
  L<Test2::EventFacet::Trace>.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2016 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL_TRACE

$fatpacked{"Types/Serialiser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_SERIALISER';
  =head1 NAME
  
  Types::Serialiser - simple data types for common serialisation formats
  
  =encoding utf-8
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  This module provides some extra datatypes that are used by common
  serialisation formats such as JSON or CBOR. The idea is to have a
  repository of simple/small constants and containers that can be shared by
  different implementations so they become interoperable between each other.
  
  =cut
  
  package Types::Serialiser;
  
  use common::sense; # required to suppress annoying warnings
  
  our $VERSION = '1.0';
  
  =head1 SIMPLE SCALAR CONSTANTS
  
  Simple scalar constants are values that are overloaded to act like simple
  Perl values, but have (class) type to differentiate them from normal Perl
  scalars. This is necessary because these have different representations in
  the serialisation formats.
  
  =head2 BOOLEANS (Types::Serialiser::Boolean class)
  
  This type has only two instances, true and false. A natural representation
  for these in Perl is C<1> and C<0>, but serialisation formats need to be
  able to differentiate between them and mere numbers.
  
  =over 4
  
  =item $Types::Serialiser::true, Types::Serialiser::true
  
  This value represents the "true" value. In most contexts is acts like
  the number C<1>. It is up to you whether you use the variable form
  (C<$Types::Serialiser::true>) or the constant form (C<Types::Serialiser::true>).
  
  The constant is represented as a reference to a scalar containing C<1> -
  implementations are allowed to directly test for this.
  
  =item $Types::Serialiser::false, Types::Serialiser::false
  
  This value represents the "false" value. In most contexts is acts like
  the number C<0>. It is up to you whether you use the variable form
  (C<$Types::Serialiser::false>) or the constant form (C<Types::Serialiser::false>).
  
  The constant is represented as a reference to a scalar containing C<0> -
  implementations are allowed to directly test for this.
  
  =item $is_bool = Types::Serialiser::is_bool $value
  
  Returns true iff the C<$value> is either C<$Types::Serialiser::true> or
  C<$Types::Serialiser::false>.
  
  For example, you could differentiate between a perl true value and a
  C<Types::Serialiser::true> by using this:
  
     $value && Types::Serialiser::is_bool $value
  
  =item $is_true = Types::Serialiser::is_true $value
  
  Returns true iff C<$value> is C<$Types::Serialiser::true>.
  
  =item $is_false = Types::Serialiser::is_false $value
  
  Returns false iff C<$value> is C<$Types::Serialiser::false>.
  
  =back
  
  =head2 ERROR (Types::Serialiser::Error class)
  
  This class has only a single instance, C<error>. It is used to signal
  an encoding or decoding error. In CBOR for example, and object that
  couldn't be encoded will be represented by a CBOR undefined value, which
  is represented by the error value in Perl.
  
  =over 4
  
  =item $Types::Serialiser::error, Types::Serialiser::error
  
  This value represents the "error" value. Accessing values of this type
  will throw an exception.
  
  The constant is represented as a reference to a scalar containing C<undef>
  - implementations are allowed to directly test for this.
  
  =item $is_error = Types::Serialiser::is_error $value
  
  Returns false iff C<$value> is C<$Types::Serialiser::error>.
  
  =back
  
  =cut
  
  BEGIN {
     # for historical reasons, and to avoid extra dependencies in JSON::PP,
     # we alias *Types::Serialiser::Boolean with JSON::PP::Boolean.
     package JSON::PP::Boolean;
  
     *Types::Serialiser::Boolean:: = *JSON::PP::Boolean::;
  }
  
  {
     # this must done before blessing to work around bugs
     # in perl < 5.18 (it seems to be fixed in 5.18).
     package Types::Serialiser::BooleanBase;
  
     use overload
        "0+"     => sub { ${$_[0]} },
        "++"     => sub { $_[0] = ${$_[0]} + 1 },
        "--"     => sub { $_[0] = ${$_[0]} - 1 },
        fallback => 1;
  
     @Types::Serialiser::Boolean::ISA = Types::Serialiser::BooleanBase::;
  }
  
  our $true  = do { bless \(my $dummy = 1), Types::Serialiser::Boolean:: };
  our $false = do { bless \(my $dummy = 0), Types::Serialiser::Boolean:: };
  our $error = do { bless \(my $dummy    ), Types::Serialiser::Error::   };
  
  sub true  () { $true  }
  sub false () { $false }
  sub error () { $error }
  
  sub is_bool  ($) {           UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_true  ($) {  $_[0] && UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_false ($) { !$_[0] && UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_error ($) {           UNIVERSAL::isa $_[0], Types::Serialiser::Error::   }
  
  package Types::Serialiser::Error;
  
  sub error {
     require Carp;
     Carp::croak ("caught attempt to use the Types::Serialiser::error value");
  };
  
  use overload
     "0+"     => \&error,
     "++"     => \&error,
     "--"     => \&error,
     fallback => 1;
  
  =head1 NOTES FOR XS USERS
  
  The recommended way to detect whether a scalar is one of these objects
  is to check whether the stash is the C<Types::Serialiser::Boolean> or
  C<Types::Serialiser::Error> stash, and then follow the scalar reference to
  see if it's C<1> (true), C<0> (false) or C<undef> (error).
  
  While it is possible to use an isa test, directly comparing stash pointers
  is faster and guaranteed to work.
  
  For historical reasons, the C<Types::Serialiser::Boolean> stash is
  just an alias for C<JSON::PP::Boolean>. When printed, the classname
  with usually be C<JSON::PP::Boolean>, but isa tests and stash pointer
  comparison will normally work correctly (i.e. Types::Serialiser::true ISA
  JSON::PP::Boolean, but also ISA Types::Serialiser::Boolean).
  
  =head1 A GENERIC OBJECT SERIALIATION PROTOCOL
  
  This section explains the object serialisation protocol used by
  L<CBOR::XS>. It is meant to be generic enough to support any kind of
  generic object serialiser.
  
  This protocol is called "the Types::Serialiser object serialisation
  protocol".
  
  =head2 ENCODING
  
  When the encoder encounters an object that it cannot otherwise encode (for
  example, L<CBOR::XS> can encode a few special types itself, and will first
  attempt to use the special C<TO_CBOR> serialisation protocol), it will
  look up the C<FREEZE> method on the object.
  
  Note that the C<FREEZE> method will normally be called I<during> encoding,
  and I<MUST NOT> change the data structure that is being encoded in any
  way, or it might cause memory corruption or worse.
  
  If it exists, it will call it with two arguments: the object to serialise,
  and a constant string that indicates the name of the data model. For
  example L<CBOR::XS> uses C<CBOR>, and the L<JSON> and L<JSON::XS> modules
  (or any other JSON serialiser), would use C<JSON> as second argument.
  
  The C<FREEZE> method can then return zero or more values to identify the
  object instance. The serialiser is then supposed to encode the class name
  and all of these return values (which must be encodable in the format)
  using the relevant form for Perl objects. In CBOR for example, there is a
  registered tag number for encoded perl objects.
  
  The values that C<FREEZE> returns must be serialisable with the serialiser
  that calls it. Therefore, it is recommended to use simple types such as
  strings and numbers, and maybe array references and hashes (basically, the
  JSON data model). You can always use a more complex format for a specific
  data model by checking the second argument, the data model.
  
  The "data model" is not the same as the "data format" - the data model
  indicates what types and kinds of return values can be returned from
  C<FREEZE>. For example, in C<CBOR> it is permissible to return tagged CBOR
  values, while JSON does not support these at all, so C<JSON> would be a
  valid (but too limited) data model name for C<CBOR::XS>. similarly, a
  serialising format that supports more or less the same data model as JSON
  could use C<JSON> as data model without losing anything.
  
  =head2 DECODING
  
  When the decoder then encounters such an encoded perl object, it should
  look up the C<THAW> method on the stored classname, and invoke it with the
  classname, the constant string to identify the data model/data format, and
  all the return values returned by C<FREEZE>.
  
  =head2 EXAMPLES
  
  See the C<OBJECT SERIALISATION> section in the L<CBOR::XS> manpage for
  more details, an example implementation, and code examples.
  
  Here is an example C<FREEZE>/C<THAW> method pair:
  
     sub My::Object::FREEZE {
        my ($self, $model) = @_;
  
        ($self->{type}, $self->{id}, $self->{variant})
     }
  
     sub My::Object::THAW {
        my ($class, $model, $type, $id, $variant) = @_;
  
        $class->new (type => $type, id => $id, variant => $variant)
     }
  
  =head1 BUGS
  
  The use of L<overload> makes this module much heavier than it should be
  (on my system, this module: 4kB RSS, overload: 260kB RSS).
  
  =head1 SEE ALSO
  
  Currently, L<JSON::XS> and L<CBOR::XS> use these types.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
TYPES_SERIALISER

$fatpacked{"Types/Serialiser/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_SERIALISER_ERROR';
  =head1 NAME
  
  Types::Serialiser::Error - dummy module for Types::Serialiser
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and
  similar modules that assume that class name equals module name. See
  L<Types::Serialiser> for more info about this class.
  
  =cut
  
  use Types::Serialiser ();
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
TYPES_SERIALISER_ERROR

$fatpacked{"YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML';
  package YAML;
  our $VERSION = '1.13';
  
  use YAML::Mo;
  
  use Exporter;
  push @YAML::ISA, 'Exporter';
  our @EXPORT = qw{ Dump Load };
  our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
  
  use YAML::Node; # XXX This is a temp fix for Module::Build
  
  # XXX This VALUE nonsense needs to go.
  use constant VALUE => "\x07YAML\x07VALUE\x07";
  
  # YAML Object Properties
  has dumper_class => default => sub {'YAML::Dumper'};
  has loader_class => default => sub {'YAML::Loader'};
  has dumper_object => default => sub {$_[0]->init_action_object("dumper")};
  has loader_object => default => sub {$_[0]->init_action_object("loader")};
  
  sub Dump {
      my $yaml = YAML->new;
      $yaml->dumper_class($YAML::DumperClass)
          if $YAML::DumperClass;
      return $yaml->dumper_object->dump(@_);
  }
  
  sub Load {
      my $yaml = YAML->new;
      $yaml->loader_class($YAML::LoaderClass)
          if $YAML::LoaderClass;
      return $yaml->loader_object->load(@_);
  }
  
  {
      no warnings 'once';
      # freeze/thaw is the API for Storable string serialization. Some
      # modules make use of serializing packages on if they use freeze/thaw.
      *freeze = \ &Dump;
      *thaw   = \ &Load;
  }
  
  sub DumpFile {
      my $OUT;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $OUT = $filename;
      }
      else {
          my $mode = '>';
          if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
              ($mode, $filename) = ($1, $2);
          }
          open $OUT, $mode, $filename
            or YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, $!);
      }
      binmode $OUT, ':utf8';  # if $Config{useperlio} eq 'define';
      local $/ = "\n"; # reset special to "sane"
      print $OUT Dump(@_);
  }
  
  sub LoadFile {
      my $IN;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $IN = $filename;
      }
      else {
          open $IN, '<', $filename
            or YAML::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT', $filename, $!);
      }
      binmode $IN, ':utf8';  # if $Config{useperlio} eq 'define';
      return Load(do { local $/; <$IN> });
  }
  
  sub init_action_object {
      my $self = shift;
      my $object_class = (shift) . '_class';
      my $module_name = $self->$object_class;
      eval "require $module_name";
      $self->die("Error in require $module_name - $@")
          if $@ and "$@" !~ /Can't locate/;
      my $object = $self->$object_class->new;
      $object->set_global_options;
      return $object;
  }
  
  my $global = {};
  sub Bless {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::bless($global, @_)
  }
  sub Blessed {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::blessed($global, @_)
  }
  sub global_object { $global }
  
  1;
YAML

$fatpacked{"YAML/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ANY';
  use strict; use warnings;
  package YAML::Any;
  our $VERSION = '1.13';
  
  use Exporter ();
  
  @YAML::Any::ISA       = 'Exporter';
  @YAML::Any::EXPORT    = qw(Dump Load);
  @YAML::Any::EXPORT_OK = qw(DumpFile LoadFile);
  
  my @dump_options = qw(
      UseCode
      DumpCode
      SpecVersion
      Indent
      UseHeader
      UseVersion
      SortKeys
      AnchorPrefix
      UseBlock
      UseFold
      CompressSeries
      InlineSeries
      UseAliases
      Purity
      Stringify
  );
  
  my @load_options = qw(
      UseCode
      LoadCode
  );
  
  my @implementations = qw(
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  );
  
  sub import {
      __PACKAGE__->implementation;
      goto &Exporter::import;
  }
  
  sub Dump {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Dump"}(@_);
  }
  
  sub DumpFile {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::DumpFile"}(@_);
  }
  
  sub Load {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Load"}(@_);
  }
  
  sub LoadFile {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::LoadFile"}(@_);
  }
  
  sub order {
      return @YAML::Any::_TEST_ORDER
          if @YAML::Any::_TEST_ORDER;
      return @implementations;
  }
  
  sub implementation {
      my @order = __PACKAGE__->order;
      for my $module (@order) {
          my $path = $module;
          $path =~ s/::/\//g;
          $path .= '.pm';
          return $module if exists $INC{$path};
          eval "require $module; 1" and return $module;
      }
      croak("YAML::Any couldn't find any of these YAML implementations: @order");
  }
  
  sub croak {
      require Carp;
      Carp::croak(@_);
  }
  
  1;
YAML_ANY

$fatpacked{"YAML/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER';
  package YAML::Dumper;
  
  use YAML::Mo;
  extends 'YAML::Dumper::Base';
  
  use YAML::Dumper::Base;
  use YAML::Node;
  use YAML::Types;
  
  # Context constants
  use constant KEY       => 3;
  use constant BLESSED   => 4;
  use constant FROMARRAY => 5;
  use constant VALUE     => "\x07YAML\x07VALUE\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $LIT_CHAR    = '|';
  
  #==============================================================================
  # OO version of Dump. YAML->new->dump($foo);
  sub dump {
      my $self = shift;
      $self->stream('');
      $self->document(0);
      for my $document (@_) {
          $self->{document}++;
          $self->transferred({});
          $self->id_refcnt({});
          $self->id_anchor({});
          $self->anchor(1);
          $self->level(0);
          $self->offset->[0] = 0 - $self->indent_width;
          $self->_prewalk($document);
          $self->_emit_header($document);
          $self->_emit_node($document);
      }
      return $self->stream;
  }
  
  # Every YAML document in the stream must begin with a YAML header, unless
  # there is only a single document and the user requests "no header".
  sub _emit_header {
      my $self = shift;
      my ($node) = @_;
      if (not $self->use_header and
          $self->document == 1
         ) {
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            unless ref($node) =~ /^(HASH|ARRAY)$/;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'HASH' and keys(%$node) == 0;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'ARRAY' and @$node == 0;
          # XXX Also croak if aliased, blessed, or ynode
          $self->headless(1);
          return;
      }
      $self->{stream} .= '---';
  # XXX Consider switching to 1.1 style
      if ($self->use_version) {
  #         $self->{stream} .= " #YAML:1.0";
      }
  }
  
  # Walk the tree to be dumped and keep track of its reference counts.
  # This function is where the Dumper does all its work. All type
  # transfers happen here.
  sub _prewalk {
      my $self = shift;
      my $stringify = $self->stringify;
      my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
  
      # Handle typeglobs
      if ($type eq 'GLOB') {
          $self->transferred->{$node_id} =
            YAML::Type::glob->yaml_dump($_[0]);
          $self->_prewalk($self->transferred->{$node_id});
          return;
      }
  
      # Handle regexps
      if (ref($_[0]) eq 'Regexp') {
          return;
      }
  
      # Handle Purity for scalars.
      # XXX can't find a use case yet. Might be YAGNI.
      if (not ref $_[0]) {
          $self->{id_refcnt}{$node_id}++ if $self->purity;
          return;
      }
  
      # Make a copy of original
      my $value = $_[0];
      ($class, $type, $node_id) = $self->node_info($value, $stringify);
  
      # Must be a stringified object.
      return if (ref($value) and not $type);
  
      # Look for things already transferred.
      if ($self->transferred->{$node_id}) {
          (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
            ? $self->node_info($self->transferred->{$node_id}, $stringify)
            : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle code refs
      if ($type eq 'CODE') {
          $self->transferred->{$node_id} = 'placeholder';
          YAML::Type::code->yaml_dump(
              $self->dump_code,
              $_[0],
              $self->transferred->{$node_id}
          );
          ($class, $type, $node_id) =
            $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle blessed things
      if (defined $class) {
          if ($value->can('yaml_dump')) {
              $value = $value->yaml_dump;
          }
          elsif ($type eq 'SCALAR') {
              $self->transferred->{$node_id} = 'placeholder';
              YAML::Type::blessed->yaml_dump
                ($_[0], $self->transferred->{$node_id});
              ($class, $type, $node_id) =
                $self->node_info(\ $self->transferred->{$node_id}, $stringify);
              $self->{id_refcnt}{$node_id}++;
              return;
          }
          else {
              $value = YAML::Type::blessed->yaml_dump($value);
          }
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle YAML Blessed things
      require YAML;
      if (defined YAML->global_object()->{blessed_map}{$node_id}) {
          $value = YAML->global_object()->{blessed_map}{$node_id};
          $self->transferred->{$node_id} = $value;
          ($class, $type, $node_id) = $self->node_info($value, $stringify);
          $self->_prewalk($value);
          return;
      }
  
      # Handle hard refs
      if ($type eq 'REF' or $type eq 'SCALAR') {
          $value = YAML::Type::ref->yaml_dump($value);
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle ref-to-glob's
      elsif ($type eq 'GLOB') {
          my $ref_ynode = $self->transferred->{$node_id} =
            YAML::Type::ref->yaml_dump($value);
  
          my $glob_ynode = $ref_ynode->{&VALUE} =
            YAML::Type::glob->yaml_dump($$value);
  
          (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
          $self->transferred->{$node_id} = $glob_ynode;
          $self->_prewalk($glob_ynode);
          return;
      }
  
      # Increment ref count for node
      return if ++($self->{id_refcnt}{$node_id}) > 1;
  
      # Keep on walking
      if ($type eq 'HASH') {
          $self->_prewalk($value->{$_})
              for keys %{$value};
          return;
      }
      elsif ($type eq 'ARRAY') {
          $self->_prewalk($_)
              for @{$value};
          return;
      }
  
      # Unknown type. Need to know about it.
      $self->warn(<<"...");
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
  
      return;
  }
  
  # Every data element and sub data element is a node.
  # Everything emitted goes through this function.
  sub _emit_node {
      my $self = shift;
      my ($type, $node_id);
      my $ref = ref($_[0]);
      if ($ref) {
          if ($ref eq 'Regexp') {
              $self->_emit(' !!perl/regexp');
              $self->_emit_str("$_[0]");
              return;
          }
          (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
      }
      else {
          $type = $ref || 'SCALAR';
          (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
      }
  
      my ($ynode, $tag) = ('') x 2;
      my ($value, $context) = (@_, 0);
  
      if (defined $self->transferred->{$node_id}) {
          $value = $self->transferred->{$node_id};
          $ynode = ynode($value);
          if (ref $value) {
              $tag = defined $ynode ? $ynode->tag->short : '';
              (undef, $type, $node_id) =
                $self->node_info($value, $self->stringify);
          }
          else {
              $ynode = ynode($self->transferred->{$node_id});
              $tag = defined $ynode ? $ynode->tag->short : '';
              $type = 'SCALAR';
              (undef, undef, $node_id) =
                $self->node_info(
                    \ $self->transferred->{$node_id},
                    $self->stringify
                );
          }
      }
      elsif ($ynode = ynode($value)) {
          $tag = $ynode->tag->short;
      }
  
      if ($self->use_aliases) {
          $self->{id_refcnt}{$node_id} ||= 0;
          if ($self->{id_refcnt}{$node_id} > 1) {
              if (defined $self->{id_anchor}{$node_id}) {
                  $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
                  return;
              }
              my $anchor = $self->anchor_prefix . $self->{anchor}++;
              $self->{stream} .= ' &' . $anchor;
              $self->{id_anchor}{$node_id} = $anchor;
          }
      }
  
      return $self->_emit_str("$value")   # Stringified object
        if ref($value) and not $type;
      return $self->_emit_scalar($value, $tag)
        if $type eq 'SCALAR' and $tag;
      return $self->_emit_str($value)
        if $type eq 'SCALAR';
      return $self->_emit_mapping($value, $tag, $node_id, $context)
        if $type eq 'HASH';
      return $self->_emit_sequence($value, $tag)
        if $type eq 'ARRAY';
      $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
      return $self->_emit_str("$value");
  }
  
  # A YAML mapping is akin to a Perl hash.
  sub _emit_mapping {
      my $self = shift;
      my ($value, $tag, $node_id, $context) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      # Sometimes 'keys' fails. Like on a bad tie implementation.
      my $empty_hash = not(eval {keys %$value});
      $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
      return ($self->{stream} .= " {}\n") if $empty_hash;
  
      # If CompressSeries is on (default) and legal is this context, then
      # use it and make the indent level be 2 for this node.
      if ($context == FROMARRAY and
          $self->compress_series and
          not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
         ) {
          $self->{stream} .= ' ';
          $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
      }
      else {
          $context = 0;
          $self->{stream} .= "\n"
            unless $self->headless && not($self->headless(0));
          $self->offset->[$self->level+1] =
            $self->offset->[$self->level] + $self->indent_width;
      }
  
      $self->{level}++;
      my @keys;
      if ($self->sort_keys == 1) {
          if (ynode($value)) {
              @keys = keys %$value;
          }
          else {
              @keys = sort keys %$value;
          }
      }
      elsif ($self->sort_keys == 2) {
          @keys = sort keys %$value;
      }
      # XXX This is hackish but sometimes handy. Not sure whether to leave it in.
      elsif (ref($self->sort_keys) eq 'ARRAY') {
          my $i = 1;
          my %order = map { ($_, $i++) } @{$self->sort_keys};
          @keys = sort {
              (defined $order{$a} and defined $order{$b})
                ? ($order{$a} <=> $order{$b})
                : ($a cmp $b);
          } keys %$value;
      }
      else {
          @keys = keys %$value;
      }
      # Force the YAML::VALUE ('=') key to sort last.
      if (exists $value->{&VALUE}) {
          for (my $i = 0; $i < @keys; $i++) {
              if ($keys[$i] eq &VALUE) {
                  splice(@keys, $i, 1);
                  push @keys, &VALUE;
                  last;
              }
          }
      }
  
      for my $key (@keys) {
          $self->_emit_key($key, $context);
          $context = 0;
          $self->{stream} .= ':';
          $self->_emit_node($value->{$key});
      }
      $self->{level}--;
  }
  
  # A YAML series is akin to a Perl array.
  sub _emit_sequence {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      return ($self->{stream} .= " []\n") if @$value == 0;
  
      $self->{stream} .= "\n"
        unless $self->headless && not($self->headless(0));
  
      # XXX Really crufty feature. Better implemented by ynodes.
      if ($self->inline_series and
          @$value <= $self->inline_series and
          not (scalar grep {ref or /\n/} @$value)
         ) {
          $self->{stream} =~ s/\n\Z/ /;
          $self->{stream} .= '[';
          for (my $i = 0; $i < @$value; $i++) {
              $self->_emit_str($value->[$i], KEY);
              last if $i == $#{$value};
              $self->{stream} .= ', ';
          }
          $self->{stream} .= "]\n";
          return;
      }
  
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
      for my $val (@$value) {
          $self->{stream} .= ' ' x $self->offset->[$self->level];
          $self->{stream} .= '-';
          $self->_emit_node($val, FROMARRAY);
      }
      $self->{level}--;
  }
  
  # Emit a mapping key
  sub _emit_key {
      my $self = shift;
      my ($value, $context) = @_;
      $self->{stream} .= ' ' x $self->offset->[$self->level]
        unless $context == FROMARRAY;
      $self->_emit_str($value, KEY);
  }
  
  # Emit a blessed SCALAR
  sub _emit_scalar {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag";
      $self->_emit_str($value, BLESSED);
  }
  
  sub _emit {
      my $self = shift;
      $self->{stream} .= join '', @_;
  }
  
  # Emit a string value. YAML has many scalar styles. This routine attempts to
  # guess the best style for the text.
  sub _emit_str {
      my $self = shift;
      my $type = $_[1] || 0;
  
      # Use heuristics to find the best scalar emission style.
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
  
      my $sf = $type == KEY ? '' : ' ';
      my $sb = $type == KEY ? '? ' : ' ';
      my $ef = $type == KEY ? '' : "\n";
      my $eb = "\n";
  
      while (1) {
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if not defined $_[0];
          $self->_emit($sf, '=', $ef), last
            if $_[0] eq VALUE;
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /$ESCAPE_CHAR/;
          if ($_[0] =~ /\n/) {
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last
                if $self->use_block;
                Carp::cluck "[YAML] \$UseFold is no longer supported"
                if $self->use_fold;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if length $_[0] <= 30;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if $_[0] !~ /\n\s*\S/;
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last;
          }
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if $self->is_valid_plain($_[0]);
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /'/;
          $self->_emit($sf),
          $self->_emit_single($_[0]),
          $self->_emit($ef);
          last;
      }
  
      $self->{level}--;
  
      return;
  }
  
  # Check whether or not a scalar should be emitted as an plain scalar.
  sub is_valid_plain {
      my $self = shift;
      return 0 unless length $_[0];
      # refer to YAML::Loader::parse_inline_simple()
      return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
      return 0 if $_[0] =~ /[\{\[\]\},]/;
      return 0 if $_[0] =~ /[:\-\?]\s/;
      return 0 if $_[0] =~ /\s#/;
      return 0 if $_[0] =~ /\:(\s|$)/;
      return 0 if $_[0] =~ /[\s\|\>]$/;
      return 0 if $_[0] eq '-';
      return 1;
  }
  
  sub _emit_block {
      my $self = shift;
      my ($indicator, $value) = @_;
      $self->{stream} .= $indicator;
      $value =~ /(\n*)\Z/;
      my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
      $value = '~' if not defined $value;
      $self->{stream} .= $chomp;
      $self->{stream} .= $self->indent_width if $value =~ /^\s/;
      $self->{stream} .= $self->indent($value);
  }
  
  # Plain means that the scalar is unquoted.
  sub _emit_plain {
      my $self = shift;
      $self->{stream} .= defined $_[0] ? $_[0] : '~';
  }
  
  # Double quoting is for single lined escaped strings.
  sub _emit_double {
      my $self = shift;
      (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
      $self->{stream} .= qq{"$escaped"};
  }
  
  # Single quoting is for single lined unescaped strings.
  sub _emit_single {
      my $self = shift;
      my $item = shift;
      $item =~ s{'}{''}g;
      $self->{stream} .= "'$item'";
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Indent a scalar to the current indentation level.
  sub indent {
      my $self = shift;
      my ($text) = @_;
      return $text unless length $text;
      $text =~ s/\n\Z//;
      my $indent = ' ' x $self->offset->[$self->level];
      $text =~ s/^/$indent/gm;
      $text = "\n$text";
      return $text;
  }
  
  # Escapes for unprintable characters
  my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
                   \x08 \t   \n   \v   \f   \r   \x0e \x0f
                   \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
                   \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
                  );
  
  # Escape the unprintable characters
  sub escape {
      my $self = shift;
      my ($text) = @_;
      $text =~ s/\\/\\\\/g;
      $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
      return $text;
  }
  
  1;
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;
  
  use YAML::Mo;
  
  use YAML::Node;
  
  # YAML Dumping options
  has spec_version    => default => sub {'1.0'};
  has indent_width    => default => sub {2};
  has use_header      => default => sub {1};
  has use_version     => default => sub {0};
  has sort_keys       => default => sub {1};
  has anchor_prefix   => default => sub {''};
  has dump_code       => default => sub {0};
  has use_block       => default => sub {0};
  has use_fold        => default => sub {0};
  has compress_series => default => sub {1};
  has inline_series   => default => sub {0};
  has use_aliases     => default => sub {1};
  has purity          => default => sub {0};
  has stringify       => default => sub {0};
  
  # Properties
  has stream      => default => sub {''};
  has document    => default => sub {0};
  has transferred => default => sub {{}};
  has id_refcnt   => default => sub {{}};
  has id_anchor   => default => sub {{}};
  has anchor      => default => sub {1};
  has level       => default => sub {0};
  has offset      => default => sub {[]};
  has headless    => default => sub {0};
  has blessed_map => default => sub {{}};
  
  # Global Options are an idea taken from Data::Dumper. Really they are just
  # sugar on top of real OO properties. They make the simple Dump/Load API
  # easy to configure.
  sub set_global_options {
      my $self = shift;
      $self->spec_version($YAML::SpecVersion)
        if defined $YAML::SpecVersion;
      $self->indent_width($YAML::Indent)
        if defined $YAML::Indent;
      $self->use_header($YAML::UseHeader)
        if defined $YAML::UseHeader;
      $self->use_version($YAML::UseVersion)
        if defined $YAML::UseVersion;
      $self->sort_keys($YAML::SortKeys)
        if defined $YAML::SortKeys;
      $self->anchor_prefix($YAML::AnchorPrefix)
        if defined $YAML::AnchorPrefix;
      $self->dump_code($YAML::DumpCode || $YAML::UseCode)
        if defined $YAML::DumpCode or defined $YAML::UseCode;
      $self->use_block($YAML::UseBlock)
        if defined $YAML::UseBlock;
      $self->use_fold($YAML::UseFold)
        if defined $YAML::UseFold;
      $self->compress_series($YAML::CompressSeries)
        if defined $YAML::CompressSeries;
      $self->inline_series($YAML::InlineSeries)
        if defined $YAML::InlineSeries;
      $self->use_aliases($YAML::UseAliases)
        if defined $YAML::UseAliases;
      $self->purity($YAML::Purity)
        if defined $YAML::Purity;
      $self->stringify($YAML::Stringify)
        if defined $YAML::Stringify;
  }
  
  sub dump {
      my $self = shift;
      $self->die('dump() not implemented in this class.');
  }
  
  sub blessed {
      my $self = shift;
      my ($ref) = @_;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      $self->{blessed_map}->{$node_id};
  }
  
  sub bless {
      my $self = shift;
      my ($ref, $blessing) = @_;
      my $ynode;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      if (not defined $blessing) {
          $ynode = YAML::Node->new($ref);
      }
      elsif (ref $blessing) {
          $self->die() unless ynode($blessing);
          $ynode = $blessing;
      }
      else {
          no strict 'refs';
          my $transfer = $blessing . "::yaml_dump";
          $self->die() unless defined &{$transfer};
          $ynode = &{$transfer}($ref);
          $self->die() unless ynode($ynode);
      }
      $self->{blessed_map}->{$node_id} = $ynode;
      my $object = ynode($ynode) or $self->die();
      return $object;
  }
  
  1;
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ERROR';
  package YAML::Error;
  
  use YAML::Mo;
  
  has 'code';
  has 'type' => default => sub {'Error'};
  has 'line';
  has 'document';
  has 'arguments' => default => sub {[]};
  
  my ($error_messages, %line_adjust);
  
  sub format_message {
      my $self = shift;
      my $output = 'YAML ' . $self->type . ': ';
      my $code = $self->code;
      if ($error_messages->{$code}) {
          $code = sprintf($error_messages->{$code}, @{$self->arguments});
      }
      $output .= $code . "\n";
  
      $output .= '   Code: ' . $self->code . "\n"
          if defined $self->code;
      $output .= '   Line: ' . $self->line . "\n"
          if defined $self->line;
      $output .= '   Document: ' . $self->document . "\n"
          if defined $self->document;
      return $output;
  }
  
  sub error_messages {
      $error_messages;
  }
  
  %$error_messages = map {s/^\s+//;$_} split "\n", <<'...';
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_NO_FINAL_NEWLINE
    Stream does not end with newline character
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
  
  %line_adjust = map {($_, 1)}
    qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
       YAML_PARSE_WARN_BAD_MINOR_VERSION
       YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
       YAML_PARSE_ERR_NO_ANCHOR
       YAML_PARSE_ERR_MANY_EXPLICIT
       YAML_PARSE_ERR_MANY_IMPLICIT
       YAML_PARSE_ERR_MANY_ANCHOR
       YAML_PARSE_ERR_ANCHOR_ALIAS
       YAML_PARSE_ERR_BAD_ALIAS
       YAML_PARSE_ERR_MANY_ALIAS
       YAML_LOAD_ERR_NO_CONVERT
       YAML_LOAD_ERR_NO_DEFAULT_VALUE
       YAML_LOAD_ERR_NON_EMPTY_STRING
       YAML_LOAD_ERR_BAD_MAP_TO_SEQ
       YAML_LOAD_ERR_BAD_STR_TO_INT
       YAML_LOAD_ERR_BAD_STR_TO_DATE
       YAML_LOAD_ERR_BAD_STR_TO_TIME
       YAML_LOAD_WARN_DUPLICATE_KEY
       YAML_PARSE_ERR_INLINE_MAP
       YAML_PARSE_ERR_INLINE_SEQUENCE
       YAML_PARSE_ERR_BAD_DOUBLE
       YAML_PARSE_ERR_BAD_SINGLE
       YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
       YAML_PARSE_ERR_BAD_IMPLICIT
       YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
       YAML_LOAD_WARN_BAD_REGEXP_ELEM
       YAML_LOAD_WARN_REGEXP_CREATE
       YAML_LOAD_WARN_GLOB_NAME
       YAML_LOAD_WARN_PARSE_CODE
       YAML_LOAD_WARN_CODE_DEPARSE
       YAML_LOAD_WARN_BAD_GLOB_ELEM
       YAML_PARSE_ERR_ZERO_INDENT
      );
  
  package YAML::Warning;
  
  our @ISA = 'YAML::Error';
  
  1;
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER';
  package YAML::Loader;
  
  use YAML::Mo;
  extends 'YAML::Loader::Base';
  
  use YAML::Loader::Base;
  use YAML::Types;
  
  # Context constants
  use constant LEAF       => 1;
  use constant COLLECTION => 2;
  use constant VALUE      => "\x07YAML\x07VALUE\x07";
  use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $FOLD_CHAR   = '>';
  my $LIT_CHAR    = '|';
  my $LIT_CHAR_RX = "\\$LIT_CHAR";
  
  sub load {
      my $self = shift;
      $self->stream($_[0] || '');
      return $self->_parse();
  }
  
  # Top level function for parsing. Parse each document in order and
  # handle processing for YAML headers.
  sub _parse {
      my $self = shift;
      my (%directives, $preface);
      $self->{stream} =~ s|\015\012|\012|g;
      $self->{stream} =~ s|\015|\012|g;
      $self->line(0);
      $self->die('YAML_PARSE_ERR_BAD_CHARS')
        if $self->stream =~ /$ESCAPE_CHAR/;
      $self->die('YAML_PARSE_ERR_NO_FINAL_NEWLINE')
        if length($self->stream) and
           $self->{stream} !~ s/(.)\n\Z/$1/s;
      $self->lines([split /\x0a/, $self->stream, -1]);
      $self->line(1);
      # Throw away any comments or blanks before the header (or start of
      # content for headerless streams)
      $self->_parse_throwaway_comments();
      $self->document(0);
      $self->documents([]);
      # Add an "assumed" header if there is no header and the stream is
      # not empty (after initial throwaways).
      if (not $self->eos) {
          if ($self->lines->[0] !~ /^---(\s|$)/) {
              unshift @{$self->lines}, '---';
              $self->{line}--;
          }
      }
  
      # Main Loop. Parse out all the top level nodes and return them.
      while (not $self->eos) {
          $self->anchor2node({});
          $self->{document}++;
          $self->done(0);
          $self->level(0);
          $self->offset->[0] = -1;
  
          if ($self->lines->[0] =~ /^---\s*(.*)$/) {
              my @words = split /\s+/, $1;
              %directives = ();
              while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
                  my ($key, $value) = ($1, $2);
                  shift(@words);
                  if (defined $directives{$key}) {
                      $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
                        $key, $self->document);
                      next;
                  }
                  $directives{$key} = $value;
              }
              $self->preface(join ' ', @words);
          }
          else {
              $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
          }
  
          if (not $self->done) {
              $self->_parse_next_line(COLLECTION);
          }
          if ($self->done) {
              $self->{indent} = -1;
              $self->content('');
          }
  
          $directives{YAML} ||= '1.0';
          $directives{TAB} ||= 'NONE';
          ($self->{major_version}, $self->{minor_version}) =
            split /\./, $directives{YAML}, 2;
          $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
            if $self->major_version ne '1';
          $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
            if $self->minor_version ne '0';
          $self->die('Unrecognized TAB policy')
            unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
  
          push @{$self->documents}, $self->_parse_node();
      }
      return wantarray ? @{$self->documents} : $self->documents->[-1];
  }
  
  # This function is the dispatcher for parsing each node. Every node
  # recurses back through here. (Inlines are an exception as they have
  # their own sub-parser.)
  sub _parse_node {
      my $self = shift;
      my $preface = $self->preface;
      $self->preface('');
      my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
      my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $preface) =
        $self->_parse_qualifiers($preface);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $self->inline('');
      while (length $preface) {
          my $line = $self->line - 1;
          if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) {
              $indicator = $1;
              $chomp = $2 if defined($2);
          }
          else {
              $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
              $self->inline($preface);
              $preface = '';
          }
      }
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif (length $self->inline) {
          $node = $self->_parse_inline(1, $implicit, $explicit);
          if (length $self->inline) {
              $self->die('YAML_PARSE_ERR_SINGLE_LINE');
          }
      }
      elsif ($indicator eq $LIT_CHAR) {
          $self->{level}++;
          $node = $self->_parse_block($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      elsif ($indicator eq $FOLD_CHAR) {
          $self->{level}++;
          $node = $self->_parse_unfold($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      else {
          $self->{level}++;
          $self->offset->[$self->level] ||= 0;
          if ($self->indent == $self->offset->[$self->level]) {
              if ($self->content =~ /^-( |$)/) {
                  $node = $self->_parse_seq($anchor);
              }
              elsif ($self->content =~ /(^\?|\:( |$))/) {
                  $node = $self->_parse_mapping($anchor);
              }
              elsif ($preface =~ /^\s*$/) {
                  $node = $self->_parse_implicit('');
              }
              else {
                  $self->die('YAML_PARSE_ERR_BAD_NODE');
              }
          }
          else {
              $node = undef;
          }
          $self->{level}--;
      }
      $#{$self->offset} = $self->level;
  
      if ($explicit) {
          if ($class) {
              if (not ref $node) {
                  my $copy = $node;
                  undef $node;
                  $node = \$copy;
              }
              CORE::bless $node, $class;
          }
          else {
              $node = $self->_parse_explicit($node, $explicit);
          }
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              # XXX Can't remember what this code actually does
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Preprocess the qualifiers that may be attached to any node.
  sub _parse_qualifiers {
      my $self = shift;
      my ($preface) = @_;
      my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
      $self->inline('');
      while ($preface =~ /^[&*!]/) {
          my $line = $self->line - 1;
          if ($preface =~ s/^\!(\S+)\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
              $explicit = $1;
          }
          elsif ($preface =~ s/^\!\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
              $implicit = 1;
          }
          elsif ($preface =~ s/^\&([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ANCHOR')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
              $anchor = $token;
          }
          elsif ($preface =~ s/^\*([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ALIAS')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
              $alias = $token;
          }
      }
      return ($anchor, $alias, $explicit, $implicit, $preface);
  }
  
  # Morph a node to it's explicit type
  sub _parse_explicit {
      my $self = shift;
      my ($node, $explicit) = @_;
      my ($type, $class);
      if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
          ($type, $class) = (($1 || ''), ($2 || ''));
  
          # FIXME # die unless uc($type) eq ref($node) ?
  
          if ( $type eq "ref" ) {
              $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
              unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
  
              my $value = $node->{VALUE()};
              $node = \$value;
          }
  
          if ( $type eq "scalar" and length($class) and !ref($node) ) {
              my $value = $node;
              $node = \$value;
          }
  
          if ( length($class) ) {
              CORE::bless($node, $class);
          }
  
          return $node;
      }
      if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
          ($type, $class) = (($1 || ''), ($2 || ''));
          my $type_class = "YAML::Type::$type";
          no strict 'refs';
          if ($type_class->can('yaml_load')) {
              return $type_class->yaml_load($node, $class, $self);
          }
          else {
              $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
          }
      }
      # This !perl/@Foo and !perl/$Foo are deprecated but still parsed
      elsif ($YAML::TagClass->{$explicit} ||
             $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
            ) {
          $class = $YAML::TagClass->{$explicit} || $2;
          if ($class->can('yaml_load')) {
              require YAML::Node;
              return $class->yaml_load(YAML::Node->new($node, $explicit));
          }
          else {
              if (ref $node) {
                  return CORE::bless $node, $class;
              }
              else {
                  return CORE::bless \$node, $class;
              }
          }
      }
      elsif (ref $node) {
          require YAML::Node;
          return YAML::Node->new($node, $explicit);
      }
      else {
          # XXX This is likely wrong. Failing test:
          # --- !unknown 'scalar value'
          return $node;
      }
  }
  
  # Parse a YAML mapping into a Perl hash
  sub _parse_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $mapping = {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          # If structured key:
          if ($self->{content} =~ s/^\?\s*//) {
              $self->preface($self->content);
              $self->_parse_next_line(COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
          # If "default" key (equals sign)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = VALUE;
          }
          # If "comment" key (slash slash)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = COMMENT;
          }
          # Regular scalar key:
          else {
              $self->inline($self->content);
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content($self->inline);
              $self->inline('');
          }
  
          unless ($self->{content} =~ s/^:\s*//) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface($self->content);
          my $line = $self->line;
          $self->_parse_next_line(COLLECTION);
          my $value = $self->_parse_node();
          if (exists $mapping->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $mapping->{$key} = $value;
          }
      }
      return $mapping;
  }
  
  # Parse a YAML sequence into a Perl array
  sub _parse_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $seq = [];
      $self->anchor2node->{$anchor} = $seq;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          if ($self->content =~ /^-(?: (.*))?$/) {
              $self->preface(defined($1) ? $1 : '');
          }
          else {
              $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
          }
          if ($self->preface =~ /^(\s*)(\w.*\:(?: |$).*)$/) {
              $self->indent($self->offset->[$self->level] + 2 + length($1));
              $self->content($2);
              $self->level($self->level + 1);
              $self->offset->[$self->level] = $self->indent;
              $self->preface('');
              push @$seq, $self->_parse_mapping('');
              $self->{level}--;
              $#{$self->offset} = $self->level;
          }
          else {
              $self->_parse_next_line(COLLECTION);
              push @$seq, $self->_parse_node();
          }
      }
      return $seq;
  }
  
  # Parse an inline value. Since YAML supports inline collections, this is
  # the top level of a sub parsing.
  sub _parse_inline {
      my $self = shift;
      my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
      $self->{inline} =~ s/^\s*(.*)\s*$/$1/; # OUCH - mugwump
      my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $self->{inline}) =
        $self->_parse_qualifiers($self->inline);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $implicit ||= $top_implicit;
      $explicit ||= $top_explicit;
      ($top_implicit, $top_explicit) = ('', '');
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif ($self->inline =~ /^\{/) {
          $node = $self->_parse_inline_mapping($anchor);
      }
      elsif ($self->inline =~ /^\[/) {
          $node = $self->_parse_inline_seq($anchor);
      }
      elsif ($self->inline =~ /^"/) {
          $node = $self->_parse_inline_double_quoted();
          $node = $self->_unescape($node);
          $node = $self->_parse_implicit($node) if $implicit;
      }
      elsif ($self->inline =~ /^'/) {
          $node = $self->_parse_inline_single_quoted();
          $node = $self->_parse_implicit($node) if $implicit;
      }
      else {
          if ($top) {
              $node = $self->inline;
              $self->inline('');
          }
          else {
              $node = $self->_parse_inline_simple();
          }
          $node = $self->_parse_implicit($node) unless $explicit;
      }
      if ($explicit) {
          $node = $self->_parse_explicit($node, $explicit);
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Parse the inline YAML mapping into a Perl hash
  sub _parse_inline_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $node = {};
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
        unless $self->{inline} =~ s/^\{\s*//;
      while (not $self->{inline} =~ s/^\s*\}//) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if (exists $node->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $node->{$key} = $value;
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline YAML sequence into a Perl array
  sub _parse_inline_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $node = [];
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
        unless $self->{inline} =~ s/^\[\s*//;
      while (not $self->{inline} =~ s/^\s*\]//) {
          my $value = $self->_parse_inline();
          push @$node, $value;
          next if $self->inline =~ /^\s*\]/;
          $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline double quoted string.
  sub _parse_inline_double_quoted {
      my $self = shift;
      my $node;
      # https://rt.cpan.org/Public/Bug/Display.html?id=90593
      if ($self->inline =~ /^"((?:(?:\\"|[^"]){0,32766}){0,32766})"\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/\\"/"/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
      }
      return $node;
  }
  
  
  # Parse the inline single quoted string.
  sub _parse_inline_single_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^'((?:(?:''|[^']){0,32766}){0,32766})'\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/''/'/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_SINGLE');
      }
      return $node;
  }
  
  # Parse the inline unquoted string and do implicit typing.
  sub _parse_inline_simple {
      my $self = shift;
      my $value;
      if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
          $value = $1;
          substr($self->{inline}, 0, length($1)) = '';
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
      }
      return $value;
  }
  
  sub _parse_implicit {
      my $self = shift;
      my ($value) = @_;
      $value =~ s/\s*$//;
      return $value if $value eq '';
      return undef if $value =~ /^~$/;
      return $value
        unless $value =~ /^[\@\`]/ or
               $value =~ /^[\-\?]\s/;
      $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
  }
  
  # Unfold a YAML multiline scalar into a single string.
  sub _parse_unfold {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      my $space = 0;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content. "\n";
          $self->_parse_next_line(LEAF);
      }
      $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
      $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
      $node =~ s/\n*\Z// unless $chomp eq '+';
      $node .= "\n" unless $chomp;
      return $node;
  }
  
  # Parse a YAML block style scalar. This is like a Perl here-document.
  sub _parse_block {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content . "\n";
          $self->_parse_next_line(LEAF);
      }
      return $node if '+' eq $chomp;
      $node =~ s/\n*\Z/\n/;
      $node =~ s/\n\Z// if $chomp eq '-';
      return $node;
  }
  
  # Handle Perl style '#' comments. Comments must be at the same indentation
  # level as the collection line following them.
  sub _parse_throwaway_comments {
      my $self = shift;
      while (@{$self->lines} and
             $self->lines->[0] =~ m{^\s*(\#|$)}
            ) {
          shift @{$self->lines};
          $self->{line}++;
      }
      $self->eos($self->{done} = not @{$self->lines});
  }
  
  # This is the routine that controls what line is being parsed. It gets called
  # once for each line in the YAML stream.
  #
  # This routine must:
  # 1) Skip past the current line
  # 2) Determine the indentation offset for a new level
  # 3) Find the next _content_ line
  #   A) Skip over any throwaways (Comments/blanks)
  #   B) Set $self->indent, $self->content, $self->line
  # 4) Expand tabs appropriately
  sub _parse_next_line {
      my $self = shift;
      my ($type) = @_;
      my $level = $self->level;
      my $offset = $self->offset->[$level];
      $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
      shift @{$self->lines};
      $self->eos($self->{done} = not @{$self->lines});
      return if $self->eos;
      $self->{line}++;
  
      # Determine the offset for a new leaf node
      if ($self->preface =~
          qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
         ) {
          $self->die('YAML_PARSE_ERR_ZERO_INDENT')
            if length($1) and $1 == 0;
          $type = LEAF;
          if (length($1)) {
              $self->offset->[$level + 1] = $offset + $1;
          }
          else {
              # First get rid of any comments.
              while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
                  $self->lines->[0] =~ /^( *)/;
                  last unless length($1) <= $offset;
                  shift @{$self->lines};
                  $self->{line}++;
              }
              $self->eos($self->{done} = not @{$self->lines});
              return if $self->eos;
              if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
      # Determine the offset for a new collection level
      elsif ($type == COLLECTION and
             $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
          $self->_parse_throwaway_comments();
          if ($self->eos) {
              $self->offset->[$level+1] = $offset + 1;
              return;
          }
          else {
              $self->lines->[0] =~ /^( *)\S/ or
                  $self->die('YAML_PARSE_ERR_NONSPACE_INDENTATION');
              if (length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
  
      if ($type == LEAF) {
          while (@{$self->lines} and
                 $self->lines->[0] =~ m{^( *)(\#)} and
                 length($1) < $offset
                ) {
              shift @{$self->lines};
              $self->{line}++;
          }
          $self->eos($self->{done} = not @{$self->lines});
      }
      else {
          $self->_parse_throwaway_comments();
      }
      return if $self->eos;
  
      if ($self->lines->[0] =~ /^---(\s|$)/) {
          $self->done(1);
          return;
      }
      if ($type == LEAF and
          $self->lines->[0] =~ /^ {$offset}(.*)$/
         ) {
          $self->indent($offset);
          $self->content($1);
      }
      elsif ($self->lines->[0] =~ /^\s*$/) {
          $self->indent($offset);
          $self->content('');
      }
      else {
          $self->lines->[0] =~ /^( *)(\S.*)$/;
          while ($self->offset->[$level] > length($1)) {
              $level--;
          }
          $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION')
            if $self->offset->[$level] != length($1);
          $self->indent(length($1));
          $self->content($2);
      }
      $self->die('YAML_PARSE_ERR_INDENTATION')
        if $self->indent - $offset > 1;
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Printable characters for escapes
  my %unescapes = (
     0 => "\x00",
     a => "\x07",
     t => "\x09",
     n => "\x0a",
     'v' => "\x0b", # Potential v-string error on 5.6.2 if not quoted
     f => "\x0c",
     r => "\x0d",
     e => "\x1b",
     '\\' => '\\',
    );
  
  # Transform all the backslash style escape characters to their literal meaning
  sub _unescape {
      my $self = shift;
      my ($node) = @_;
      $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
      return $node;
  }
  
  1;
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER_BASE';
  package YAML::Loader::Base;
  
  use YAML::Mo;
  
  has load_code     => default => sub {0};
  has stream        => default => sub {''};
  has document      => default => sub {0};
  has line          => default => sub {0};
  has documents     => default => sub {[]};
  has lines         => default => sub {[]};
  has eos           => default => sub {0};
  has done          => default => sub {0};
  has anchor2node   => default => sub {{}};
  has level         => default => sub {0};
  has offset        => default => sub {[]};
  has preface       => default => sub {''};
  has content       => default => sub {''};
  has indent        => default => sub {0};
  has major_version => default => sub {0};
  has minor_version => default => sub {0};
  has inline        => default => sub {''};
  
  sub set_global_options {
      my $self = shift;
      $self->load_code($YAML::LoadCode || $YAML::UseCode)
        if defined $YAML::LoadCode or defined $YAML::UseCode;
  }
  
  sub load {
      die 'load() not implemented in this class.';
  }
  
  1;
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MARSHALL';
  use strict; use warnings;
  package YAML::Marshall;
  
  use YAML::Node ();
  
  sub import {
      my $class = shift;
      no strict 'refs';
      my $package = caller;
      unless (grep { $_ eq $class} @{$package . '::ISA'}) {
          push @{$package . '::ISA'}, $class;
      }
  
      my $tag = shift;
      if ( $tag ) {
          no warnings 'once';
          $YAML::TagClass->{$tag} = $package;
          ${$package . "::YamlTag"} = $tag;
      }
  }
  
  sub yaml_dump {
      my $self = shift;
      no strict 'refs';
      my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
      $self->yaml_node($self, $tag);
  }
  
  sub yaml_load {
      my ($class, $node) = @_;
      if (my $ynode = $class->yaml_ynode($node)) {
          $node = $ynode->{NODE};
      }
      bless $node, $class;
  }
  
  sub yaml_node {
      shift;
      YAML::Node->new(@_);
  }
  
  sub yaml_ynode {
      shift;
      YAML::Node::ynode(@_);
  }
  
  1;
YAML_MARSHALL

$fatpacked{"YAML/Mo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MO';
  package YAML::Mo; $VERSION = '0.88';
  # use Mo qw[builder default import];
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version 0.31
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{bless{@_[1..$#_]},$_[0]};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;$a{default}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$a{default}->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not $_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;
  
  our $DumperModule = 'Data::Dumper';
  
  my ($_new_error, $_info, $_scalar_info);
  
  no strict 'refs';
  *{$M.'Object::die'} = sub {
      my $self = shift;
      my $error = $self->$_new_error(@_);
      $error->type('Error');
      Carp::croak($error->format_message);
  };
  
  *{$M.'Object::warn'} = sub {
      my $self = shift;
      return unless $^W;
      my $error = $self->$_new_error(@_);
      $error->type('Warning');
      Carp::cluck($error->format_message);
  };
  
  # This code needs to be refactored to be simpler and more precise, and no,
  # Scalar::Util doesn't DWIM.
  #
  # Can't handle:
  # * blessed regexp
  *{$M.'Object::node_info'} = sub {
      my $self = shift;
      my $stringify = $_[1] || 0;
      my ($class, $type, $id) =
          ref($_[0])
          ? $stringify
            ? &$_info("$_[0]")
            : do {
                require overload;
                my @info = &$_info(overload::StrVal($_[0]));
                if (ref($_[0]) eq 'Regexp') {
                    @info[0, 1] = (undef, 'REGEXP');
                }
                @info;
            }
          : &$_scalar_info($_[0]);
      ($class, $type, $id) = &$_scalar_info("$_[0]")
          unless $id;
      return wantarray ? ($class, $type, $id) : $id;
  };
  
  #-------------------------------------------------------------------------------
  $_info = sub {
      return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
  };
  
  $_scalar_info = sub {
      my $id = 'undef';
      if (defined $_[0]) {
          \$_[0] =~ /\((\w+)\)$/o or CORE::die();
          $id = "$1-S";
      }
      return (undef, undef, $id);
  };
  
  $_new_error = sub {
      require Carp;
      my $self = shift;
      require YAML::Error;
  
      my $code = shift || 'unknown error';
      my $error = YAML::Error->new(code => $code);
      $error->line($self->line) if $self->can('line');
      $error->document($self->document) if $self->can('document');
      $error->arguments([@_]);
      return $error;
  };
  
  1;
YAML_MO

$fatpacked{"YAML/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_NODE';
  use strict; use warnings;
  package YAML::Node;
  
  use YAML::Tag;
  require YAML::Mo;
  
  use Exporter;
  our @ISA     = qw(Exporter YAML::Mo::Object);
  our @EXPORT  = qw(ynode);
  
  sub ynode {
      my $self;
      if (ref($_[0]) eq 'HASH') {
          $self = tied(%{$_[0]});
      }
      elsif (ref($_[0]) eq 'ARRAY') {
          $self = tied(@{$_[0]});
      }
      elsif (ref(\$_[0]) eq 'GLOB') {
          $self = tied(*{$_[0]});
      }
      else {
          $self = tied($_[0]);
      }
      return (ref($self) =~ /^yaml_/) ? $self : undef;
  }
  
  sub new {
      my ($class, $node, $tag) = @_;
      my $self;
      $self->{NODE} = $node;
      my (undef, $type) = YAML::Mo::Object->node_info($node);
      $self->{KIND} = (not defined $type) ? 'scalar' :
                      ($type eq 'ARRAY') ? 'sequence' :
                      ($type eq 'HASH') ? 'mapping' :
                      $class->die("Can't create YAML::Node from '$type'");
      tag($self, ($tag || ''));
      if ($self->{KIND} eq 'scalar') {
          yaml_scalar->new($self, $_[1]);
          return \ $_[1];
      }
      my $package = "yaml_" . $self->{KIND};
      $package->new($self)
  }
  
  sub node { $_->{NODE} }
  sub kind { $_->{KIND} }
  sub tag {
      my ($self, $value) = @_;
      if (defined $value) {
                 $self->{TAG} = YAML::Tag->new($value);
          return $self;
      }
      else {
         return $self->{TAG};
      }
  }
  sub keys {
      my ($self, $value) = @_;
      if (defined $value) {
                 $self->{KEYS} = $value;
          return $self;
      }
      else {
         return $self->{KEYS};
      }
  }
  
  #==============================================================================
  package yaml_scalar;
  
  @yaml_scalar::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      tie $_[2], $class, $self;
  }
  
  sub TIESCALAR {
      my ($class, $self) = @_;
      bless $self, $class;
      $self
  }
  
  sub FETCH {
      my ($self) = @_;
      $self->{NODE}
  }
  
  sub STORE {
      my ($self, $value) = @_;
      $self->{NODE} = $value
  }
  
  #==============================================================================
  package yaml_sequence;
  
  @yaml_sequence::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      my $new;
      tie @$new, $class, $self;
      $new
  }
  
  sub TIEARRAY {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCHSIZE {
      my ($self) = @_;
      scalar @{$self->{NODE}};
  }
  
  sub FETCH {
      my ($self, $index) = @_;
      $self->{NODE}[$index]
  }
  
  sub STORE {
      my ($self, $index, $value) = @_;
      $self->{NODE}[$index] = $value
  }
  
  sub undone {
      die "Not implemented yet"; # XXX
  }
  
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *undone; # XXX Must implement before release
  
  #==============================================================================
  package yaml_mapping;
  
  @yaml_mapping::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      @{$self->{KEYS}} = sort keys %{$self->{NODE}};
      my $new;
      tie %$new, $class, $self;
      $new
  }
  
  sub TIEHASH {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCH {
      my ($self, $key) = @_;
      if (exists $self->{NODE}{$key}) {
          return (grep {$_ eq $key} @{$self->{KEYS}})
                 ? $self->{NODE}{$key} : undef;
      }
      return $self->{HASH}{$key};
  }
  
  sub STORE {
      my ($self, $key, $value) = @_;
      if (exists $self->{NODE}{$key}) {
          $self->{NODE}{$key} = $value;
      }
      elsif (exists $self->{HASH}{$key}) {
          $self->{HASH}{$key} = $value;
      }
      else {
          if (not grep {$_ eq $key} @{$self->{KEYS}}) {
              push(@{$self->{KEYS}}, $key);
          }
          $self->{HASH}{$key} = $value;
      }
      $value
  }
  
  sub DELETE {
      my ($self, $key) = @_;
      my $return;
      if (exists $self->{NODE}{$key}) {
          $return = $self->{NODE}{$key};
      }
      elsif (exists $self->{HASH}{$key}) {
          $return = delete $self->{NODE}{$key};
      }
      for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
          if ($self->{KEYS}[$i] eq $key) {
              splice(@{$self->{KEYS}}, $i, 1);
          }
      }
      return $return;
  }
  
  sub CLEAR {
      my ($self) = @_;
      @{$self->{KEYS}} = ();
      %{$self->{HASH}} = ();
  }
  
  sub FIRSTKEY {
      my ($self) = @_;
      $self->{ITER} = 0;
      $self->{KEYS}[0]
  }
  
  sub NEXTKEY {
      my ($self) = @_;
      $self->{KEYS}[++$self->{ITER}]
  }
  
  sub EXISTS {
      my ($self, $key) = @_;
      exists $self->{NODE}{$key}
  }
  
  1;
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TAG';
  use strict; use warnings;
  package YAML::Tag;
  
  use overload '""' => sub { ${$_[0]} };
  
  sub new {
      my ($class, $self) = @_;
      bless \$self, $class
  }
  
  sub short {
      ${$_[0]}
  }
  
  sub canonical {
      ${$_[0]}
  }
  
  1;
YAML_TAG

$fatpacked{"YAML/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TYPES';
  package YAML::Types;
  
  use YAML::Mo;
  use YAML::Node;
  
  # XXX These classes and their APIs could still use some refactoring,
  # but at least they work for now.
  #-------------------------------------------------------------------------------
  package YAML::Type::blessed;
  
  use YAML::Mo; # XXX
  
  sub yaml_dump {
      my $self = shift;
      my ($value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      no strict 'refs';
      my $kind = lc($type) . ':';
      my $tag = ${$class . '::ClassTag'} ||
                "!perl/$kind$class";
      if ($type eq 'REF') {
          YAML::Node->new(
              {(&YAML::VALUE, ${$_[0]})}, $tag
          );
      }
      elsif ($type eq 'SCALAR') {
          $_[1] = $$value;
          YAML::Node->new($_[1], $tag);
      }
      elsif ($type eq 'GLOB') {
          # blessed glob support is minimal, and will not round-trip
          # initial aim: to not cause an error
          return YAML::Type::glob->yaml_dump($value, $tag);
      } else {
          YAML::Node->new($value, $tag);
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::undef;
  
  sub yaml_dump {
      my $self = shift;
  }
  
  sub yaml_load {
      my $self = shift;
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::glob;
  
  sub yaml_dump {
      my $self = shift;
      # $_[0] remains as the glob
      my $tag = pop @_ if 2==@_;
  
      $tag = '!perl/glob:' unless defined $tag;
      my $ynode = YAML::Node->new({}, $tag);
      for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
          my $value = *{$_[0]}{$type};
          $value = $$value if $type eq 'SCALAR';
          if (defined $value) {
              if ($type eq 'IO') {
                  my @stats = qw(device inode mode links uid gid rdev size
                                 atime mtime ctime blksize blocks);
                  undef $value;
                  $value->{stat} = YAML::Node->new({});
                  if ($value->{fileno} = fileno(*{$_[0]})) {
                      local $^W;
                      map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
                      $value->{tell} = tell(*{$_[0]});
                  }
              }
              $ynode->{$type} = $value;
          }
      }
      return $ynode;
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      my ($name, $package);
      if (defined $node->{NAME}) {
          $name = $node->{NAME};
          delete $node->{NAME};
      }
      else {
          $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
          return undef;
      }
      if (defined $node->{PACKAGE}) {
          $package = $node->{PACKAGE};
          delete $node->{PACKAGE};
      }
      else {
          $package = 'main';
      }
      no strict 'refs';
      if (exists $node->{SCALAR}) {
          *{"${package}::$name"} = \$node->{SCALAR};
          delete $node->{SCALAR};
      }
      for my $elem (qw(ARRAY HASH CODE IO)) {
          if (exists $node->{$elem}) {
              if ($elem eq 'IO') {
                  $loader->warn('YAML_LOAD_WARN_GLOB_IO');
                  delete $node->{IO};
                  next;
              }
              *{"${package}::$name"} = $node->{$elem};
              delete $node->{$elem};
          }
      }
      for my $elem (sort keys %$node) {
          $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
      }
      return *{"${package}::$name"};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::code;
  
  my $dummy_warned = 0;
  my $default = '{ "DUMMY" }';
  
  sub yaml_dump {
      my $self = shift;
      my $code;
      my ($dumpflag, $value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      my $tag = "!perl/code";
      $tag .= ":$class" if defined $class;
      if (not $dumpflag) {
          $code = $default;
      }
      else {
          bless $value, "CODE" if $class;
          eval { use B::Deparse };
          return if $@;
          my $deparse = B::Deparse->new();
          eval {
              local $^W = 0;
              $code = $deparse->coderef2text($value);
          };
          if ($@) {
              warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
              $code = $default;
          }
          bless $value, $class if $class;
          chomp $code;
          $code .= "\n";
      }
      $_[2] = $code;
      YAML::Node->new($_[2], $tag);
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      if ($loader->load_code) {
          my $code = eval "package main; sub $node";
          if ($@) {
              $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
              return sub {};
          }
          else {
              CORE::bless $code, $class if $class;
              return $code;
          }
      }
      else {
          return CORE::bless sub {}, $class if $class;
          return sub {};
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::ref;
  
  sub yaml_dump {
      my $self = shift;
      YAML::Node->new({(&YAML::VALUE, ${$_[0]})}, '!perl/ref')
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
        unless exists $node->{&YAML::VALUE};
      return \$node->{&YAML::VALUE};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::regexp;
  
  # XXX Be sure to handle blessed regexps (if possible)
  sub yaml_dump {
      die "YAML::Type::regexp::yaml_dump not currently implemented";
  }
  
  use constant _QR_TYPES => {
      '' => sub { qr{$_[0]} },
      x => sub { qr{$_[0]}x },
      i => sub { qr{$_[0]}i },
      s => sub { qr{$_[0]}s },
      m => sub { qr{$_[0]}m },
      ix => sub { qr{$_[0]}ix },
      sx => sub { qr{$_[0]}sx },
      mx => sub { qr{$_[0]}mx },
      si => sub { qr{$_[0]}si },
      mi => sub { qr{$_[0]}mi },
      ms => sub { qr{$_[0]}sm },
      six => sub { qr{$_[0]}six },
      mix => sub { qr{$_[0]}mix },
      msx => sub { qr{$_[0]}msx },
      msi => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class) = @_;
      return qr{$node} unless $node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;
      my ($flags, $re) = ($1, $2);
      $flags =~ s/-.*//;
      $flags =~ s/^\^//;
      my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
      my $qr = &$sub($re);
      bless $qr, $class if length $class;
      return $qr;
  }
  
  1;
YAML_TYPES

$fatpacked{"ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OK';
  package ok;
  our $VERSION = '1.302120';
  
  use strict;
  use Test::More ();
  
  sub import {
      shift;
  
      if (@_) {
          goto &Test::More::pass if $_[0] eq 'ok';
          goto &Test::More::use_ok;
      }
  
      # No argument list - croak as if we are prototyped like use_ok()
      my (undef, $file, $line) = caller();
      ($file =~ /^\(eval/) or die "Not enough arguments for 'use ok' at $file line $line\n";
  }
  
  
  __END__
  
  =encoding UTF-8
  
  =head1 NAME
  
  ok - Alternative to Test::More::use_ok
  
  =head1 SYNOPSIS
  
      use ok 'Some::Module';
  
  =head1 DESCRIPTION
  
  With this module, simply change all C<use_ok> in test scripts to C<use ok>,
  and they will be executed at C<BEGIN> time.
  
  Please see L<Test::use::ok> for the full description.
  
  =head1 CC0 1.0 Universal
  
  To the extent possible under law,  has waived all copyright and related
  or neighboring rights to L<Test-use-ok>.
  
  This work is published from Taiwan.
  
  L<http://creativecommons.org/publicdomain/zero/1.0>
  
  =cut
OK

$fatpacked{"x86_64-linux/JSON/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_JSON_XS';
  =head1 NAME
  
  JSON::XS - JSON serialising/deserialising, done correctly and fast
  
  =encoding utf-8
  
  JSON::XS -  JSON /
             (http://fleur.hio.jp/perldoc/mix/lib/JSON/XS.html)
  
  =head1 SYNOPSIS
  
   use JSON::XS;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = JSON::XS->new->ascii->pretty->allow_nonref;
   $pretty_printed_unencoded = $coder->encode ($perl_scalar);
   $perl_scalar = $coder->decode ($unicode_json_text);
  
   # Note that JSON version 2.0 and above will automatically use JSON::XS
   # if available, at virtually no speed overhead either, so you should
   # be able to just:
   
   use JSON;
  
   # and do the same things, except that you have a pure-perl fallback now.
  
  =head1 DESCRIPTION
  
  This module converts Perl data structures to JSON and vice versa. Its
  primary goal is to be I<correct> and its secondary goal is to be
  I<fast>. To reach the latter goal it was written in C.
  
  Beginning with version 2.0 of the JSON module, when both JSON and
  JSON::XS are installed, then JSON will fall back on JSON::XS (this can be
  overridden) with no overhead due to emulation (by inheriting constructor
  and methods). If JSON::XS is not available, it will fall back to the
  compatible JSON::PP module as backend, so using JSON instead of JSON::XS
  gives you a portable JSON API that can be fast when you need and doesn't
  require a C compiler when that is a problem.
  
  As this is the n-th-something JSON module on CPAN, what was the reason
  to write yet another JSON module? While it seems there are many JSON
  modules, none of them correctly handle all corner cases, and in most cases
  their maintainers are unresponsive, gone missing, or not listening to bug
  reports for other reasons.
  
  See MAPPING, below, on how JSON::XS maps perl values to JSON values and
  vice versa.
  
  =head2 FEATURES
  
  =over 4
  
  =item * correct Unicode handling
  
  This module knows how to handle Unicode, documents how and when it does
  so, and even documents what "correct" means.
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  MAPPING section below to learn about those.
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security
  feature).
  
  =item * fast
  
  Compared to other JSON modules and other serialisers such as Storable,
  this module usually compares favourably in terms of speed, too.
  
  =item * simple to use
  
  This module has both a simple functional interface as well as an object
  oriented interface.
  
  =item * reasonably versatile output formats
  
  You can choose between the most compact guaranteed-single-line format
  possible (nice for simple line-based protocols), a pure-ASCII format
  (for when your transport is not 8-bit clean, still supports the whole
  Unicode range), or a pretty-printed format (for when you want to read that
  stuff). Or you can combine those features in whatever way you like.
  
  =back
  
  =cut
  
  package JSON::XS;
  
  use common::sense;
  
  our $VERSION = 3.01;
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(encode_json decode_json);
  
  use Exporter;
  use XSLoader;
  
  use Types::Serialiser ();
  
  =head1 FUNCTIONAL INTERFACE
  
  The following convenience methods are provided by this module. They are
  exported by default:
  
  =over 4
  
  =item $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
     $json_text = JSON::XS->new->utf8->encode ($perl_scalar)
  
  Except being faster.
  
  =item $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
     $perl_scalar = JSON::XS->new->utf8->decode ($json_text)
  
  Except being faster.
  
  =back
  
  
  =head1 A FEW NOTES ON UNICODE AND PERL
  
  Since this often leads to confusion, here are a few very clear words on
  how Unicode works in Perl, modulo bugs.
  
  =over 4
  
  =item 1. Perl strings can store characters with ordinal values > 255.
  
  This enables you to store Unicode characters as single characters in a
  Perl string - very natural.
  
  =item 2. Perl does I<not> associate an encoding with your strings.
  
  ... until you force it to, e.g. when matching it against a regex, or
  printing the scalar to a file, in which case Perl either interprets your
  string as locale-encoded text, octets/binary, or as Unicode, depending
  on various settings. In no case is an encoding stored together with your
  data, it is I<use> that decides encoding, not any magical meta data.
  
  =item 3. The internal utf-8 flag has no meaning with regards to the
  encoding of your string.
  
  Just ignore that flag unless you debug a Perl bug, a module written in
  XS or want to dive into the internals of perl. Otherwise it will only
  confuse you, as, despite the name, it says nothing about how your string
  is encoded. You can have Unicode strings with that flag set, with that
  flag clear, and you can have binary data with that flag set and that flag
  clear. Other possibilities exist, too.
  
  If you didn't know about that flag, just the better, pretend it doesn't
  exist.
  
  =item 4. A "Unicode String" is simply a string where each character can be
  validly interpreted as a Unicode code point.
  
  If you have UTF-8 encoded data, it is no longer a Unicode string, but a
  Unicode string encoded in UTF-8, giving you a binary string.
  
  =item 5. A string containing "high" (> 255) character values is I<not> a UTF-8 string.
  
  It's a fact. Learn to live with it.
  
  =back
  
  I hope this helps :)
  
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =over 4
  
  =item $json = new JSON::XS
  
  Creates a new JSON::XS object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON::XS->new->utf8->space_after->encode ({a => [1,2]})
     => {"a": [1, 2]}
  
  =item $json = $json->ascii ([$enable])
  
  =item $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON::XS->new->ascii (1)->encode ([chr 0x10401])
    => ["\ud801\udc01"]
  
  =item $json = $json->latin1 ([$enable])
  
  =item $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =item $json = $json->utf8 ([$enable])
  
  =item $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::XS->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::XS->new->decode (decode "UTF-32LE", $jsontext);
  
  =item $json = $json->pretty ([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  Example, pretty-print some simple structure:
  
     my $json = JSON::XS->new->pretty(1)->encode ({a => [1,2]})
     =>
     {
        "a" : [
           1,
           2
        ]
     }
  
  =item $json = $json->indent ([$enable])
  
  =item $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  =item $json = $json->space_before ([$enable])
  
  =item $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =item $json = $json->space_after ([$enable])
  
  =item $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =item $json = $json->relaxed ([$enable])
  
  =item $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =item $json = $json->canonical ([$enable])
  
  =item $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =item $json = $json->allow_nonref ([$enable])
  
  =item $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON::XS->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =item $json = $json->allow_unknown ([$enable])
  
  =item $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_nonref>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =item $json = $json->allow_blessed ([$enable])
  
  =item $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =item $json = $json->convert_blessed ([$enable])
  
  =item $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =item $json = $json->allow_tags ([$enable])
  
  =item $enabled = $json->allow_tags
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<FREEZE> method on
  the object's class. If found, it will be used to serialise the object into
  a nonstandard tagged JSON value (that JSON decoders cannot decode).
  
  It also causes C<decode> to parse such tagged JSON values and deserialise
  them via a call to the C<THAW> method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion, and tagged JSON values will cause a parse error
  in C<decode>, as if tags were not part of the grammar.
  
  =item $json = $json->filter_json_object ([$coderef->($hashref)])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to the
  newly-created hash. If the code references returns a single scalar (which
  need not be a reference), this value (i.e. a copy of that scalar to avoid
  aliasing) is inserted into the deserialised data structure. If it returns
  an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
  original deserialised hash will be inserted. This setting can slow down
  decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::XS->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]')
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =item $json = $json->filter_json_single_key_object ($key [=> $coderef->($value)])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::XS
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =item $json = $json->shrink ([$enable])
  
  =item $enabled = $json->get_shrink
  
  Perl usually over-allocates memory a bit when allocating space for
  strings. This flag optionally resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible. This can save
  memory when your JSON texts are either very very long or you have many
  short strings. It will also try to downgrade any strings to octet-form
  if possible: perl stores strings internally either in an encoding called
  UTF-X or in octet-form. The latter cannot store everything but uses less
  space in general (and some buggy Perl or C code might even rely on that
  internal representation being used).
  
  The actual definition of what shrink does might change in future versions,
  but it will always try to save space at the expense of time.
  
  If C<$enable> is true (or missing), the string returned by C<encode> will
  be shrunk-to-fit, while all strings generated by C<decode> will also be
  shrunk-to-fit.
  
  If C<$enable> is false, then the normal perl allocation algorithms are used.
  If you work with your data, then this is likely to be faster.
  
  In the future, this setting might control other things, such as converting
  strings that look like integers or floats into integers or floats
  internally (there is no difference on the Perl level), saving space.
  
  =item $json = $json->max_depth ([$maximum_nesting_depth])
  
  =item $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  Note that nesting is implemented by recursion in C. The default value has
  been chosen to be as large as typical operating systems allow without
  crashing.
  
  See SECURITY CONSIDERATIONS, below, for more info on why this is useful.
  
  =item $json = $json->max_size ([$maximum_string_size])
  
  =item $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See SECURITY CONSIDERATIONS, below, for more info on why this is useful.
  
  =item $json_text = $json->encode ($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =item $perl_scalar = $json->decode ($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =item ($perl_scalar, $characters) = $json->decode_prefix ($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON::XS->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =back
  
  
  =head1 INCREMENTAL PARSING
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  JSON::XS will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =over 4
  
  =item [void, scalar or list context] = $json->incr_parse ([$string])
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
     my @objs = JSON::XS->new->incr_parse ("[5][7][1,2]");
  
  =item $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =item $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =item $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =back
  
  =head2 LIMITATIONS
  
  All options that affect decoding are supported, except
  C<allow_nonref>. The reason for this is that it cannot be made to work
  sensibly: JSON objects and arrays are self-delimited, i.e. you can
  concatenate them back to back and still decode them perfectly. This does
  not hold true for JSON numbers, however.
  
  For example, is the string C<1> a single JSON number, or is it simply the
  start of C<12>? Or is C<12> a single JSON number, or the concatenation
  of C<1> and C<2>? In neither case you can tell, and this is why JSON::XS
  takes the conservative route and disallows this case.
  
  =head2 EXAMPLES
  
  Some examples will make all this clearer. First, a simple example that
  works similarly to C<decode_prefix>: We want to decode the JSON object at
  the start of a string and identify the portion after the JSON object:
  
     my $text = "[1,2,3] hello";
  
     my $json = new JSON::XS;
  
     my $obj = $json->incr_parse ($text)
        or die "expected JSON object or array at beginning of string";
  
     my $tail = $json->incr_text;
     # $tail now contains " hello"
  
  Easy, isn't it?
  
  Now for a more complicated example: Imagine a hypothetical protocol where
  you read some requests from a TCP stream, and each request is a JSON
  array, without any separation between them (in fact, it is often useful to
  use newlines as "separators", as these get interpreted as whitespace at
  the start of the JSON text, which makes it possible to test said protocol
  with C<telnet>...).
  
  Here is how you'd do it (it is trivial to write this in an event-based
  manner):
  
     my $json = new JSON::XS;
  
     # read some data from the socket
     while (sysread $socket, my $buf, 4096) {
  
        # split and decode as many requests as possible
        for my $request ($json->incr_parse ($buf)) {
           # act on the $request
        }
     }
  
  Another complicated example: Assume you have a string with JSON objects
  or arrays, all separated by (optional) comma characters (e.g. C<[1],[2],
  [3]>). To parse them, we have to skip the commas between the JSON texts,
  and here is where the lvalue-ness of C<incr_text> comes in useful:
  
     my $text = "[1],[2], [3]";
     my $json = new JSON::XS;
  
     # void context, so no parsing done
     $json->incr_parse ($text);
  
     # now extract as many objects as possible. note the
     # use of scalar context so incr_text can be called.
     while (my $obj = $json->incr_parse) {
        # do something with $obj
  
        # now skip the optional comma
        $json->incr_text =~ s/^ \s* , //x;
     }
  
  Now lets go for a very complex example: Assume that you have a gigantic
  JSON array-of-objects, many gigabytes in size, and you want to parse it,
  but you cannot load it into memory fully (this has actually happened in
  the real world :).
  
  Well, you lost, you have to implement your own JSON parser. But JSON::XS
  can still help you: You implement a (very simple) array parser and let
  JSON decode the array elements, which are all full JSON objects on their
  own (this wouldn't work if the array elements could be JSON numbers, for
  example):
  
     my $json = new JSON::XS;
  
     # open the monster
     open my $fh, "<bigfile.json"
        or die "bigfile: $!";
  
     # first parse the initial "["
     for (;;) {
        sysread $fh, my $buf, 65536
           or die "read error: $!";
        $json->incr_parse ($buf); # void context, so no parsing
  
        # Exit the loop once we found and removed(!) the initial "[".
        # In essence, we are (ab-)using the $json object as a simple scalar
        # we append data to.
        last if $json->incr_text =~ s/^ \s* \[ //x;
     }
  
     # now we have the skipped the initial "[", so continue
     # parsing all the elements.
     for (;;) {
        # in this loop we read data until we got a single JSON object
        for (;;) {
           if (my $obj = $json->incr_parse) {
              # do something with $obj
              last;
           }
  
           # add more data
           sysread $fh, my $buf, 65536
              or die "read error: $!";
           $json->incr_parse ($buf); # void context, so no parsing
        }
  
        # in this loop we read data until we either found and parsed the
        # separating "," between elements, or the final "]"
        for (;;) {
           # first skip whitespace
           $json->incr_text =~ s/^\s*//;
  
           # if we find "]", we are done
           if ($json->incr_text =~ s/^\]//) {
              print "finished.\n";
              exit;
           }
  
           # if we find ",", we can continue with the next element
           if ($json->incr_text =~ s/^,//) {
              last;
           }
  
           # if we find anything else, we have a parse error!
           if (length $json->incr_text) {
              die "parse error near ", $json->incr_text;
           }
  
           # else add more data
           sysread $fh, my $buf, 65536
              or die "read error: $!";
           $json->incr_parse ($buf); # void context, so no parsing
        }
  
  This is a complex example, but most of the complexity comes from the fact
  that we are trying to be correct (bear with me if I am wrong, I never ran
  the above example :).
  
  
  
  =head1 MAPPING
  
  This section describes how JSON::XS maps Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserve object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, JSON::XS will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, JSON::XS only guarantees precision up to but not including
  the least significant bit.
  
  =item true, false
  
  These JSON atoms become C<Types::Serialiser::true> and
  C<Types::Serialiser::false>, respectively. They are overloaded to act
  almost exactly like the numbers C<1> and C<0>. You can check whether
  a scalar is a JSON boolean by using the C<Types::Serialiser::is_bool>
  function (after C<use Types::Serialier>, of course).
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =item tagged values (C<< (I<tag>)I<value> >>).
  
  Another nonstandard extension to the JSON syntax, enabled with the
  C<allow_tags> setting, are tagged values. In this implementation, the
  I<tag> must be a perl package/class name encoded as a JSON string, and the
  I<value> must be a JSON array encoding optional constructor arguments.
  
  See L<OBJECT SERIALISATION>, below, for details.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. JSON::XS can optionally sort the hash keys
  (determined by the I<canonical> flag), so the same datastructure will
  serialise to the same JSON text (given same settings and version of
  JSON::XS), but this incurs a runtime overhead and is only rarely useful,
  e.g. when you want to compare some JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON.
  
  Since C<JSON::XS> uses the boolean model from L<Types::Serialiser>, you
  can also C<use Types::Serialiser> and then use C<Types::Serialiser::false>
  and C<Types::Serialiser::true> to improve readability.
  
     use Types::Serialiser;
     encode_json [\0, Types::Serialiser::true]      # yields [false,true]
  
  =item Types::Serialiser::true, Types::Serialiser::false
  
  These special values from the L<Types::Serialiser> module become JSON true
  and JSON false values, respectively. You can also use C<\1> and C<\0>
  directly if you want.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::XS>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a JSON string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a JSON number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways. Tell me
  if you need this capability (but don't forget to explain why it's needed
  :).
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As JSON cannot directly represent Perl objects, you have to choose between
  a pure JSON representation (without the ability to deserialise the object
  automatically again), and a nonstandard extension to the JSON syntax,
  tagged values.
  
  =head3 SERIALISATION
  
  What happens when C<JSON::XS> encounters a Perl object depends on the
  C<allow_blessed>, C<convert_blessed> and C<allow_tags> settings, which are
  used in this order:
  
  =over 4
  
  =item 1. C<allow_tags> is enabled and the object has a C<FREEZE> method.
  
  In this case, C<JSON::XS> uses the L<Types::Serialiser> object
  serialisation protocol to create a tagged JSON value, using a nonstandard
  extension to the JSON syntax.
  
  This works by invoking the C<FREEZE> method on the object, with the first
  argument being the object to serialise, and the second argument being the
  constant string C<JSON> to distinguish it from other serialisers.
  
  The C<FREEZE> method can return any number of values (i.e. zero or
  more). These values and the paclkage/classname of the object will then be
  encoded as a tagged JSON value in the following format:
  
     ("classname")[FREEZE return values...]
  
  e.g.:
  
     ("URI")["http://www.google.com/"]
     ("MyDate")[2013,10,29]
     ("ImageData::JPEG")["Z3...VlCg=="]
  
  For example, the hypothetical C<My::Object> C<FREEZE> method might use the
  objects C<type> and C<id> members to encode the object:
  
     sub My::Object::FREEZE {
        my ($self, $serialiser) = @_;
  
        ($self->{type}, $self->{id})
     }
  
  =item 2. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fatc that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 3. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 4. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  C<JSON::XS> throws an exception.
  
  =back
  
  =head3 DESERIALISATION
  
  For deserialisation there are only two cases to consider: either
  nonstandard tagging was used, in which case C<allow_tags> decides,
  or objects cannot be automatically be deserialised, in which
  case you can use postprocessing or the C<filter_json_object> or
  C<filter_json_single_key_object> callbacks to get some real objects our of
  your JSON.
  
  This section only considers the tagged value case: I a tagged JSON object
  is encountered during decoding and C<allow_tags> is disabled, a parse
  error will result (as if tagged values were not part of the grammar).
  
  If C<allow_tags> is enabled, C<JSON::XS> will look up the C<THAW> method
  of the package/classname used during serialisation (it will not attempt
  to load the package as a Perl module). If there is no such method, the
  decoding will fail with an error.
  
  Otherwise, the C<THAW> method is invoked with the classname as first
  argument, the constant string C<JSON> as second argument, and all the
  values from the JSON array (the values originally returned by the
  C<FREEZE> method) as remaining arguments.
  
  The method must then return the object. While technically you can return
  any Perl scalar, you might have to enable the C<enable_nonref> setting to
  make that work in all cases, so better return an actual blessed reference.
  
  As an example, let's implement a C<THAW> function that regenerates the
  C<My::Object> from the C<FREEZE> example earlier:
  
     sub My::Object::THAW {
        my ($class, $serialiser, $type, $id) = @_;
  
        $class->new (type => $type, id => $id)
     }
  
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  
  =head2 JSON and ECMAscript
  
  JSON syntax is based on how literals are represented in javascript (the
  not-standardised predecessor of ECMAscript) which is presumably why it is
  called "JavaScript Object Notation".
  
  However, JSON is not a subset (and also not a superset of course) of
  ECMAscript (the standard) or javascript (whatever browsers actually
  implement).
  
  If you want to use javascript's C<eval> function to "parse" JSON, you
  might run into parse errors for valid JSON texts, or the resulting data
  structure might not be queryable:
  
  One of the problems is that U+2028 and U+2029 are valid characters inside
  JSON strings, but are not allowed in ECMAscript string literals, so the
  following Perl fragment will not output something that can be guaranteed
  to be parsable by javascript's C<eval>:
  
     use JSON::XS;
  
     print encode_json [chr 0x2028];
  
  The right fix for this is to use a proper JSON parser in your javascript
  programs, and not rely on C<eval> (see for example Douglas Crockford's
  F<json2.js> parser).
  
  If this is not an option, you can, as a stop-gap measure, simply encode to
  ASCII-only JSON:
  
     use JSON::XS;
  
     print JSON::XS->new->ascii->encode ([chr 0x2028]);
  
  Note that this will enlarge the resulting JSON text quite a bit if you
  have many non-ASCII characters. You might be tempted to run some regexes
  to only escape U+2028 and U+2029, e.g.:
  
     # DO NOT USE THIS!
     my $json = JSON::XS->new->utf8->encode ([chr 0x2028]);
     $json =~ s/\xe2\x80\xa8/\\u2028/g; # escape U+2028
     $json =~ s/\xe2\x80\xa9/\\u2029/g; # escape U+2029
     print $json;
  
  Note that I<this is a bad idea>: the above only works for U+2028 and
  U+2029 and thus only for fully ECMAscript-compliant parsers. Many existing
  javascript implementations, however, have issues with other characters as
  well - using C<eval> naively simply I<will> cause problems.
  
  Another problem is that some javascript implementations reserve
  some property names for their own purposes (which probably makes
  them non-ECMAscript-compliant). For example, Iceweasel reserves the
  C<__proto__> property name for its own purposes.
  
  If that is a problem, you could parse try to filter the resulting JSON
  output for these property strings, e.g.:
  
     $json =~ s/"__proto__"\s*:/"__proto__renamed":/g;
  
  This works because C<__proto__> is not valid outside of strings, so every
  occurrence of C<"__proto__"\s*:> must be a string used as property name.
  
  If you know of other incompatibilities, please let me know.
  
  
  =head2 JSON and YAML
  
  You often hear that JSON is a subset of YAML. This is, however, a mass
  hysteria(*) and very far from the truth (as of the time of this writing),
  so let me state it clearly: I<in general, there is no way to configure
  JSON::XS to output a data structure as valid YAML> that works in all
  cases.
  
  If you really must use JSON::XS to generate YAML, you should use this
  algorithm (subject to change in future versions):
  
     my $to_yaml = JSON::XS->new->utf8->space_after (1);
     my $yaml = $to_yaml->encode ($ref) . "\n";
  
  This will I<usually> generate JSON texts that also parse as valid
  YAML. Please note that YAML has hardcoded limits on (simple) object key
  lengths that JSON doesn't have and also has different and incompatible
  unicode character escape syntax, so you should make sure that your hash
  keys are noticeably shorter than the 1024 "stream characters" YAML allows
  and that you do not have characters with codepoint values outside the
  Unicode BMP (basic multilingual page). YAML also does not allow C<\/>
  sequences in strings (which JSON::XS does not I<currently> generate, but
  other JSON generators might).
  
  There might be other incompatibilities that I am not aware of (or the YAML
  specification has been changed yet again - it does so quite often). In
  general you should not try to generate YAML with a JSON generator or vice
  versa, or try to parse JSON with a YAML parser or vice versa: chances are
  high that you will run into severe interoperability problems when you
  least expect it.
  
  =over 4
  
  =item (*)
  
  I have been pressured multiple times by Brian Ingerson (one of the
  authors of the YAML specification) to remove this paragraph, despite him
  acknowledging that the actual incompatibilities exist. As I was personally
  bitten by this "JSON is YAML" lie, I refused and said I will continue to
  educate people about these issues, so others do not run into the same
  problem again and again. After this, Brian called me a (quote)I<complete
  and worthless idiot>(unquote).
  
  In my opinion, instead of pressuring and insulting people who actually
  clarify issues with YAML and the wrong statements of some of its
  proponents, I would kindly suggest reading the JSON spec (which is not
  that difficult or long) and finally make YAML compatible to it, and
  educating users about the changes, instead of spreading lies about the
  real compatibility for many I<years> and trying to silence people who
  point out that it isn't true.
  
  Addendum/2009: the YAML 1.2 spec is still incompatible with JSON, even
  though the incompatibilities have been documented (and are known to Brian)
  for many years and the spec makes explicit claims that YAML is a superset
  of JSON. It would be so easy to fix, but apparently, bullying people and
  corrupting userdata is so much easier.
  
  =back
  
  
  =head2 SPEED
  
  It seems that JSON::XS is surprisingly fast, as shown in the following
  tables. They have been generated with the help of the C<eg/bench> program
  in the JSON::XS distribution, to make it easy to compare on your own
  system.
  
  First comes a comparison between various modules using
  a very short single-line JSON string (also available at
  L<http://dist.schmorp.de/misc/json/short.json>).
  
     {"method": "handleMessage", "params": ["user1",
     "we were just talking"], "id": null, "array":[1,11,234,-5,1e5,1e7,
     1,  0]}
  
  It shows the number of encodes/decodes per second (JSON::XS uses
  the functional interface, while JSON::XS/2 uses the OO interface
  with pretty-printing and hashkey sorting enabled, JSON::XS/3 enables
  shrink. JSON::DWIW/DS uses the deserialise function, while JSON::DWIW::FJ
  uses the from_json method). Higher is better:
  
     module        |     encode |     decode |
     --------------|------------|------------|
     JSON::DWIW/DS |  86302.551 | 102300.098 |
     JSON::DWIW/FJ |  86302.551 |  75983.768 |
     JSON::PP      |  15827.562 |   6638.658 |
     JSON::Syck    |  63358.066 |  47662.545 |
     JSON::XS      | 511500.488 | 511500.488 |
     JSON::XS/2    | 291271.111 | 388361.481 |
     JSON::XS/3    | 361577.931 | 361577.931 |
     Storable      |  66788.280 | 265462.278 |
     --------------+------------+------------+
  
  That is, JSON::XS is almost six times faster than JSON::DWIW on encoding,
  about five times faster on decoding, and over thirty to seventy times
  faster than JSON's pure perl implementation. It also compares favourably
  to Storable for small amounts of data.
  
  Using a longer test string (roughly 18KB, generated from Yahoo! Locals
  search API (L<http://dist.schmorp.de/misc/json/long.json>).
  
     module        |     encode |     decode |
     --------------|------------|------------|
     JSON::DWIW/DS |   1647.927 |   2673.916 |
     JSON::DWIW/FJ |   1630.249 |   2596.128 |
     JSON::PP      |    400.640 |     62.311 |
     JSON::Syck    |   1481.040 |   1524.869 |
     JSON::XS      |  20661.596 |   9541.183 |
     JSON::XS/2    |  10683.403 |   9416.938 |
     JSON::XS/3    |  20661.596 |   9400.054 |
     Storable      |  19765.806 |  10000.725 |
     --------------+------------+------------+
  
  Again, JSON::XS leads by far (except for Storable which non-surprisingly
  decodes a bit faster).
  
  On large strings containing lots of high Unicode characters, some modules
  (such as JSON::PC) seem to decode faster than JSON::XS, but the result
  will be broken due to missing (or wrong) Unicode handling. Others refuse
  to decode or encode properly, so it was impossible to prepare a fair
  comparison table for that case.
  
  
  =head1 SECURITY CONSIDERATIONS
  
  When you are using JSON in a protocol, talking to untrusted potentially
  hostile creatures requires relatively few measures.
  
  First of all, your JSON decoder should be secure, that is, should not have
  any buffer overflows. Obviously, this module should ensure that and I am
  trying hard on making that true, but you never know.
  
  Second, you need to avoid resource-starving attacks. That means you should
  limit the size of JSON texts you accept, or make sure then when your
  resources run out, that's just fine (e.g. by using a separate process that
  can crash safely). The size of a JSON text in octets or characters is
  usually a good indication of the size of the resources required to decode
  it into a Perl structure. While JSON::XS can check the size of the JSON
  text, it might be too late when you already have it in memory, so you
  might want to check the size before you accept the string.
  
  Third, JSON::XS recurses using the C stack when decoding objects and
  arrays. The C stack is a limited resource: for instance, on my amd64
  machine with 8MB of stack size I can decode around 180k nested arrays but
  only 14k nested JSON objects (due to perl itself recursing deeply on croak
  to free the temporary). If that is exceeded, the program crashes. To be
  conservative, the default nesting limit is set to 512. If your process
  has a smaller stack, you should adjust this setting accordingly with the
  C<max_depth> method.
  
  Something else could bomb you, too, that I forgot to think of. In that
  case, you get to keep the pieces. I am always open for hints, though...
  
  Also keep in mind that JSON::XS might leak contents of your Perl data
  structures in its error messages, so when you serialise sensitive
  information you might want to make sure that exceptions thrown by JSON::XS
  will not end up in front of untrusted eyes.
  
  If you are using JSON::XS to return packets to consumption
  by JavaScript scripts in a browser you should have a look at
  L<http://blog.archive.jpsykes.com/47/practical-csrf-and-json-security/> to
  see whether you are vulnerable to some common attack vectors (which really
  are browser design bugs, but it is still you who will have to deal with
  it, as major browser developers care only for features, not about getting
  security right).
  
  
  =head1 INTEROPERABILITY WITH OTHER MODULES
  
  C<JSON::XS> uses the L<Types::Serialiser> module to provide boolean
  constants. That means that the JSON true and false values will be
  comaptible to true and false values of iother modules that do the same,
  such as L<JSON::PP> and L<CBOR::XS>.
  
  
  =head1 THREADS
  
  This module is I<not> guaranteed to be thread safe and there are no
  plans to change this until Perl gets thread support (as opposed to the
  horribly slow so-called "threads" which are simply slow and bloated
  process simulations - use fork, it's I<much> faster, cheaper, better).
  
  (It might actually work, but you have been warned).
  
  
  =head1 THE PERILS OF SETLOCALE
  
  Sometimes people avoid the Perl locale support and directly call the
  system's setlocale function with C<LC_ALL>.
  
  This breaks both perl and modules such as JSON::XS, as stringification of
  numbers no longer works correctly (e.g. C<$x = 0.1; print "$x"+1> might
  print C<1>, and JSON::XS might output illegal JSON as JSON::XS relies on
  perl to stringify numbers).
  
  The solution is simple: don't call C<setlocale>, or use it for only those
  categories you need, such as C<LC_MESSAGES> or C<LC_CTYPE>.
  
  If you need C<LC_NUMERIC>, you should enable it only around the code that
  actually needs it (avoiding stringification of numbers), and restore it
  afterwards.
  
  
  =head1 BUGS
  
  While the goal of this module is to be correct, that unfortunately does
  not mean it's bug-free, only that I think its design is bug-free. If you
  keep reporting bugs they will be fixed swiftly, though.
  
  Please refrain from using rt.cpan.org or any other bug reporting
  service. I put the contact address into my modules for a reason.
  
  =cut
  
  BEGIN {
     *true    = \$Types::Serialiser::true;
     *true    = \&Types::Serialiser::true;
     *false   = \$Types::Serialiser::false;
     *false   = \&Types::Serialiser::false;
     *is_bool = \&Types::Serialiser::is_bool;
  
     *JSON::XS::Boolean:: = *Types::Serialiser::Boolean::;
  }
  
  XSLoader::load "JSON::XS", $VERSION;
  
  =head1 SEE ALSO
  
  The F<json_xs> command line utility for quick experiments.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
X86_64-LINUX_JSON_XS

$fatpacked{"x86_64-linux/JSON/XS/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_JSON_XS_BOOLEAN';
  =head1 NAME
  
  JSON::XS::Boolean - dummy module providing JSON::XS::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and
  similar modules. It's only needed for compatibility with data serialised
  (by other modules such as Storable) that was decoded by JSON::XS versions
  before 3.0.
  
  Since 3.0, JSON::PP::Boolean has replaced it. Support for
  JSON::XS::Boolean will be removed in a future release.
  
  =cut
  
  use JSON::XS ();
  
  1;
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
X86_64-LINUX_JSON_XS_BOOLEAN

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.49";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.49";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/PerlIO/utf8_strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PERLIO_UTF8_STRICT';
  package PerlIO::utf8_strict;
  $PerlIO::utf8_strict::VERSION = '0.006';
  use strict;
  use warnings;
  
  use XSLoader;
  
  XSLoader::load(__PACKAGE__, __PACKAGE__->VERSION);
  
  1;
  
  #ABSTRACT: Fast and correct UTF-8 IO
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  PerlIO::utf8_strict - Fast and correct UTF-8 IO
  
  =head1 VERSION
  
  version 0.006
  
  =head1 SYNOPSIS
  
   open my $fh, '<:utf8_strict', $filename;
  
  =head1 DESCRIPTION
  
  This module provides a fast and correct UTF-8 PerlIO layer. Unlike perl's default C<:utf8> layer it checks the input for correctness.
  
  =head1 LAYER ARGUMENTS
  
  =over 4
  
  =item allow_noncharacters
  
  =item allow_surrogates
  
  =back
  
  =head1 EXPORT
  
  PerlIO::utf8_strict exports no subroutines or symbols, just a perl layer C<utf8_strict>
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Can't decode ill-formed UTF-8 octet sequence <%s>
  
  (F) Encountered an ill-formed UTF-8 octet sequence. <%s> contains a hexadecimal 
  representation of the maximal subpart of the ill-formed subsequence.
  
  =item Can't interchange noncharacter code point U+%.4X
  
  (F) Noncharacters is permanently reserved for internal use and that should 
  never be interchanged. Noncharacters consist of the values U+nFFFE and U+nFFFF 
  (where n is from 0 to 10^16) and the values U+FDD0..U+FDEF.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Leon Timmermans <leont@cpan.org>
  
  =item *
  
  Christian Hansen <chansen@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Leon Timmermans, Christian Hansen.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX_PERLIO_UTF8_STRICT

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.49";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.49";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.+?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

$fatpacked{"x86_64-linux/common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_COMMON_SENSE';
  package common::sense;
  
  our $VERSION = 3.73;
  
  # overload should be included
  
  sub import {
     local $^W; # work around perl 5.16 spewing out warnings for next statement
     # use warnings
     ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x0c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00\x00\x00\xc0";
     # use strict, use utf8; use feature;
     $^H |= 0x1c820fc0;
     @^H{qw(feature_evalbytes feature___SUB__ feature_unicode feature_state feature_switch feature_say feature_fc)} = (1) x 7;
  }
  
  1
X86_64-LINUX_COMMON_SENSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

# -*- cperl -*-

use Test::More;
use Git;
use Term::ANSIColor qw(:constants);
use JSON;

use File::Slurper qw(read_text);
use YAML qw(LoadFile);

use v5.14; # For say

my $student_repo = Git->repository ( Directory => '.' );
my $hito = $ENV{'objetivo'};

my @repo_files = $student_repo->command("ls-files");

doing( "Hito 0 de $hito");
for my $f (qw( .gitignore README.md LICENSE ) ) {
  ok grep( $f, @repo_files ), "Fichero $f presente";
}

done_testing() if $hito <= 0;

doing( "Hito 1 de $hito" );
# Fase 2
my ($readme_file) = grep( /^README/, @repo_files );
my $README =  read_text( $readme_file );
my $cc;

eval { $cc = LoadFile("cc.yaml"); };

say "Error $@ leyendo cc.yaml" unless $cc;

ok( $cc, "cc.yaml ledo sin problemas");

if ( $cc ) {
  for my $k (qw(lenguaje entidad)) {
    ok( $cc->{$k}, "Clave $k presente en cc.yaml" );
  }
}

my $entidad = $cc->{'entidad'};

say "Entidad $entidad";
ok( (ref($entidad) eq 'ARRAY') or (ref( $entidad ) eq 'SCALAR' ), "entidad en cc.yaml es del tipo correcto" );
file_present( $entidad, \@repo_files, "entidad" );

done_testing();


# ------------------------------- Subs -----------------------------------
sub doing {
  my $what = shift;
  diag "\n\t Comprobando $what\n";
}

sub check {
  return BOLD.GREEN ." ".RESET.join(" ",@_);
}

sub fail_x {
  return BOLD.MAGENTA."".RESET.join(" ",@_);
}

sub travis_status {
  my $README = shift;
  my ($build_status) = ($README =~ /Build Status..([^\)]+)\)/);
  my $status_svg = `curl -L -s $build_status`;
  return $status_svg =~ /passing/?"Passing":"Fail";
}

sub check_ip {
  my $ip = shift;
  if ( $ip ) {
    diag "\n\t".check( "Detectada direccin de despliegue $ip" )."\n";
  } else {
    diag "\n\t".fail_x( "Problemas detectando direccin de despliegue" )."\n";
  }
  my $pinger = Net::Ping->new();
  $pinger->port_number(22); # Puerto ssh
  isnt($pinger->ping($ip), 0, "$ip es alcanzable");
}

sub file_present {
  my ($file, $ls_files_ref, $name ) = @_;
  my @files = (ref($file) eq 'ARRAY')?@$file:($file);
  for my $file (@files ) {
    ok( grep( /$file/, @$ls_files_ref ), "Fichero $name  $file presente" );
  }
}
